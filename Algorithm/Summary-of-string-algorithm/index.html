<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>一些字符串算法小结 | 2inf</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- modified--><link rel="stylesheet" type="text/css" href="/css/atom-one-dark.min.css?v=0.0.0"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script><!----><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">一些字符串算法小结</h1><a id="logo" href="/.">2inf</a><p class="description">wtyang的数学与cs之旅</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/" target="_self"><i class="fa fa-archive"> 归档</i></a><a href="/tags/" target="_self"><i class="fa fa-tags"> 标签</i></a><a href="/about/" target="_self"><i class="fa fa-user"> 关于</i></a><a href="https://note.2inf.top" target="_self"><i class="fa fa-book"> 笔记</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">一些字符串算法小结</h1><div class="post-meta">2019-09-08<span> | </span><span class="category"><a href="/categories/Algorithm/">Algorithm</a></span></div><div class="post-content"><h1>回文串</h1>
<h2 id="manacher-算法"><a class="header-anchor" href="#manacher-算法">¶</a>$Manacher$算法</h2>
<p>  <s>众所周知</s>, $Manacher$算法是一个求字符串中最长回文子序列问题的算法, 可以想到一个比较显然的做法: 长度为奇数的回文串以最中间字符的位置为对称轴, 而长度为偶数的回文串的对称轴在中间两个字符之间的空隙处. 于是我们考虑遍历这些对称轴, 并且同时向左右扩展, 直到左右两边的字符不同或到达边界.</p>
<p>  这个算法的复杂度是$O(n^2)$, 是无法过一些较大数据范围的题, 我们来思考一下这个算法的缺点, 显然, 回文串长度的奇偶性造成了对称轴的位置可能在某字符上, 也可能在两个字符之间的空隙处，要对两种情况分别处理. 为了解决这个问题, 可以强行在原字符串中插入其他本字符串不会出现的字符, 如<code>&quot;#&quot;</code>.</p>
<a id="more"></a> 
<p>  对于整个算法的主体, 定义$p[i]$表示以字符$i$为回文中心的最长回文串的半径, 那么$p[i]-1$就是字符串中最长回文串的长度(除去<code>'#'</code>), 定义$maxr$为目前找到回文串的最右端, 中心为$id$, 当我们扫描到的位置$i$, 若$id\leq i\leq maxr$, 可以找到对称点$2<em>id-i$求出其最长半径, 那么$p[i] = \min(p[2</em>id-i], maxr-i)$</p>
<p><img src="/Algorithm/Summary-of-string-algorithm/manacher1.png" alt></p>
<p><a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">[模板]$Manacher$算法</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e7</span> + <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> n, ans, p[N];</span><br><span class="line"><span class="hljs-keyword">char</span> s[N], str[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    str[<span class="hljs-number">0</span>] = str[<span class="hljs-number">1</span>] = <span class="hljs-string">'#'</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        str[(i&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">2</span>] = s[i];</span><br><span class="line">        str[(i&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">3</span>] = <span class="hljs-string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = (n&lt;&lt;<span class="hljs-number">1</span>) + <span class="hljs-number">2</span>; str[n] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> maxr = <span class="hljs-number">0</span>, id = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; str[i] != <span class="hljs-number">0</span>; ++i) str[i] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (maxr &gt; i) p[i] = min(p[<span class="hljs-number">2</span>*id-i], maxr - i);</span><br><span class="line">        <span class="hljs-keyword">else</span> p[i] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; str[i+p[i]] == str[i-p[i]]; ++p[i]);</span><br><span class="line">        <span class="hljs-keyword">if</span> (p[i] + i &gt; maxr) &#123; maxr = p[i] + i; id = i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(s);</span><br><span class="line">    init();</span><br><span class="line">    manacher();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ans = max(ans, p[i]);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans - <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>String Matching Problem</h1>
<p> Given a text $T$ and a pattern $P$, if $n$=strlen($T$) &gt; strlen($P$) = $m$，find all of occurrences of $P$ within $T$。For example:</p>
<ul>
<li>T = ABC ABCDAB ABCD<font color="#FFFF00">ABCDABD</font>E</li>
<li>P = ABCDABD</li>
<li>$P$ appears one time in $T$</li>
</ul>
<p> We can easily get a naive method takes $O(nm)$ time，that is, initiate string comparison at every starting point, and each comparison takes $O(m)$ time.</p>
<h2 id="hash-function"><a class="header-anchor" href="#hash-function">¶</a>Hash Function</h2>
<p>  Hash function is a function that take a string and outputs a number(i.e. ASCII value). We take a constant number $B$, view the string as base-$B$ number, and distribute a positive number to denote a character. Take a const number $Mod$，use the base-$B$ number mod $Mod$ to get hash value.</p>
<p>$$h(x_1\cdots x_k)=x_1B<sup>{k-1}+x_2B</sup>{k-2}+\cdots+x_{k-1}B+x_k\pmod {Mod}$$</p>
<p>  A good hash function has few collisions. Generally, we take $B=131$ or $B=1331$, and that yields few collisions，we view string is the same as hash value is equal. If we take $Mod=2^{64}$, we can straight use $unsigned\ long\ long$ integer type to store hash value, automatically mod $2^{64}$ when get overfow error to avoid mod operation that takes time.</p>
<p>  To figure out the problem, we preprocess $P$ to speedup queries, figure out suffix hash value of $T$ to avoid hash every substing of length $m$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">2e9</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ull B = <span class="hljs-number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> a[N], b[N];</span><br><span class="line">ull Hash[N], hb;</span><br><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line"><span class="hljs-keyword">int</span> Next[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calcNext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="hljs-keyword">while</span> (j &amp;&amp; b[i] != b[j+<span class="hljs-number">1</span>]) j = Next[j];</span><br><span class="line">		<span class="hljs-keyword">if</span> (b[i] == b[j+<span class="hljs-number">1</span>]) j++;</span><br><span class="line">		Next[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, a + <span class="hljs-number">1</span>);</span><br><span class="line">	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, b + <span class="hljs-number">1</span>);</span><br><span class="line">	n = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>);</span><br><span class="line">	m = <span class="hljs-built_in">strlen</span>(b + <span class="hljs-number">1</span>);</span><br><span class="line">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i)</span><br><span class="line">		Hash[i] = a[i] + Hash[i+<span class="hljs-number">1</span>] * B;</span><br><span class="line">	ull base = <span class="hljs-number">1</span>;</span><br><span class="line">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		hb += base * b[i];</span><br><span class="line">		base *= B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - m + <span class="hljs-number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="hljs-keyword">if</span> (hb == Hash[i] - base * Hash[i + m])</span><br><span class="line">			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	calcNext();</span><br><span class="line">	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, Next[i]);</span><br><span class="line">	<span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="knuth-morris-pratt-algorithm"><a class="header-anchor" href="#knuth-morris-pratt-algorithm">¶</a><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Knuth–Morris–Pratt algorithm</a></h2>
<p> Knuth–Morris–Pratt algorithm, a linear time algorithm that solves the string matching problem by preprocessing P in $O(m)$ time. The main idea is to skip some comparisons by using the previous comparison result.</p>
<ol>
<li>Uses an auxiliary array $\pi$ that is defined as the following</li>
</ol>
<p>   - $\pi[i]$ is the largest integer smaller than i such that $P_1\dots P_{\pi[i]}$ is a suffix of $P_1\dots P_i$</p>
<ul>
<li>It’s better to see an example than the definition.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">$i$</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$P_i$</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">$\pi[i]$</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p> In the former problem $\pi=(0,0,0,0,1,2,0)$, we define$\pi[0]=-1$，Let’s see why this is useful in the .gif below.</p>
<p><img src="/Algorithm/Summary-of-string-algorithm/KMP1.gif" alt></p>
<p>Obviously, we can get some conclusions as follows</p>
<ul>
<li>
<p>if $P_1\dots P_{\pi[i]}$ is a suffix of $P_1\dots P_i$, then $P_1\dots P_{\pi[i]-1}$ is a suffix of $P_1\dots P_{i-1}$</p>
</li>
<li>
<p>all the prefixes of $P$ that are a suffix of $P_1\dots P_i$ can be obtained by recursively applying $\pi$ to $i$</p>
</li>
</ul>
<p>   - e.g., $P_1\dots P_{\pi[i]},P_1\dot P_{\pi[\pi[i]]},P_1\dots P_{\pi[\pi[\pi[i]]]}$ are all suffixes of $P_1\dots P_i$</p>
<ul>
<li>A non-obvious conclusion:</li>
</ul>
<p>   - First, let’s write $\pi^{(k)}[i]$ as $\pi[\cdot]$ applied k times to i.  e.g. $\pi^{(2)}[i]=\pi[\pi[i]]$</p>
<p>   - $\pi[i]$ is equal to $\pi^{(k)}[i-1]+1$, where $k$ is the smallest integer that satisfies $P_{\pi^{(k)}[i-1]+1}=P_i$</p>
<p>   - if there is no such $k$, $\pi[i]=0$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">function <span class="hljs-title">getfail</span><span class="hljs-params">(P)</span></span></span><br><span class="line"><span class="hljs-function">    m </span>= P.length</span><br><span class="line">    let fail[<span class="hljs-number">0.</span>..m<span class="hljs-number">-1</span>] be a <span class="hljs-keyword">new</span> <span class="hljs-built_in">array</span></span><br><span class="line">    fail[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span></span><br><span class="line">    match = <span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> to m - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> match &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> P[match+<span class="hljs-number">1</span>] != P[i]</span><br><span class="line">            match = fail[match]</span><br><span class="line">        <span class="hljs-keyword">if</span> P[match+<span class="hljs-number">1</span>] = P[i]</span><br><span class="line">            match += <span class="hljs-number">1</span></span><br><span class="line">        fail[i] = match</span><br><span class="line">    <span class="hljs-keyword">return</span> fail</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">fuction <span class="hljs-title">KMP</span><span class="hljs-params">(T, P)</span></span></span><br><span class="line"><span class="hljs-function">    fail </span>= getfail(P)</span><br><span class="line">    match = <span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to T.length - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> match &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> P[match+<span class="hljs-number">1</span>] != T[i]</span><br><span class="line">            match = fail[match]</span><br><span class="line">        <span class="hljs-keyword">if</span> P[match+<span class="hljs-number">1</span>] == T[i]</span><br><span class="line">            match += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> match + <span class="hljs-number">1</span> == m</span><br><span class="line">            <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Intuition: we look at all the prefixes of $P$ that are suffixes of $P_1\dots P_{i-1}$ and find the longest one whose next letter mathches $P_i$</li>
</ul>
<p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">[模板]$KMP$算法</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, Next[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (j &amp;&amp; b[i] != b[j+<span class="hljs-number">1</span>]) j = Next[j];</span><br><span class="line">        <span class="hljs-keyword">if</span> (b[i] == b[j+<span class="hljs-number">1</span>]) j++;</span><br><span class="line">        Next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, a + <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, b + <span class="hljs-number">1</span>);</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>), m = <span class="hljs-built_in">strlen</span>(b + <span class="hljs-number">1</span>);</span><br><span class="line">    calc();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] != b[j+<span class="hljs-number">1</span>]) j = Next[j];</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[i] == b[j+<span class="hljs-number">1</span>]) j++;</span><br><span class="line">        <span class="hljs-keyword">if</span> (j == m) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i - m + <span class="hljs-number">1</span>); j = Next[j];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, Next[i]);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>其他</h1>
<h2 id="trie-字典树"><a class="header-anchor" href="#trie-字典树">¶</a>$Trie$(字典树)</h2>
<p>  $Trie$是一种用于实现字符串快速检索的多叉树结构, 其基本操作如下:</p>
<ol>
<li>若$P$的$c$字符指针指向一个已经存在的节点$Q$, 则令$P=Q$</li>
<li>若$P$的$c$字符指针指向空, 则新建一个节点$Q$, 令$P$的$c$字符指针指向$Q$, 然后令$P=Q$</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> trie[N][<span class="hljs-number">26</span>], tot = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(str), p = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ch = str[k] - <span class="hljs-string">'a'</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(str), p = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">        p = trie[p][str[k]-<span class="hljs-string">'a'</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ans;</span><br><span class="line">        ans += ed[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ac-自动机"><a class="header-anchor" href="#ac-自动机">¶</a>$AC$自动机</h2>
<p>  很多聚聚都说$AC$自动机就是在$trie$树上进行$KMP$</p>
<h2 id="练习"><a class="header-anchor" href="#练习">¶</a>练习</h2>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><!--pspan= __('copyright_title_prefix')
= page.title--><p><span>文章作者：</span>wtyang</p><!--pspan= __('copyright_date_prefix')
= page.date.format(config.date_format)--><!--pspan= __('copyright_update_prefix')
= page.updated.format(config.date_format)--><p><span>原始链接：</span><a href="/Algorithm/Summary-of-string-algorithm/">https://2inf.top/Algorithm/Summary-of-string-algorithm/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://2inf.top/Algorithm/Summary-of-string-algorithm/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><i class="fa fa-tag"></i>字符串</a></div><div class="post-nav"><a class="pre" href="/Math/Theory-and-application-of-Catalan-Number/">Catalan数的原理与应用</a><a class="next" href="/Math/The-basis-of-combinatorics/">组合数学基础</a></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">2inf</a>&nbsp;|&nbsp;<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">湘ICP备20012049号-1 </a>|&nbsp;
<a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i>&nbsp;RSS Feed</a><div><link rel="stylesheet" type="text/css" href="/css/badge.css"/><div class="github-badge"><a rel="nofollow" target="_blank" href="https://hexo.io"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hexo</span></a></div>
<div class="github-badge"> <a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"><span class="badge-subject">Theme</span><span class="badge-value bg-orange">maupassant</span></a></div>
<div class="github-badge"> <a rel="nofollow" target="_blank" href="https://www.cnblogs.com/2inf/"><span class="badge-subject">cnblogs</span><span class="badge-value bg-blueviolet">2inf</span></a></div></div></div></div></div><div class="post-toc"><div class="post-toc-wrap"><div class="post-toc" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#manacher-算法"><span class="toc-number">1.1.</span> <span class="toc-text">¶$Manacher$算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">String Matching Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hash-function"><span class="toc-number">2.1.</span> <span class="toc-text">¶Hash Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#knuth-morris-pratt-algorithm"><span class="toc-number">2.2.</span> <span class="toc-text">¶Knuth–Morris–Pratt algorithm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#trie-字典树"><span class="toc-number">3.1.</span> <span class="toc-text">¶$Trie$(字典树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ac-自动机"><span class="toc-number">3.2.</span> <span class="toc-text">¶$AC$自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#练习"><span class="toc-number">3.3.</span> <span class="toc-text">¶练习</span></a></li></ol></li></ol></div></div><div class="post-toc-toggle-wrap open" id="right-toggle"><div class="post-toc-toggle-first post-toc-toggle"></div><div class="post-toc-toggle-second post-toc-toggle"></div><div class="post-toc-toggle-thrid post-toc-toggle"></div></div><script type="text/javascript" src="/js/sidebar.js?v=0.0.0" async></script></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
  TeX: {equationNumbers: { autoNumber: ['AMS'], useLabelIds: true }},
  'HTML-CSS': { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } }
  });
</script><!--script(type='text/javascript', src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', async)--><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script>hljs.initHighlightingOnLoad();</script><script type="text/javascript" src="/js/app.js?v=0.0.0"></script></div></body></html>