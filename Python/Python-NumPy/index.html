<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Python科学计算-NumPy | 2inf</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- modified--><link rel="stylesheet" type="text/css" href="/css/atom-one-dark.min.css?v=0.0.0"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script><!----><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python科学计算-NumPy</h1><a id="logo" href="/.">2inf</a><p class="description">wtyangのスペース(spread nonsense)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/" target="_self"><i class="fa fa-archive"> 归档</i></a><a href="/tags/" target="_self"><i class="fa fa-tags"> 标签</i></a><a href="/about/" target="_self"><i class="fa fa-user"> 关于</i></a><a href="https://note.2inf.top" target="_self"><i class="fa fa-book"> 笔记</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Python科学计算-NumPy</h1><div class="post-meta">2020-05-31<span> | </span><span class="category"><a href="/categories/Python/">Python</a></span></div><div class="post-content"><p>参考文献:</p>
<ol type="1">
<li><p><a href="https://numpy.org/doc/stable/reference/index.html" target="_blank" rel="noopener">NumPy Reference</a></p></li>
<li><p><a href="https://numpy.org/doc/stable/user/index.html" target="_blank" rel="noopener">NumPy User Guide</a></p></li>
<li><p><a href="https://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">Python Numpy Tutorial (with Jupyter and Colab)</a></p></li>
<li><p><a href="https://www.runoob.com/numpy/numpy-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p></li>
<li><p><a href="https://aistudio.baidu.com/aistudio/projectDetail/118377" target="_blank" rel="noopener">挑战NumPy100关</a></p></li>
</ol>
<hr>
<p>  我们知道 Python 用 list 结构保存一组值，可以当作数组用，列表的元素可以是任何对象，因此列表中保存的是对象的指针。对数值运算而言，这种结构比较耗费内存和CPU。此外还有 array 模块，能直接保存数值，但不支持多维数组，也没有各种运算函数，也不适合做数值运算。</p>
<p>  NumPy 的诞生弥补了这些不足，它提供 ndarray(n-dimensional array object) 和 ufunc(universal function object) 两种基本对象。以下为本文的导入方式和 NumPy 版本号:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.__version__</span><br><span class="line"><span class="hljs-string">'1.16.4'</span></span><br></pre></td></tr></table></figure>
<h1 id="ndarray-对象">ndarray 对象</h1>
<h2 id="创建">创建</h2>
<p>  通过给 array()函数传递 Python 的序列对象来创建数组。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = np.array((<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</span><br></pre></td></tr></table></figure>
<p>  数组的形状通过 shape 属性获得 它是一个描述数组各个轴的长度的元组(tuple):</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.shape b.shape c.shape</span><br><span class="line">(<span class="hljs-number">4</span>,)    (<span class="hljs-number">4</span>,)    (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span><br></pre></td></tr></table></figure>
<p>  下面的例子将数组c 的 shape 属性改为(4,3)，并不是对数组进行转置，而是改变每个轴大小，数组元素在内存中的位置并没有改变。此外，当设置某个轴元素个数为-1时，将自动计算此轴长度。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.shape = <span class="hljs-number">4</span>, <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c</span><br><span class="line">array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</span><br></pre></td></tr></table></figure>
<p>  使用数组的 reshape()方法，可以创建指定形状的新数组，而原数组形状保持不变。数组 a 和 d 共享数据存储空间，修改任意一个数组元素会同时修改另一个数组的内容。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>d = a.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span></span><br><span class="line">     d             a</span><br><span class="line">------------ --------------</span><br><span class="line">[[  <span class="hljs-number">1</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line"> [  <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="元素类型">元素类型</h2>
<p>  数组的元素类型可以通过 dtype 属性获得。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.dtype</span><br><span class="line">dtype(<span class="hljs-string">'int32'</span>)</span><br></pre></td></tr></table></figure>
<p>  可以通过 dtype 参数在创建数组时指定元素类型，注意 float 是 64 位的双精度浮点类型，complex 是 128 位的双精度复数类型。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ai32 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=np.int32)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>af = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=float)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ac = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=complex)</span><br><span class="line">ai32.dtype af.dtype ac.dtype</span><br><span class="line">int32      float64  complex128</span><br></pre></td></tr></table></figure>
<p>  在需要指定 dtype 参数时，也可以传递一个字符串来表示元素的数值类型。NumPy 中的每个数值类型都有几种字符串表示方式，字符串和类型之间的对应关系储存在 typeDict 字典中。下面例子获得与 float64 类型对应的所有键值:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>[key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> np.typeDict.items() <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> np.float64]</span><br><span class="line">[<span class="hljs-string">'double'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'float64'</span>, <span class="hljs-string">'Float64'</span>, <span class="hljs-string">'f8'</span>, <span class="hljs-string">'float_'</span>, <span class="hljs-string">'float'</span>]</span><br></pre></td></tr></table></figure>
<p>  完整的类型列表通过下面的语句得到。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(np.typeDict.values())</span><br><span class="line">---</span><br><span class="line">&#123;numpy.bool_, numpy.bytes_, numpy.complex128, numpy.complex128,</span><br><span class="line"> numpy.complex64, numpy.datetime64, numpy.float16, numpy.float32,</span><br><span class="line"> numpy.float64, numpy.float64, numpy.int16, numpy.int32,</span><br><span class="line"> numpy.int32, numpy.int64, numpy.int8, numpy.object_,</span><br><span class="line"> numpy.str_, numpy.timedelta64, numpy.uint16, numpy.uint32,</span><br><span class="line"> numpy.uint32, numpy.uint64, numpy.uint8, numpy.void&#125;</span><br></pre></td></tr></table></figure>
<p>  上面显示的数值类型与数组的 dtype 属性是不同的对象。通过 dtype 对象的 type 属性可以获得与其对应的数值类型:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.dtype.type</span><br><span class="line">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">int32</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>  下面创建一个 16 位(<span class="math inline">\(-2^{15}\sim2^{15}-1\)</span>)的符号整数对象，计算 <span class="math inline">\(200*200\)</span> 会溢出，得到一个负数 <span class="math inline">\(200*200-2^{16}\)</span> 。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.int16(<span class="hljs-number">200</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a*a</span><br><span class="line">__main__:<span class="hljs-number">1</span>: RuntimeWarning: overflow encountered <span class="hljs-keyword">in</span> short_scalars</span><br><span class="line"><span class="hljs-number">-25536</span></span><br></pre></td></tr></table></figure>
<p>  NumPy 的数值对象的运算速度比 Python 的内置类型的运算速度慢很多，如果程序中需要大量地对单个数值运算，应避免使用 NumPy 的数值对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="hljs-number">3.14</span></span><br><span class="line">v2 = np.float64(v1)</span><br><span class="line">%timeit v1*v1</span><br><span class="line">%timeit v2*v2</span><br><span class="line">---</span><br><span class="line"><span class="hljs-number">85.1</span> ns ± <span class="hljs-number">4.1</span> ns per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10000000</span> loops each)</span><br><span class="line"><span class="hljs-number">159</span> ns ± <span class="hljs-number">10.3</span> ns per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10000000</span> loops each)</span><br></pre></td></tr></table></figure>
<p>  使用 astype() 方法可以对数组元素类型进行转换:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=np.float)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t2 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=np.complex)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t3 = t1.astype(np.int32)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t4 = t2.astype(np.complex64)</span><br></pre></td></tr></table></figure>
<h2 id="自动生成数组">自动生成数组</h2>
<p>  前面的例子都是先创建一个 Python 的序列对象，然后通过array()将其转换为数组，这样做显然效率不高。因此NumPy 提供了很多专门用于创建数组的函数。</p>
<p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html" target="_blank" rel="noopener">arange()</a>类似于内置函数 range()，通过指定开始值、终值和步长来创建表示等差数列的一维数组。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>)</span><br><span class="line">array([<span class="hljs-number">0.</span> , <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>])</span><br></pre></td></tr></table></figure>
<p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html" target="_blank" rel="noopener">linspace()</a>通过指定开始值、终值和元素个数来创建表示等差数列的一维数组，可通过默认位 True 的 endpoint 参数指定是否包含终值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)</span><br><span class="line">array([<span class="hljs-number">0.</span>        , <span class="hljs-number">0.11111111</span>, <span class="hljs-number">0.22222222</span>, <span class="hljs-number">0.33333333</span>, <span class="hljs-number">0.44444444</span>,</span><br><span class="line">       <span class="hljs-number">0.55555556</span>, <span class="hljs-number">0.66666667</span>, <span class="hljs-number">0.77777778</span>, <span class="hljs-number">0.88888889</span>, <span class="hljs-number">1.</span>        ])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, endpoint=<span class="hljs-keyword">False</span>)</span><br><span class="line">array([<span class="hljs-number">0.</span> , <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>])</span><br></pre></td></tr></table></figure>
<p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.logspace.html" target="_blank" rel="noopener">logspace()</a>和 linspace()类似，不过创建的是等比数列。下面的例子为从 <span class="math inline">\(10^0\)</span> 到 <span class="math inline">\(10^2\)</span>、有 5 个元素的等比数列。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.logspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>)</span><br><span class="line">array([  <span class="hljs-number">1.</span>        ,   <span class="hljs-number">3.16227766</span>,  <span class="hljs-number">10.</span>        ,  <span class="hljs-number">31.6227766</span> ,</span><br><span class="line">       <span class="hljs-number">100.</span>        ])</span><br></pre></td></tr></table></figure>
<p>  基数可以通过 base 参数指定，默认值为 10。下面创建一个比例为 <span class="math inline">\(2^{1/12}\)</span> 的等比数组，其比值为音乐中相差半音的两个音阶之间的频率比值，可用于计算一个八度中所有半音的频率。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.logspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, base=<span class="hljs-number">2</span>, endpoint=<span class="hljs-keyword">False</span>)</span><br><span class="line">array([<span class="hljs-number">1.</span>        , <span class="hljs-number">1.05946309</span>, <span class="hljs-number">1.12246205</span>, <span class="hljs-number">1.18920712</span>, <span class="hljs-number">1.25992105</span>,</span><br><span class="line">       <span class="hljs-number">1.33483985</span>, <span class="hljs-number">1.41421356</span>, <span class="hljs-number">1.49830708</span>, <span class="hljs-number">1.58740105</span>, <span class="hljs-number">1.68179283</span>,</span><br><span class="line">       <span class="hljs-number">1.78179744</span>, <span class="hljs-number">1.88774863</span>])</span><br></pre></td></tr></table></figure>
<p>  zeros()、ones()、empty()，eye()可以创建指定形状和类型的数组。其中empty()只分配数组所使用的内存，不对数组元素进行初始化操作，因此它的运行速度是最快的。zeros()将元素初始化为 0，ones()将数组元素初始化为 1。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.empty((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), np.int)</span><br><span class="line">array([[   <span class="hljs-number">4063294</span>,    <span class="hljs-number">2097214</span>, <span class="hljs-number">1469448192</span>],</span><br><span class="line">       [     <span class="hljs-number">32760</span>, <span class="hljs-number">1469454912</span>,      <span class="hljs-number">32760</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.zeros(<span class="hljs-number">4</span>, np.int)</span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])</span><br></pre></td></tr></table></figure>
<p>  full()将数组元素初始化为指定的值:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.full(<span class="hljs-number">4</span>, np.pi)</span><br><span class="line">array([<span class="hljs-number">3.14159265</span>, <span class="hljs-number">3.14159265</span>, <span class="hljs-number">3.14159265</span>, <span class="hljs-number">3.14159265</span>])</span><br></pre></td></tr></table></figure>
<p>  此外，zeros_like()、ones_like()、empty_like()等函数可创建与参数数组的形状及类型相同的数组。因此，zeros_like(a)和 zeros(a.shape, a.dtype)的效果相同。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">3</span>, dtype=float)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.zeros_like(a)</span><br><span class="line">array([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>])</span><br></pre></td></tr></table></figure>
<p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.frombuffer.html" target="_blank" rel="noopener">frombuffer()</a>、<a href="https://numpy.org/devdocs/reference/generated/numpy.fromstring.html" target="_blank" rel="noopener">fromstring()</a>、<a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html" target="_blank" rel="noopener">fromfile()</a>等函数可以从字节序列或文件创建数组，下面以 fromstring()为例介绍它们的用法。Python 的字符串实际上是一个字节序列，每个字符占一个字节，因此如果从字符串s 创建一个 8 位的整数数组，所得到的数组正好就是字符串中每个字符的 ASCII 编码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">"abcdefgh"</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.fromstring(s, dtype=np.int8)</span><br><span class="line">__main__:<span class="hljs-number">1</span>: DeprecationWarning: The binary mode of fromstring <span class="hljs-keyword">is</span> deprecated, <span class="hljs-keyword">as</span> it behaves surprisingly on unicode inputs. Use frombuffer instead</span><br><span class="line">array([ <span class="hljs-number">97</span>,  <span class="hljs-number">98</span>,  <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>], dtype=int8)</span><br></pre></td></tr></table></figure>
<p>  如果从字符串 s 创建 16 位的整数数组，那么两个相邻的字节就表示一个整数，把字节 98 和字节 97 当作一个16 位的整数，它的值就是<span class="math inline">\(98*256+97=25185\)</span>。可以看出，16 位的整数是以低位字节在前(little-endian)的方式保存在内存中的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.fromstring(s, dtype=np.int16)</span><br><span class="line">array([<span class="hljs-number">25185</span>, <span class="hljs-number">25699</span>, <span class="hljs-number">26213</span>, <span class="hljs-number">26727</span>], dtype=int16)</span><br></pre></td></tr></table></figure>
<p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html" target="_blank" rel="noopener">fromfunction()</a>通过函数创建数组，第一个参数为计算数组元素的函数，第二个参数为 shape。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.fromfunction(<span class="hljs-keyword">lambda</span> i: i % <span class="hljs-number">4</span> + <span class="hljs-number">1</span>, (<span class="hljs-number">10</span>,), dtype=int)</span><br><span class="line">array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], dtype=int32)</span><br></pre></td></tr></table></figure>
<h2 id="存取元素">存取元素</h2>
<p>  NumPy 切片语法类似于 Python 列表的标准切片语法，即数组 x 切片获取方式：x[start:stop:step]，因此将数组颠倒即 x[::-1]。除了使用切片存取元素之外，NumPy 还提供了整数列表和布尔数组等下标存取方式。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = x[[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">8</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="hljs-number">10</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure>
<p>  整数序列下标也可以用来修改元素的值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]] = <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="hljs-number">10</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">-2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure>
<p>  当下标是多维数组时，得到的也是多维数组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[np.array([[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">8</span>]])]</span><br><span class="line">array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">8</span>]].reshape(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>  下面是 bool 数组的例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[np.array([<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>])]</span><br><span class="line">array([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[x &gt; <span class="hljs-number">5</span>]</span><br><span class="line">array([<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>])</span><br></pre></td></tr></table></figure>
<h2 id="多维数组">多维数组</h2>
<p>  多维数组与一维数组类似，NumPy 采用元组作为数组的下标。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">10</span>).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>) + np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],</span><br><span class="line">       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>],</span><br><span class="line">       [<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>, <span class="hljs-number">35</span>],</span><br><span class="line">       [<span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>],</span><br><span class="line">       [<span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">54</span>, <span class="hljs-number">55</span>]])</span><br><span class="line">---</span><br><span class="line">a[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>]     a[<span class="hljs-number">4</span>:, <span class="hljs-number">4</span>:]        a[:, <span class="hljs-number">2</span>]                         a[<span class="hljs-number">2</span>::<span class="hljs-number">2</span>, ::<span class="hljs-number">2</span>]</span><br><span class="line">array([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) array([[<span class="hljs-number">44</span>, <span class="hljs-number">45</span>], array([ <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>, <span class="hljs-number">52</span>]) array([[<span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">24</span>],</span><br><span class="line">                     [<span class="hljs-number">54</span>, <span class="hljs-number">55</span>]])                                       [<span class="hljs-number">40</span>, <span class="hljs-number">42</span>, <span class="hljs-number">44</span>]])</span><br></pre></td></tr></table></figure>
<p>  如果下标元组中只包含整数和切片，那么得到的数组和原始数组共享数据，它是原数组的视图。下面的例子中，数组 b 是 a 的视图，它们共享数据，因此修改 b[0]时，数组 a 中对应的元素也被修改：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = a[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">0</span>] = -b[<span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>]</span><br><span class="line">array([<span class="hljs-number">-3</span>,  <span class="hljs-number">4</span>])</span><br></pre></td></tr></table></figure>
<p>  因为数组的下标是一个元组，所以我们可以将下标元组保存起来，用同一个元组存取多个数组。下面的例子中，a[idx]和 a[::2, 2:]相同，a[idx][idx]和 a[::2, 2:][::2, 2:]相同。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>idx = slice(<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-number">2</span>), slice(<span class="hljs-number">2</span>, <span class="hljs-keyword">None</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[idx]</span><br><span class="line">array([[ <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>],</span><br><span class="line">       [<span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[idx][idx]</span><br><span class="line">array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">44</span>, <span class="hljs-number">45</span>]])</span><br></pre></td></tr></table></figure>
<p>  用 Python 内置的 slice() 函数创建下标比较麻烦，因此 NumPy 提供了一个 s_对象来帮助我们创建数组下标，s_实际上是 IndexExpression 类的一个对象：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.s_[::<span class="hljs-number">2</span>, <span class="hljs-number">2</span>:]</span><br><span class="line">(slice(<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-number">2</span>), slice(<span class="hljs-number">2</span>, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>))</span><br></pre></td></tr></table></figure>
<p>  在多维数组的下标元组中，也可以使用整数元组或列表、整数数组和布尔数组。当在下标中使用这些对象时，所获得的数据是原始数据的副本，因此修改结果数组不会改变原始数组。</p>
<p><img src="/Python/Python-NumPy/Python-NumPy1.jpg"></p>
<p>  当所有轴都用形状相同的整数数组作为下标时，得到的数组和下标数组的形状相同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[x, y]</span><br><span class="line">array([[ <span class="hljs-number">5</span>, <span class="hljs-number">14</span>],</span><br><span class="line">       [<span class="hljs-number">23</span>, <span class="hljs-number">32</span>]])</span><br><span class="line"><span class="hljs-comment"># or</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>)].reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="结构数组">结构数组</h2>
<p>  在C语言中可以通过 struct 关键字定义结构类型，结构中的字段占据连续的内存空间。类型相同的两个结构体所占用的内存大小相同，因此可以很容易定义结构数组。与C语言类似，NumPy 中也很容易对这种结构数组进行操作。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">persontype = np.dtype(&#123; <span class="hljs-comment">#1</span></span><br><span class="line">    <span class="hljs-string">'names'</span>:[<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'weight'</span>],</span><br><span class="line">    <span class="hljs-string">'formats'</span>:[<span class="hljs-string">'S32'</span>,<span class="hljs-string">'i'</span>, <span class="hljs-string">'f'</span>]&#125;, align=<span class="hljs-keyword">True</span>)</span><br><span class="line">a = np.array([(<span class="hljs-string">"Zhang"</span>, <span class="hljs-number">32</span>, <span class="hljs-number">75.5</span>), (<span class="hljs-string">"Wang"</span>, <span class="hljs-number">24</span>, <span class="hljs-number">65.2</span>)], <span class="hljs-comment">#2</span></span><br><span class="line">             dtype = persontype)</span><br></pre></td></tr></table></figure>
<p>  <strong>#1</strong> 先创建一个 dtype 对象 persontype，它的参数是一个描述结构类型的各个字段的字典。字典有两个键：'names'和'formats'。每个键对应的值都是一个列表。'names'定义结构中每个字段的名称，而'formats'则定义每个字段的类型。这里使用类型字符串定义字段类型：</p>
<ul>
<li><code>'S32'</code> ：长度为32 字节的字符串类型，由于结构中每个元素的大小必须固定，因此需要指定字符串的长度。</li>
<li><code>'i'</code> ：32 bit 的整数类型，相当于 np.int32。</li>
<li><code>'f'</code> ：32 bit 的单精度浮点数类型，相当于 np.float32。</li>
</ul>
<p>  <strong>#2</strong> 然后调用array()创建数组，通过 dtype 参数指定所创建数组的元素类型为 persontype。数组a 的元素类型：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'S32'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'weight'</span>, <span class="hljs-string">'&lt;f4'</span>)], align=<span class="hljs-keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>  因此还可以用多个元组的列表描述结构的类型：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persontype = np.dtype([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'|S32'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'weight'</span>, <span class="hljs-string">'&lt;f4'</span>)])</span><br></pre></td></tr></table></figure>
<p>  类型字符串前面的'|'、'&lt;'、'&gt;'等字符表示字段值的字节顺序：</p>
<ul>
<li><code>|</code> ：忽视字节顺序</li>
<li><code>&lt;</code> ：低位字节在前，即小端模式(little endian)</li>
<li><code>&gt;</code> ：高位字节在前，即大端模式(big endian)</li>
</ul>
<p>  下面的例子是两种修改方式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = a[<span class="hljs-number">1</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c[<span class="hljs-string">"name"</span>] = <span class="hljs-string">"Li"</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>][<span class="hljs-string">"name"</span>]</span><br><span class="line"><span class="hljs-string">b'Li'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = a[<span class="hljs-string">"age"</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">0</span>] = <span class="hljs-number">40</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>][<span class="hljs-string">"age"</span>]</span><br><span class="line"><span class="hljs-number">40</span></span><br></pre></td></tr></table></figure>
<p>  通过 a.tostring() 或 a.tofile() 方法，可以将数组 a 以二进制的方式转换成字符串或写入文件：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.tofile(<span class="hljs-string">"test.bin"</span>)</span><br></pre></td></tr></table></figure>
<p>  在 IPyton 中运行以下程序读取 test.bin 中数据。%%file 为 IPython 的 <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="noopener">magic command</a>, 它将单元格中文本保存成文件read_struct_array.c</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%%file read_struct_array.c</span><br><span class="line"><span class="hljs-comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">struct person &#123;</span><br><span class="line">    char name[<span class="hljs-number">30</span>];</span><br><span class="line">    int age;</span><br><span class="line">    float weight;</span><br><span class="line">&#125;p[<span class="hljs-number">3</span>];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="hljs-string">"test.bin"</span>, <span class="hljs-string">"rb"</span>);</span><br><span class="line">    fread(p, sizeof(struct person), <span class="hljs-number">2</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;</span><br><span class="line">        printf(<span class="hljs-string">"%s %d %f\n"</span>, p[i].name, p[i].age, p[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在 IPython 中可以通过!执行系统命令</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!gcc read_struct_array.c -o read_struct_array.exe</span><br><span class="line">!read_struct_array.exe</span><br><span class="line">---</span><br><span class="line">Zhang <span class="hljs-number">40</span> <span class="hljs-number">75.500000</span></span><br><span class="line">Li <span class="hljs-number">24</span> <span class="hljs-number">65.199997</span></span><br></pre></td></tr></table></figure>
<p>  结构类型中可以包括其他的结构类型，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.dtype([(<span class="hljs-string">'f1'</span>, [(<span class="hljs-string">'f2'</span>, <span class="hljs-string">'&lt;i2'</span>)])])</span><br><span class="line">dtype([(<span class="hljs-string">'f1'</span>, [(<span class="hljs-string">'f2'</span>, <span class="hljs-string">'&lt;i2'</span>)])])</span><br></pre></td></tr></table></figure>
<p>  当某个字段的类型为数组时，用元组的第三个参数表示其形状：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.dtype([(<span class="hljs-string">'f0'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'f1'</span>, <span class="hljs-string">'&lt;f8'</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))])</span><br><span class="line">dtype([(<span class="hljs-string">'f0'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'f1'</span>, <span class="hljs-string">'&lt;f8'</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))])</span><br></pre></td></tr></table></figure>
<p>  用下面的字典参数也可以定义结构类型，字典的键为结构中的字段名，值为字段的类型描述，但是由于字典的键是没有顺序的，因此字段的顺序需要在类型描述中给出。类型描述是一个元组，它的第二个值给出字段的以字节为单位的偏移量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.dtype(&#123;<span class="hljs-string">'name'</span>:(<span class="hljs-string">'S25'</span>, <span class="hljs-number">0</span>), <span class="hljs-string">'age'</span>:(np.uint8, <span class="hljs-number">25</span>)&#125;)</span><br><span class="line">dtype([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'S25'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'u1'</span>)])</span><br></pre></td></tr></table></figure>
<h1 id="ufunc-函数">ufunc 函数</h1>
<p>  ufunc 是一种能对数组每个元素进行运算的函数。NumPy 中许多函数都是由 C 语言编写，计算速度非常快。</p>
<h2 id="四则运算">四则运算</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">ufunc 函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">y=x1+x2</td>
<td style="text-align: center;">add(x1,x2[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=x1-x2</td>
<td style="text-align: center;">subtract(x1,x2[,y])</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y=x1*x2</td>
<td style="text-align: center;">multiply(x1,x2[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=x1/x2</td>
<td style="text-align: center;">divide(x1,x2[,y])</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y=x1/x2</td>
<td style="text-align: center;">true_divide(x1,x2[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=x1//x2</td>
<td style="text-align: center;">floor_divide(x1,x2[,y])</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y=-x</td>
<td style="text-align: center;">negative(x[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=x1**x2</td>
<td style="text-align: center;">power(x1,x2[,y])</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y=x1%x2</td>
<td style="text-align: center;">remainder(x1,x2[,y]), mod(x1,x2[,y])</td>
</tr>
</tbody>
</table>
<p>  一些例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x1 = np.arange(<span class="hljs-number">9.0</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x2 = np.arange(<span class="hljs-number">3.0</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.multiply(x1, x2)</span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">4.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">4.</span>, <span class="hljs-number">10.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">7.</span>, <span class="hljs-number">16.</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.divmod(np.arange(<span class="hljs-number">5</span>), <span class="hljs-number">3</span>)</span><br><span class="line">(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], dtype=int32), array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], dtype=int32))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.gcd(np.arange(<span class="hljs-number">6</span>), <span class="hljs-number">20</span>)</span><br><span class="line">array([<span class="hljs-number">20</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>])</span><br></pre></td></tr></table></figure>
<h2 id="比较运算和布尔运算">比较运算和布尔运算</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">ufunc 函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">y=(x1==x2)</td>
<td style="text-align: center;">equal(x1,x2[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=(x1!=x2)</td>
<td style="text-align: center;">not_equal(x1,x2[,y])</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y=(x1&lt;x2)</td>
<td style="text-align: center;">less(x1,x2,[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=(x1&lt;=x2)</td>
<td style="text-align: center;">less_equal(x1,x2,[,y])</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y=(x1&gt;x2)</td>
<td style="text-align: center;">greater(x1,x2,[,y])</td>
</tr>
<tr class="even">
<td style="text-align: center;">y=(x1&gt;=x2)</td>
<td style="text-align: center;">greater_equal(x1,x2,[,y])</td>
</tr>
</tbody>
</table>
<p>  由于 Python 中的 bool 运算使用 and、or 和 not 等关键字，它们无法被重载，因此数组的 bool 运算只能通过相应的 ufunc 函数进行。这些函数名都以“logical_”开头，在 IPython 中使用自动补全找到它们：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.logical <span class="hljs-comment"># Press Tab</span></span><br><span class="line">np.logical_and np.logical_not np.logical_or np.logical_xor</span><br></pre></td></tr></table></figure>
<p>  位运算函数包括 bitwise_and、bitwise_or、bitwise_xor、invert、left_shift 和 right_shift。</p>
<p>  对整数 0，在 32 位符号整数中按位取反的结果是 0xFFFFFFFF，这个值表示 -1。而在 8 位无符号整数中结果为 0xFF，为 255。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>~ np.arange(<span class="hljs-number">5</span>)</span><br><span class="line">array([<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">-5</span>], dtype=int32)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>~ np.arange(<span class="hljs-number">5</span>, dtype=np.uint8)</span><br><span class="line">array([<span class="hljs-number">255</span>, <span class="hljs-number">254</span>, <span class="hljs-number">253</span>, <span class="hljs-number">252</span>, <span class="hljs-number">251</span>], dtype=uint8)</span><br></pre></td></tr></table></figure>
<p>  left_shift 例子如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.binary_repr(<span class="hljs-number">5</span>)</span><br><span class="line"><span class="hljs-string">'101'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.left_shift(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])</span><br><span class="line">array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>], dtype=int32)</span><br></pre></td></tr></table></figure>
<h2 id="自定义-ufunc-函数">自定义 ufunc 函数</h2>
<p><img src="/Python/Python-NumPy/Python-NumPy2.jpg"></p>
<p>  如图，我们用一个分段函数计算三角波上某点 y 坐标：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">triangle_wave</span><span class="hljs-params">(x, c, c0, hc)</span>:</span></span><br><span class="line">    x = x - int(x)</span><br><span class="line">    <span class="hljs-keyword">if</span> x &gt;= c: r = <span class="hljs-number">0.0</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> x &lt; c0: r = x / c0 * hc</span><br><span class="line">    <span class="hljs-keyword">else</span>: r = (c - x) / (c - c0) * hc</span><br><span class="line">    <span class="hljs-keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>  若考虑以下方法，每次都要用列表推导式调用函数，对于多维数组很麻烦</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>)</span><br><span class="line">y1 = np.array([triangle_wave(t, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1.0</span>) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> x])</span><br></pre></td></tr></table></figure>
<p>  通过 frompyfunc() 可以将计算单个值的函数转换为能对数组的每个元素进行计算的 ufunc 函数。它的格式为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frompyfunc(func, nin, nout)</span><br></pre></td></tr></table></figure>
<p>  其中：func 是计算单个元素的函数，nin 是 func 输入参数的个数，nout 是 func 返回值的个数。下面的例子使用 frompyfunc()将 triangle_wave 转换为一个 ufunc 函数对象 triangle_ufunc1：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>triangle_ufunc1 = np.frompyfunc(triangle_wave, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y2 = triangle_ufunc1(x, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p>  值得注意的是，triangle_ufunc1()所返回数组的元素类型是 object，因此还需要再调用数组的 astype()方法以将其转换为双精度浮点数组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y2.dtype   y2.astype(np.float).dtype</span><br><span class="line">dtype(<span class="hljs-string">'O'</span>) dtype(<span class="hljs-string">'float64'</span>)</span><br></pre></td></tr></table></figure>
<p>  使用 vectorize()可以实现和 frompyfunc()类似的功能，但它可以通过 otypes 参数指定返回数组的元素类型。otypes 参数可以是一个表示元素类型的字符串，也可以是一个类型列表，使用列表可以描述多个返回数组的元素类型。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>triangle_ufunc2 = np.vectorize(triangle_wave, otypes=[np.float])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y3 = triangle_ufunc2(x, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p>  验证结果如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.all(y1 == y2) np.all(y2 == y3)</span><br><span class="line"><span class="hljs-keyword">True</span>             <span class="hljs-keyword">True</span></span><br></pre></td></tr></table></figure>
<h2 id="广播-broadcasting">广播 (Broadcasting)</h2>
<p>  当使用 ufunc 函数对两个数组进行计算时，ufunc 函数会对这两个数组的对应元素进行计算，因此要求这两个数组的形状相同。如果形状不同，会进行如下的广播处理：</p>
<ol type="1">
<li>让所有输入数组都向其中维数最多的数组看齐，shape 属性中不足的部分都通过在前面加 1 补齐。</li>
<li>输出数组的 shape 属性是输入数组的 shape 属性在各个轴上的最大值。</li>
<li>如果输入数组的某个轴长度为 1 或与输出数组对应轴的长度相同，这个数组就能够用来计算，否则出错。</li>
<li>当输入数组的某个轴长度为 1 时，沿着此轴运算时都用此轴上的第一组值。</li>
</ol>
<p>  我们举一个例子，先创建二维数组 a，形状为(6, 1)：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">10</span>).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)：</span><br><span class="line">a      a.shape</span><br><span class="line">[[ <span class="hljs-number">0</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">1</span>)</span><br><span class="line"> [<span class="hljs-number">10</span>],</span><br><span class="line"> [<span class="hljs-number">20</span>],</span><br><span class="line"> [<span class="hljs-number">30</span>],</span><br><span class="line"> [<span class="hljs-number">40</span>],</span><br><span class="line"> [<span class="hljs-number">50</span>]]</span><br></pre></td></tr></table></figure>
<p>  在创建一维数组 b，形状为(5,)：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)</span><br><span class="line">b               b.shape</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] (<span class="hljs-number">5</span>,)</span><br></pre></td></tr></table></figure>
<p>  计算 a 与 b 的和，得到一个加法表，它相当于计算两个数组中所有元素对的和，得到一个形状为(6, 5)的数组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = a + b</span><br><span class="line">c                      c.shape</span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span><br><span class="line"> [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],</span><br><span class="line"> [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>],</span><br><span class="line"> [<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>],</span><br><span class="line"> [<span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>],</span><br><span class="line"> [<span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">54</span>]]</span><br></pre></td></tr></table></figure>
<p>  由于数组 a 和 b 的维数不同，根据规则 1，需要让数组 b 的 shape 属性向数组 a 对齐，于是将数组 b 的 shape 属性前面加 1，补齐为(1,5)，相当于做了如下计算：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b.shape = <span class="hljs-number">1</span>, <span class="hljs-number">5</span></span><br><span class="line">b                 b.shape</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]] (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure>
<p>  做加法运算的两个输入数组的 shape 属性分别为(6,1)和(1,5)，根据规则 2，输出数组各个轴的长度为输入数组各个轴长度的最大值，可知输出数组的 shape 属性为(6,5)。</p>
<p>  由于数组 b 第 0 轴的长度为 1，而数组 a 第 0 轴的长度为 6，因此为了让它们在第 0 轴上能够相加，需要将数组 b 第 0 轴的长度扩展为 6，这相当于：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = b.repeat(<span class="hljs-number">6</span>, axis=<span class="hljs-number">0</span>)</span><br><span class="line">b                 b.shape</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>  由于数组 a 第 1 轴的长度为 1，而数组 b 第 1 轴的长度为 5，因此为了让它们在第 1 轴上能够相加，需要将数组 a 第 1 轴的长度扩展为5，这相当于：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = a.repeat(<span class="hljs-number">5</span>, axis=<span class="hljs-number">1</span>)</span><br><span class="line">a                      a.shape</span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span><br><span class="line"> [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],</span><br><span class="line"> [<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],</span><br><span class="line"> [<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>],</span><br><span class="line"> [<span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>],</span><br><span class="line"> [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>]]</span><br></pre></td></tr></table></figure>
<p>  经过上述处理之后，数组 a 和 b 就可以按对应元素进行相加运算了。当然，在执行 a + b 运算时，NumPy 内部并不会真正将长度为 1 的轴用 repeat() 进行扩展，这样太浪费内存空间了。由于这种广播计算很常用，因此 NumPy 提供了快速产生能进行广播运算的数组的 ogrid 对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = np.ogrid[:<span class="hljs-number">5</span>, :<span class="hljs-number">5</span>]</span><br><span class="line">x     y</span><br><span class="line">[[<span class="hljs-number">0</span>], [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</span><br><span class="line"> [<span class="hljs-number">1</span>],</span><br><span class="line"> [<span class="hljs-number">2</span>],</span><br><span class="line"> [<span class="hljs-number">3</span>],</span><br><span class="line"> [<span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>  mgrid 对象的用法和 ogrid 对象类似，但是它所返回的是进行广播之后的数组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = np.mgrid[:<span class="hljs-number">5</span>, :<span class="hljs-number">5</span>]</span><br><span class="line">x                 y</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]] [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>  ogrid 切片下标有两种形式：</p>
<ul>
<li>开始值:结束值:步长，和 np.arange(开始值, 结束值, 步长)类似。</li>
<li>开始值:结束值:长度 j，当第三个参数为虚数时，它表示所返回数组的长度，其和 np.linspace(开始值, 结束值, 长度)类似。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = np.ogrid[:<span class="hljs-number">1</span>:<span class="hljs-number">4j</span>, :<span class="hljs-number">1</span>:<span class="hljs-number">3j</span>]</span><br><span class="line">x              y</span><br><span class="line">[[<span class="hljs-number">0.</span>        ], [[<span class="hljs-number">0.</span> , <span class="hljs-number">0.5</span>, <span class="hljs-number">1.</span> ]]</span><br><span class="line"> [<span class="hljs-number">0.33333333</span>],</span><br><span class="line"> [<span class="hljs-number">0.66666667</span>],</span><br><span class="line"> [<span class="hljs-number">1.</span>        ]]</span><br></pre></td></tr></table></figure>
<p>  利用 ogrid 的返回值，我们很容易计算二元函数在等间距网格上的值。下面是绘制三维曲面 <span class="math inline">\(f(x,y)=xe^{x^2-y^2}\)</span> 的部分程序：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = np.ogrid[<span class="hljs-number">-2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">20j</span>, <span class="hljs-number">-2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">20j</span>]</span><br><span class="line">z = x * np.exp(- x**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/Python/Python-NumPy/Python-NumPy3.jpg"></p>
<p>  为了充分利用 ufunc 函数的广播功能，我们经常需要调整数组的形状，因此数组支持特殊的下标对象 None，它表示在 None 对应的位置创建一个长度为 1 的新轴，例如对于一维数组 a, a[None, :]和 a.reshape(1，-1)等效，而 a[:, None]和 a.reshape(-1，1)等效：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">4</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-keyword">None</span>, :]</span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[:, <span class="hljs-keyword">None</span>]</span><br><span class="line">array([[<span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">1</span>],</span><br><span class="line">       [<span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>]])</span><br></pre></td></tr></table></figure>
<p>  因此可以实现广播运算：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-keyword">None</span>, :] + y[:, <span class="hljs-keyword">None</span>]</span><br><span class="line">array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">12</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">13</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>]])</span><br></pre></td></tr></table></figure>
<p>  还可以使用 ix_()将两个一维数组转换成可广播的二维数组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>gy, gx = np.ix_(y, x)</span><br><span class="line">gx                 gy     gx + gy</span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">10</span>]] [[<span class="hljs-number">2</span>],  [[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">12</span>],</span><br><span class="line">                    [<span class="hljs-number">3</span>],   [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">13</span>],</span><br><span class="line">                    [<span class="hljs-number">8</span>]]   [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>]]</span><br></pre></td></tr></table></figure>
<p>  注意数组 y 对应广播运算结果中的第 0 轴，而数组 x 与第 1 轴对应。ix_()的参数可以是 N 个一维数。</p>
<h2 id="ufunc-的方法">ufunc 的方法</h2>
<p>  ufunc 函数对象本身还有一些方法，这些方法只对两个输入、一个输出的 ufunc 对象有效，其他的 ufunc 对象调用这些方法时会抛出 ValueError 异常。</p>
<p>  reduce()方法和 Python 的 reduce()函数类似，它沿着axis 参数指定的轴对数组进行操作，相当于将<code>&lt;op&gt;</code>运算符插入到沿 axis 轴的所有元素之间：<code>&lt;op&gt;.reduce(array, axis=0, dtype=None)</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>r1 = np.add.reduce([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>r2 = np.add.reduce([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], axis=<span class="hljs-number">1</span>)</span><br><span class="line">r1 r2</span><br><span class="line"><span class="hljs-number">6</span>  [ <span class="hljs-number">6</span>, <span class="hljs-number">15</span>]</span><br></pre></td></tr></table></figure>
<p>  accumulate()和 reduce()类似，只是它返回的数组和输入数组的形状相同，保存所有的中间计算结果：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a1 = np.add.accumulate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a2 = np.add.accumulate([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], axis=<span class="hljs-number">1</span>)</span><br><span class="line">a1        a2</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>] [[ <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">           [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">15</span>]]</span><br></pre></td></tr></table></figure>
<p>  reduceat()计算多组reduce()的结果，通过 indices 参数指定一系列的起始和终止位置。它的计算有些特别，参考下面例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>res = np.add.reduceat(a, indices=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>res</span><br><span class="line">array([ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure>
<p>  它按照如下计算得出：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> indices[i] &lt; indices[i+<span class="hljs-number">1</span>]:</span><br><span class="line">    res[i] = &lt;op&gt;.reduce(a[indices[i]:indices[i+<span class="hljs-number">1</span>]])</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    res[i] = a[indices[i]]</span><br></pre></td></tr></table></figure>
<p>  而最后一个元素则按照<code>&lt;op&gt;.reduce(a[indices[-1]:])</code>计算得出。</p>
<p>  在例子中，可以看出 res[::2]和 a 相等，而 res[1::2]和 np.add.accumulate(a) 相等。</p>
<p>  ufunc 函数的 outer()方法等同于：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.shape += (<span class="hljs-number">1</span>,)*b.ndim</span><br><span class="line">&lt;op&gt;(a, b)</span><br><span class="line">a = a.squeee()</span><br></pre></td></tr></table></figure>
<p>  其中 squeeze()方法剔除数组 a 中长度为 1 的轴，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.multiply.outer([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line">array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">8</span>],</span><br><span class="line">       [ <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>]])</span><br></pre></td></tr></table></figure>
<p>  通过 outer()计算得到的结果是乘法表。</p>
<h1 id="多维数组的下标存取">多维数组的下标存取</h1>
<h2 id="下标对象">下标对象</h2>
<p>  多维数组的下标应该是一个长度上与数组的维数相同的元组。如果下标元组的长度比数组的维数大，就会出错。如果小，就需要在下标元组的后面补“:”，使得它的长度与数组维数相同。</p>
<p>  如果下标对象不是元组，NumPy 会首先把它转换为元组。这种转换可能会和用户所希望的不一致。数组 a 是一个三维数组，下面的例子用二维列表 lidx 和一个二维数组 aidx 作为下标，得到的结果是不一样的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">3</span> * <span class="hljs-number">4</span> * <span class="hljs-number">5</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>lidx = [[<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>aidx = np.array(lidx)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[lidx]</span><br><span class="line">__main__:<span class="hljs-number">1</span>: FutureWarning: Using a non-tuple sequence <span class="hljs-keyword">for</span> multidimensional indexing <span class="hljs-keyword">is</span> deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted <span class="hljs-keyword">as</span> an array index, `arr[np.array(seq)]`, which will result either <span class="hljs-keyword">in</span> an error <span class="hljs-keyword">or</span> a different result.</span><br><span class="line">array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[aidx]</span><br><span class="line">array([[[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">         [ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">         [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],</span><br><span class="line">         [<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       [[[<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>],</span><br><span class="line">         [<span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>],</span><br><span class="line">         [<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>],</span><br><span class="line">         [<span class="hljs-number">35</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>, <span class="hljs-number">38</span>, <span class="hljs-number">39</span>]]]])</span><br></pre></td></tr></table></figure>
<p>  下标元组各个元素有如下几种类型：切片、整数、整数数组和布尔数组。如果元素不是这些类型，如列表或元组，就将其转换成整数数组。如果下标元组的所有元素都是切片和整数，那么用它作为下标得到的是原始数组的一个视图，即它和原始数组共享数据存储空间。</p>
<h2 id="整数数组作为下标">整数数组作为下标</h2>
<p>  下面讨论下标元组中的元素由切片和整数数组构成的情况。假设整数数组有 <span class="math inline">\(N_c\)</span> 个，切片有 <span class="math inline">\(N_s\)</span> 个。<span class="math inline">\(N_c+N_s\)</span> 为数组的维数 <span class="math inline">\(D\)</span>。首先这 <span class="math inline">\(N_c\)</span> 个整数数组必须满足广播条件，假设它们进行广播之后的维数为 <span class="math inline">\(M\)</span>，形状为<span class="math inline">\((d_0,d_1,\cdots,d_{M-1})\)</span>。如果 <span class="math inline">\(N_s\)</span> 为0，即没有切片元素，那么下标得到的结果数组 <span class="math inline">\(res\)</span> 的形状和整数数组广播之后的形状相同。它的每个元素值可按照下面的公式得出： <span class="math display">\[res[i_0,i_1,\cdots,i_{M-1}]=X[ind_0[i_0,i_1,\cdots,i_{M-1}],\cdots,ind_{N_t-1}[i_0,i_1,\cdots,i_{M-1}]]\]</span></p>
<p>  其中 <span class="math inline">\(ind0\)</span> 到 <span class="math inline">\(ind_{N_t-1}\)</span> 为进行广播之后的整数数组。</p>
<blockquote>
<p>若只需沿着指定轴通过整数数组获取元素，可以使用<a href="https://numpy.org/doc/1.18/reference/generated/numpy.take.html" target="_blank" rel="noopener"><code>numpy.take()</code></a>函数，运算速度比整数数组下标略快，支持下标越界处理。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i0 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i1 = np.array([[[<span class="hljs-number">0</span>]], [[<span class="hljs-number">1</span>]]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i2 = np.array([[[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = a[i0, i1, i2]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[[<span class="hljs-number">22</span>, <span class="hljs-number">43</span>, <span class="hljs-number">22</span>],</span><br><span class="line">        [ <span class="hljs-number">2</span>, <span class="hljs-number">23</span>,  <span class="hljs-number">2</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="hljs-number">27</span>, <span class="hljs-number">48</span>, <span class="hljs-number">27</span>],</span><br><span class="line">        [ <span class="hljs-number">7</span>, <span class="hljs-number">28</span>,  <span class="hljs-number">7</span>]]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b.shape</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure>
<p>  i0、i1、i2 三个整数数组的 shape 属性分别为(2,3)、(2,1,1)、(1,1,3)，根据广播规则，先在长度不足 3 的 shape 属性前面补 1，使它们的维数相同，广播之后的shape 属性为各个轴的最大值，即三个整数数组广播之后的 shape 属性为(2,2,3)。</p>
<p>  可以使用 broadcast_arrays()查看广播之后的数组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ind0, ind1, ind2 = np.broadcast_arrays(i0, i1, i2)</span><br><span class="line">ind0                 ind1                 ind2</span><br><span class="line">array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],   array([[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],   array([[[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],</span><br><span class="line">        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]],          [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]],          [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],          [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],          [[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],</span><br><span class="line">        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]])         [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]])         [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]])</span><br></pre></td></tr></table></figure>
<p>  对于数组 b 中的任意一个元素 b[i,j,k]，它是数组 a 中经过 ind0、ind1 和 ind2 进行下标转换之后的值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i, j, k = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>print(b[i, j, k], a[ind0[i, j, k], ind1[i, j, k], ind2[i, j, k]])</span><br><span class="line"><span class="hljs-number">28</span> <span class="hljs-number">28</span></span><br></pre></td></tr></table></figure>
<p>  下面考虑 <span class="math inline">\(N_s\)</span> 不为 0 的情况。当存在切片下标时，可以细分为两种情况：下标元组中的整数数组之间没有切片，即整数数组只有一个或者是连续的。这时结果数组的 shape 属性为：将原始数组的 shape 属性中整数数组所占据的部分替换为它们广播之后的 shape 属性。例如，假设原始数组 a 的 shape 属性为(3,4,5)，i0 和 i1 广播之后的形状为(2, 2, 3)，则 a[1:3, i0, i1]的形状为(2, 2, 2, 3)：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, i0, i1]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.shape</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure>
<p>  其中，数组 c 的 shape 属性中的第一个 2 是切片 “1:3” 的长度，后面的(2,2,3)则是 i0 和 i1 广播之后数组的形状。</p>
<p>  当下标元组中的整数数组不是连续的，结果数组的 shape 属性为整数数组广播之后的形状后面再加上切片元素对应的形状。例如，a[i0, :, i1]的 shape 属性为(2, 2, 3, 4)。其中(2, 2, 3)是 i0 和 i1 广播之后的形状，而 4 是数组 a 第 1 轴的长度：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>d = a[i0, :, i1]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>d.shape</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span><br></pre></td></tr></table></figure>
<h2 id="布尔数组作为下标">布尔数组作为下标</h2>
<p>  当使用布尔数组直接作为下标对象或者元组下标对象中有布尔数组时，都相当于用 nonzero()将布尔数组转换成一组整数数组，然后使用整数数组进行下标运算。</p>
<p>  nonzeros(a)返回数组 a 中值不为零的元素的下标，它的返回值是一个长度为 a.ndim(数组 a 的轴数)的元组，元组的每个元素都是一个整数数组，其值为非零元素的下标在对应轴上的值。对于一维布尔数组b1，nonzero(b1)得到的是一个长度为 1 的元组:</p>
<blockquote>
<p>若只需沿着指定轴通过整数数组获取元素，可以使用<a href="https://numpy.org/doc/1.18/reference/generated/numpy.compress.html" target="_blank" rel="noopener"><code>numpy.compress()</code></a>函数。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b1 = np.array([<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.nonzero(b1)</span><br><span class="line">(array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], dtype=int64),)</span><br></pre></td></tr></table></figure>
<p>  对于二维数组 b2，nonzero(b2)得到的是一个长度为 2 的元组。它的第 0 个元素是数组 a 中值不为 0 的元素的第 0 轴的下标，第 1 个元素则是第 1 轴的下标，</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b2 = np.array([[<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>], [<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">False</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.nonzero(b2)</span><br><span class="line">(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], dtype=int64), array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>], dtype=int64))</span><br></pre></td></tr></table></figure>
<h1 id="庞大的函数库">庞大的函数库</h1>
<h2 id="随机数"><a href="https://numpy.org/doc/stable/reference/random/index.html" target="_blank" rel="noopener">随机数</a></h2>
<ul>
<li><a href="https://numpy.org/doc/stable/reference/random/generator.html" target="_blank" rel="noopener">Random Generator</a></li>
<li><a href="https://numpy.org/doc/stable/reference/random/legacy.html" target="_blank" rel="noopener">Legacy Generator (RandomState)</a></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数名</th>
<th style="text-align: center;">功能</th>
<th style="text-align: center;">函数名</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">rand</td>
<td style="text-align: center;">0到1之间的随机数</td>
<td style="text-align: center;">randn</td>
<td style="text-align: center;">标准正态分布的随机数</td>
</tr>
<tr class="even">
<td style="text-align: center;">randint</td>
<td style="text-align: center;">指定范围内随机整数</td>
<td style="text-align: center;">normal</td>
<td style="text-align: center;">正态分布</td>
</tr>
<tr class="odd">
<td style="text-align: center;">uniform</td>
<td style="text-align: center;">均匀分布</td>
<td style="text-align: center;">poisson</td>
<td style="text-align: center;">泊松分布</td>
</tr>
<tr class="even">
<td style="text-align: center;">permutation</td>
<td style="text-align: center;">随机排列</td>
<td style="text-align: center;">shuffle</td>
<td style="text-align: center;">随机打乱顺序</td>
</tr>
<tr class="odd">
<td style="text-align: center;">choice</td>
<td style="text-align: center;">随机抽取样本</td>
<td style="text-align: center;">seed</td>
<td style="text-align: center;">设置随机数种子</td>
</tr>
</tbody>
</table>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><!--pspan= __('copyright_title_prefix')
= page.title--><p><span>文章作者：</span>wtyang</p><!--pspan= __('copyright_date_prefix')
= page.date.format(config.date_format)--><!--pspan= __('copyright_update_prefix')
= page.updated.format(config.date_format)--><p><span>原始链接：</span><a href="/Python/Python-NumPy/">https://2inf.top/Python/Python-NumPy/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://2inf.top/Python/Python-NumPy/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a> 许可协议。转载请注明出处！</p></div><br><div class="tags"><a href="/tags/NumPy/"><i class="fa fa-tag"></i>NumPy</a></div><div class="post-nav"><a class="pre" href="/Others/Anime-and-Game/">My fun</a><a class="next" href="/Algorithm/Learing-Segment-Tree/">线段树学习</a></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">2inf</a>&nbsp;|&nbsp;<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">湘ICP备20012049号-1 </a>|&nbsp;
<a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i>&nbsp;RSS Feed</a><div><link rel="stylesheet" type="text/css" href="/css/badge.css"/><div class="github-badge"><a rel="nofollow" target="_blank" href="https://hexo.io"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hexo</span></a></div>
<div class="github-badge"> <a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"><span class="badge-subject">Theme</span><span class="badge-value bg-orange">maupassant</span></a></div>
<div class="github-badge"> <a rel="nofollow" target="_blank" href="https://www.cnblogs.com/2inf/"><span class="badge-subject">cnblogs</span><span class="badge-value bg-blueviolet">2inf</span></a></div></div></div></div></div><div class="post-toc"><div class="post-toc-wrap"><div class="post-toc" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ndarray-对象"><span class="toc-number">1.</span> <span class="toc-text">ndarray 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建"><span class="toc-number">1.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元素类型"><span class="toc-number">1.2.</span> <span class="toc-text">元素类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动生成数组"><span class="toc-number">1.3.</span> <span class="toc-text">自动生成数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存取元素"><span class="toc-number">1.4.</span> <span class="toc-text">存取元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多维数组"><span class="toc-number">1.5.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构数组"><span class="toc-number">1.6.</span> <span class="toc-text">结构数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ufunc-函数"><span class="toc-number">2.</span> <span class="toc-text">ufunc 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#四则运算"><span class="toc-number">2.1.</span> <span class="toc-text">四则运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较运算和布尔运算"><span class="toc-number">2.2.</span> <span class="toc-text">比较运算和布尔运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义-ufunc-函数"><span class="toc-number">2.3.</span> <span class="toc-text">自定义 ufunc 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#广播-broadcasting"><span class="toc-number">2.4.</span> <span class="toc-text">广播 (Broadcasting)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ufunc-的方法"><span class="toc-number">2.5.</span> <span class="toc-text">ufunc 的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多维数组的下标存取"><span class="toc-number">3.</span> <span class="toc-text">多维数组的下标存取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#下标对象"><span class="toc-number">3.1.</span> <span class="toc-text">下标对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数数组作为下标"><span class="toc-number">3.2.</span> <span class="toc-text">整数数组作为下标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#布尔数组作为下标"><span class="toc-number">3.3.</span> <span class="toc-text">布尔数组作为下标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#庞大的函数库"><span class="toc-number">4.</span> <span class="toc-text">庞大的函数库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#随机数"><span class="toc-number">4.1.</span> <span class="toc-text">随机数</span></a></li></ol></li></ol></div></div><div class="post-toc-toggle-wrap open" id="right-toggle"><div class="post-toc-toggle-first post-toc-toggle"></div><div class="post-toc-toggle-second post-toc-toggle"></div><div class="post-toc-toggle-thrid post-toc-toggle"></div></div><script type="text/javascript" src="/js/sidebar.js?v=0.0.0" async></script></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
  TeX: {equationNumbers: { autoNumber: ['AMS'], useLabelIds: true }},
  'HTML-CSS': { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } }
  });
</script><!--script(type='text/javascript', src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', async)--><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script>hljs.initHighlightingOnLoad();</script><script type="text/javascript" src="/js/app.js?v=0.0.0"></script></div></body></html>