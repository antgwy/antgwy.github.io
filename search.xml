<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉搜索树相关学习</title>
      <link href="/uncategorized/BST/"/>
      <url>/uncategorized/BST/</url>
      
        <content type="html"><![CDATA[<p>  给定一棵二叉树，每个节点带有一个数值称为 “关键码”，则“BST 性质”指，对树中任意一个节点：</p><ol><li>该节点的关键码不小于它的左子树中任意节点的关键码。</li><li>该节点的关键码不大于它的右子树中任意节点的关键码。</li></ol><p>  满足以上性质的二叉树即为“二叉搜索树(Binary Search Tree，BST)”。二叉搜索树的中序遍历是一个关键码单调递增的节点序列。</p><h2 id="treap"><a class="header-anchor" href="#treap">¶</a>Treap</h2><p>  满足 BST 性质且中序遍历为相同序列得二叉搜索树不唯一，它们是等价的，可以在维持 BST 性质上，改变二叉搜索树形态，使得每个节点左右子树大小达到平衡，从而整棵树深度维持在 $O(\log{n})$。</p><p>  改变形态并保持 BST 性质方法即“旋转”，基本的旋转有“左旋”与“右旋”，如下图所示。</p><p><img src="/uncategorized/BST/treap1.png" alt></p><p>  左右旋代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p)</span> </span>&#123; <span class="hljs-comment">// 右旋</span></span><br><span class="line">    <span class="hljs-keyword">int</span> q = a[p].l;</span><br><span class="line">    a[p].l = a[q].r; a[q].r = p;</span><br><span class="line">    p = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p)</span> </span>&#123; <span class="hljs-comment">// 左旋</span></span><br><span class="line">    <span class="hljs-keyword">int</span> q = a[p].r;</span><br><span class="line">    a[p].r = a[q].l; a[q].l = p;</span><br><span class="line">    p = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  为处理关键码相同的情况，节点增加一个域 <code>cnt</code>，节点的 <code>sz</code> 代表以该节点为根的子树中所有 <code>cnt</code> 的和，不存在重复数值时，<code>sz</code> 就是子树大小。</p><p><a href="https://www.luogu.com.cn/problem/P3369" target="_blank" rel="noopener">P3369 【模板】普通平衡树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Treap</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> l, r;</span><br><span class="line"><span class="hljs-keyword">int</span> val, dat;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt, sz;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> tot, rt, n;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">a[++tot].val = val; a[tot].dat = rand(); a[tot].cnt = a[tot].sz = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">a[p].sz = a[a[p].l].sz + a[a[p].r].sz + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">New(-INF), New(INF);</span><br><span class="line">rt = <span class="hljs-number">1</span>, a[<span class="hljs-number">1</span>].r = <span class="hljs-number">2</span>;</span><br><span class="line">update(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getrank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (val == a[p].val) <span class="hljs-keyword">return</span> a[a[p].l].sz + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (val &lt; a[p].val) <span class="hljs-keyword">return</span> getrank(a[p].l, val);</span><br><span class="line"><span class="hljs-keyword">return</span> getrank(a[p].r, val) + a[a[p].l].sz + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getval</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> INF;</span><br><span class="line"><span class="hljs-keyword">if</span> (a[a[p].l].sz &gt;= rank) <span class="hljs-keyword">return</span> getval(a[p].l, rank);</span><br><span class="line"><span class="hljs-keyword">if</span> (a[a[p].l].sz + a[p].cnt &gt;= rank) <span class="hljs-keyword">return</span> a[p].val;</span><br><span class="line"><span class="hljs-keyword">return</span> getval(a[p].r, rank - a[a[p].l].sz - a[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = a[p].l;</span><br><span class="line">a[p].l = a[q].r, a[q].r = p, p = q;</span><br><span class="line">update(a[p].r), update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> q = a[p].r;</span><br><span class="line">a[p].r = a[q].l, a[q].l = p, p = q;</span><br><span class="line">update(a[p].l), update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!p) &#123; p = New(val); <span class="hljs-keyword">return</span>; &#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">a[p].cnt++, update(p);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (val &lt; a[p].val) &#123;</span><br><span class="line">insert(a[p].l, val);</span><br><span class="line"><span class="hljs-keyword">if</span> (a[p].dat &lt; a[a[p].l].dat) zig(p); <span class="hljs-comment">// 不满足堆性质，右旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">insert(a[p].r, val);</span><br><span class="line"><span class="hljs-keyword">if</span> (a[p].dat &lt; a[a[p].r].dat) zag(p); <span class="hljs-comment">// 不满足堆性质，左旋</span></span><br><span class="line">&#125;</span><br><span class="line">update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>, p = rt; <span class="hljs-comment">// a[1].val = -INF;</span></span><br><span class="line"><span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (a[p].l &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">p = a[p].l;</span><br><span class="line"><span class="hljs-keyword">while</span> (a[p].r &gt; <span class="hljs-number">0</span>) p = a[p].r;</span><br><span class="line">ans = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p;</span><br><span class="line">p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">2</span>, p = rt; <span class="hljs-comment">// a[2].val = INF;</span></span><br><span class="line"><span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (a[p].r &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">p = a[p].r;</span><br><span class="line"><span class="hljs-keyword">while</span> (a[p].l &gt; <span class="hljs-number">0</span>) p = a[p].l;</span><br><span class="line">ans = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p;</span><br><span class="line">p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;p, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (val == a[p].val) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a[p].cnt &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line"> a[p].cnt--, update(p);</span><br><span class="line"> <span class="hljs-keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="hljs-keyword">if</span> (a[p].l || a[p].r) &#123;</span><br><span class="line"> <span class="hljs-keyword">if</span> (!a[p].r || a[a[p].l].dat &gt; a[a[p].r].dat)</span><br><span class="line"> zig(p), remove(a[p].r, val);</span><br><span class="line"> <span class="hljs-keyword">else</span></span><br><span class="line"> zag(p), remove(a[p].l, val);</span><br><span class="line"> update(p);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="hljs-keyword">else</span> p = <span class="hljs-number">0</span>;</span><br><span class="line"> <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">val &lt; a[p].val ? remove(a[p].l, val) : remove(a[p].r, val);</span><br><span class="line">update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">build();</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="hljs-keyword">int</span> op, x;</span><br><span class="line"><span class="hljs-keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line"><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) insert(rt, x);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) remove(rt, x);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getrank(rt, x) - <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">4</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getval(rt, x + <span class="hljs-number">1</span>));</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">5</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpre(x));</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">6</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getnext(x));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最近公共祖先问题</title>
      <link href="/Algorithm/Lowest-Common-Ancestor/"/>
      <url>/Algorithm/Lowest-Common-Ancestor/</url>
      
        <content type="html"><![CDATA[<p>  在一棵有根树里，两个节点的最近公共祖先即两个点的公共祖先里深度最大的，记点集 $S=(v_1,v_2,\cdots,v_n)$ 的最近公共祖先 $LCA(v_1,v_2,\cdots,v_n)$ 或 $LCA(S)$。</p><p>  朴素算法是：dfs 求出每个点深度，假设 y 深度比 x 大，让 y 向上走至与 x 同等深度，之后 x 与 y 一起向上走直到相遇，时间复杂度 $O(n)$。</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2586" target="_blank" rel="noopener">模板 hdu2586</a></p><h2 id="rmq-问题"><a class="header-anchor" href="#rmq-问题">¶</a>RMQ 问题</h2><p>  RMQ(Range Minimum/Maximum Query) 问题是指在长度为 n 的序列 $a$ 里，求区间 $[l,r]$ 中的最大值。</p><p>  ST 表用于解决可重复贡献问题。ST 表基于倍增思想，$O(n\log{n})$ 处理，$O(1)$ 回答每个询问，不支持修改。</p><p>  记 $f(i,j)$ 表示区间 $[i,i+2^j-1]$ 的最大值。则 $f(i,0)=a_i$，转移方程 $f(i,j)=\max(f(i,j-1),f(i+2^{j-1},j-1))$。对于每个询问 $[l,r]$，令 $k=\log_2(r-l+1)$，则答案为 $f(l,k)$ 与 $f(r-2^k+1,k)$ 二者中的最大值。</p><p><a href="https://www.luogu.com.cn/problem/P3865" target="_blank" rel="noopener">模板题</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N], f[N][<span class="hljs-number">20</span>], mn[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  mn[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    mn[i] = (i&amp;(i<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span> ? mn[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span> : mn[i<span class="hljs-number">-1</span>];</span><br><span class="line">    f[i][<span class="hljs-number">0</span>] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= mn[n]; ++j)</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span>&lt;&lt;j) - <span class="hljs-number">1</span> &lt;= n; ++i)</span><br><span class="line">      f[i][j] = max(f[i][j<span class="hljs-number">-1</span>], f[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> k = mn[r-l+<span class="hljs-number">1</span>];</span><br><span class="line">  <span class="hljs-keyword">return</span> max(f[l][k], f[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  init();</span><br><span class="line">  <span class="hljs-keyword">int</span> x, y;</span><br><span class="line">  <span class="hljs-keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, query(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上倍增法"><a class="header-anchor" href="#树上倍增法">¶</a>树上倍增法</h2><p>  记 $f(i,k)$ 表示 $i$ 的 $2^k$ 辈祖先，则 $f[i,0]$ 即为 $i$ 的父节点，且有 $f[i,k]=f[f[i,k-1],k-1]$，可以对树进行 bfs 预处理，时间复杂度 $O(n\log{n})$，每次查询时间复杂度 $O(\log{n})$，从而考虑一下算法：</p><p>  假设 $d[x]\le d[y]$，将 $y$ 向上走至与 $x$ 同一高度处，若 $x==y$，则已找到，否则把 $x,y$ 同时向上调整保证深度一致且二者不相遇，最后 $x,y$ 只差一步相遇，父节点即为 $LCA$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">4e4</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> t, n, m, tot, k;</span><br><span class="line"><span class="hljs-keyword">int</span> f[N][<span class="hljs-number">20</span>], d[N], dis[N], head[N], lg[N];</span><br><span class="line"><span class="hljs-keyword">int</span> ver[N&lt;&lt;<span class="hljs-number">1</span>], edge[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y; edge[tot] = z; nxt[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;</span><br><span class="line">  q.push(<span class="hljs-number">1</span>);</span><br><span class="line">  d[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> y = ver[i];</span><br><span class="line">      <span class="hljs-keyword">if</span> (d[y]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="hljs-number">1</span>;</span><br><span class="line">      dis[y] = dis[x] + edge[i];</span><br><span class="line">      f[y][<span class="hljs-number">0</span>] = x;</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j)</span><br><span class="line">        f[y][j] = f[f[y][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];</span><br><span class="line">      q.push(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (d[x] &gt; d[y]) swap(x, y);</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &gt;= <span class="hljs-number">0</span>; --i)</span><br><span class="line">    <span class="hljs-keyword">if</span> (d[f[y][i]] &gt;= d[x]) y = f[y][i];</span><br><span class="line">  <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &gt;= <span class="hljs-number">0</span>; --i)</span><br><span class="line">    <span class="hljs-keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; ++i) lg[i] = lg[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    k = lg[n] + <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) head[i] = d[i] = <span class="hljs-number">0</span>;</span><br><span class="line">    tot = <span class="hljs-number">0</span>; </span><br><span class="line">    <span class="hljs-keyword">int</span> x, y, z;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      add(x, y, z);</span><br><span class="line">      add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dis[x] + dis[y] - <span class="hljs-number">2</span> * dis[lca(x, y)]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lca-的-tarjan-算法"><a class="header-anchor" href="#lca-的-tarjan-算法">¶</a>LCA 的 Tarjan 算法</h2><p>  使用并查集对向上标记法的优化，是离线算法。具体的思想是在 dfs 时对树的节点进行分类：</p><ol><li>已访问但未回溯的节点添加标记 1，这些节点是当前访问节点 $x$ 及 $x$ 的祖先。</li><li>已访问并且回溯的节点添加标记 2。</li><li>未访问的节点标记 0。</li></ol><p>  对于正在访问的节点 x，它到根节点的路径已标记为 1。若 y 是已经访问且回溯的节点，则 $LCA(x,y)$ 就是 $y$ 向上走到根，第一个遇到的标记为 1 的节点。可以用并查集优化，当节点标记为 2 时，把它所在集合合并到父节点所在集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">4e4</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> t, n, m, tot;</span><br><span class="line"><span class="hljs-keyword">int</span> fa[N], d[N], v[N], ans[M];</span><br><span class="line"><span class="hljs-keyword">int</span> ver[N&lt;&lt;<span class="hljs-number">1</span>], edge[N&lt;&lt;<span class="hljs-number">1</span>], nxt[N&lt;&lt;<span class="hljs-number">1</span>], head[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; q[N], qid[N]; </span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y; edge[tot] = z; nxt[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addquery</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  q[x].push_back(y), qid[x].push_back(id);</span><br><span class="line">  q[y].push_back(x), qid[y].push_back(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (x == fa[x]) <span class="hljs-keyword">return</span> x;</span><br><span class="line">  <span class="hljs-keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> y = ver[i];</span><br><span class="line">    <span class="hljs-keyword">if</span> (v[y]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">    d[y] = d[x] + edge[i];</span><br><span class="line">    tarjan(y);</span><br><span class="line">    fa[y] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)q[x].size(); ++i) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> y = q[x][i], id = qid[x][i];</span><br><span class="line">    <span class="hljs-keyword">if</span> (v[y] == <span class="hljs-number">2</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> lca = find(y);</span><br><span class="line">      ans[id] = min(ans[id], d[x] + d[y] - <span class="hljs-number">2</span> * d[lca]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v[x] = <span class="hljs-number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="hljs-keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      head[i] = <span class="hljs-number">0</span>; fa[i] = i; v[i] = <span class="hljs-number">0</span>;</span><br><span class="line">      q[i].clear(); qid[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    tot = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> x, y, z;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      add(x, y, z);</span><br><span class="line">      add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="hljs-keyword">if</span> (x == y) &#123; ans[i] = <span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>; &#125;</span><br><span class="line">      addquery(x, y, i);</span><br><span class="line">      ans[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论-LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主席树专题学习</title>
      <link href="/Algorithm/Chairman-Tree/"/>
      <url>/Algorithm/Chairman-Tree/</url>
      
        <content type="html"><![CDATA[<ul><li>参考链接</li></ul><p><a href="https://oi-wiki.org/ds/persistent-seg/" target="_blank" rel="noopener">OI-wiki</a></p><p><a href="https://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank" rel="noopener">Wikipedia</a></p><p><a href="https://www.luogu.com.cn/blog/LonecharmRiver/zhu-xi-shu" target="_blank" rel="noopener">主席树-孤独·粲泽</a></p><h2 id="主席树"><a class="header-anchor" href="#主席树">¶</a>主席树</h2><p><img src="/Algorithm/Chairman-Tree/Persistent-tree.png" alt></p><p>  传统意义就是可持久化线段树，持久化即可以记录每一次修改的内容，为什么叫主席树呢，最早用这种方法的人黄嘉泰(HJT) 首字母和一位主席相同。</p><h3 id="静态区间第-k-小"><a class="header-anchor" href="#静态区间第-k-小">¶</a>静态区间第 k 小</h3><p>  以 <a href="http://poj.org/problem?id=2104" target="_blank" rel="noopener">POJ2104 K-th Number</a> 为例</p><p>题意：给定一个长度为 $n(1\le n\le10^5)$ 的序列，和 $m(1\le m\le5000)$ 个询问：$l_i,r_i,k_i$，表示求 $a[l_i],a[l_i+1],\cdots,a[r_i]$ 中第 $k_i$ 小的数是多少。</p><p>  建立一颗权值线段树，维护序列 $a$ 中有多少数在值域区间 $[L,R]$ 内(记为 $cnt_{L,R}$)，只需比较 $cnt_{L,mid}$ 与 k 的关系，即可确定 a 的第 k 小数 $\le mid$ 还是 $&gt;mid$，从而进入左右子树之一。</p><p>  将序列 $a$ 离散化，$a[i]$ 的值为 $H[a[i]]\in[1,t]$，在 $[1,t]$ 建立可持久化线段树，每个结点一个值 $cnt$ 表示值域区间 $[L,R]$ 一共插入多少数。对每个 $a[i]$，在可持久化线段树上进行对 $H[a[i]]$ 的单点修改。</p><p>  可持久化线段树中“以 $root[i]$ 为根的线段树”的值域区间 $[L,R]$ 保存了 $a$ 的前 $i$ 个数有多少个落在值域 $[L,R]$ 内。</p><p>  对每个询问 $l_i,r_i,k_i$，注意到：以 $root[l_i]$ 和 $root[r_i]$ 为根的两棵线段树对值域的划分是相同的，即除了 $cnt$ 值不同外两棵线段树的内部构造和每个结点代表的值域区间完全对应。我们有：$root[r_i]$ 的值域区间 $[L,R]$ 的 $cnt$ 值减去 $root[l_i-1]$ 的值域区间 $[L,R]$ 的 $cnt$ 值就等于 $a[l_i\sim r_i]$ 中有多少个数落在值域 $[L,R]$ 内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> ls, rs, cnt;</span><br><span class="line">&#125;tree[N*<span class="hljs-number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m, tot;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N], b[N], root[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = ++tot; tree[p].cnt = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> p;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    tree[p].ls = build(l, mid);</span><br><span class="line">    tree[p].rs = build(mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = ++tot; tree[p] = tree[pre];</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[p].cnt += v;</span><br><span class="line">        <span class="hljs-keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x &lt;= mid) tree[p].ls = update(tree[pre].ls, l, mid, x, v);</span><br><span class="line">    <span class="hljs-keyword">else</span> tree[p].rs = update(tree[pre].rs, mid + <span class="hljs-number">1</span>, r, x, v);</span><br><span class="line">    tree[p].cnt = tree[tree[p].ls].cnt + tree[tree[p].rs].cnt;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> lsnt = tree[tree[p].ls].cnt - tree[tree[q].ls].cnt;</span><br><span class="line">    <span class="hljs-keyword">if</span> (k &lt;= lsnt) <span class="hljs-keyword">return</span> query(tree[p].ls, tree[q].ls, l, mid, k);</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> query(tree[p].rs, tree[q].rs, mid + <span class="hljs-number">1</span>, r, k - lsnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="hljs-number">1</span>, b + n + <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> t = unique(b + <span class="hljs-number">1</span>, b + n + <span class="hljs-number">1</span>) - (b + <span class="hljs-number">1</span>);</span><br><span class="line">    root[<span class="hljs-number">0</span>] = build(<span class="hljs-number">1</span>, t);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = lower_bound(b + <span class="hljs-number">1</span>, b + t + <span class="hljs-number">1</span>, a[i]) - b;</span><br><span class="line">        root[i] = update(root[i<span class="hljs-number">-1</span>], <span class="hljs-number">1</span>, t, x, <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> l, r, k;</span><br><span class="line">    <span class="hljs-keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="hljs-keyword">int</span> ans = query(root[r], root[l<span class="hljs-number">-1</span>], <span class="hljs-number">1</span>, t, k);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, b[ans]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态区间第-k-小"><a class="header-anchor" href="#动态区间第-k-小">¶</a>动态区间第 k 小</h3><p>以 <a href="https://www.luogu.com.cn/problem/P2617" target="_blank" rel="noopener">洛谷 P2617 Dynamic Rankings</a> 为例。</p><p>  用树状数组维护前缀和，以 $root[i]$ 为根的线段树表示 $[i-lowbit(i)+1, i]$ 值域区间建成的线段树。</p><p>  查询时，$L$ 数组存储拼出 $[1,l-1]$ 的所有点，$R$ 数组存储拼出 $[1,r]$ 的所有点。需要注意的是容易 MLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Op</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> l, r, k;</span><br><span class="line">&#125;op[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> ls, rs, cnt;</span><br><span class="line">&#125;tree[N*<span class="hljs-number">400</span>]; <span class="hljs-comment">// nlog^2(n) 大小</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m, tot, t, cl, cr;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N], b[N&lt;&lt;<span class="hljs-number">1</span>], root[N];</span><br><span class="line"><span class="hljs-keyword">int</span> L[<span class="hljs-number">20</span>], R[<span class="hljs-number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = ++tot; tree[p].cnt = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> p;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    tree[p].ls = build(l, mid);</span><br><span class="line">    tree[p].rs = build(mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = ++tot; tree[p] = tree[pre];</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[p].cnt += v;</span><br><span class="line">        <span class="hljs-keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x &lt;= mid) tree[p].ls = update(tree[pre].ls, l, mid, x, v);</span><br><span class="line">    <span class="hljs-keyword">else</span> tree[p].rs = update(tree[pre].rs, mid + <span class="hljs-number">1</span>, r, x, v);</span><br><span class="line">    tree[p].cnt = tree[tree[p].ls].cnt + tree[tree[p].rs].cnt;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cl; ++i)</span><br><span class="line">        sum -= tree[tree[L[i]].ls].cnt;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cr; ++i)</span><br><span class="line">        sum += tree[tree[R[i]].ls].cnt;</span><br><span class="line">    <span class="hljs-keyword">if</span> (k &lt;= sum) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cl; ++i)</span><br><span class="line">            L[i] = tree[L[i]].ls;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cr; ++i)</span><br><span class="line">            R[i] = tree[R[i]].ls;</span><br><span class="line">        <span class="hljs-keyword">return</span> query(l, mid, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cl; ++i)</span><br><span class="line">            L[i] = tree[L[i]].rs;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cr; ++i)</span><br><span class="line">            R[i] = tree[R[i]].rs;</span><br><span class="line">        <span class="hljs-keyword">return</span> query(mid + <span class="hljs-number">1</span>, r, k - sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-comment">// [1,i] 的线段树值域为 a[x] 的次数 += v</span></span><br><span class="line">    <span class="hljs-keyword">int</span> id = lower_bound(b + <span class="hljs-number">1</span>, b + t + <span class="hljs-number">1</span>, a[x]) - b;</span><br><span class="line">    <span class="hljs-keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">        root[x] = update(root[x], <span class="hljs-number">1</span>, t, id, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        b[++t] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">char</span> str[<span class="hljs-number">2</span>];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, str);</span><br><span class="line">        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">'Q'</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;op[i].l, &amp;op[i].r, &amp;op[i].k);</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">'C'</span>) &#123;</span><br><span class="line">            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;op[i].l, &amp;op[i].r);</span><br><span class="line">            b[++t] = op[i].r; op[i].k = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="hljs-number">1</span>, b + t + <span class="hljs-number">1</span>);</span><br><span class="line">    t = unique(b + <span class="hljs-number">1</span>, b + t + <span class="hljs-number">1</span>) - (b + <span class="hljs-number">1</span>);</span><br><span class="line">    root[<span class="hljs-number">0</span>] = build(<span class="hljs-number">1</span>, t);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) add(i, <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (op[i].k) &#123;</span><br><span class="line">            cl = cr = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = op[i].l - <span class="hljs-number">1</span>; j; j -= lowbit(j))</span><br><span class="line">                L[++cl] = root[j];</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = op[i].r; j; j -= lowbit(j))</span><br><span class="line">                R[++cr] = root[j];</span><br><span class="line">            <span class="hljs-keyword">int</span> ans = query(<span class="hljs-number">1</span>, t, op[i].k);</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, b[ans]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            add(op[i].l, <span class="hljs-number">-1</span>);</span><br><span class="line">            a[op[i].l] = op[i].r;</span><br><span class="line">            add(op[i].l, <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="训练题"><a class="header-anchor" href="#训练题">¶</a>训练题</h2><p>  打算单独开一个。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构-主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复分析1-基础</title>
      <link href="/Math/complex-analysis1/"/>
      <url>/Math/complex-analysis1/</url>
      
        <content type="html"><![CDATA[<h2 id="复数及复空间"><a class="header-anchor" href="#复数及复空间">¶</a>复数及复空间</h2><h3 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h3><p>$z=x+iy=re^{i\theta}=r(\cos{\theta}+i\sin{\theta})$</p><p>取$-\pi\lt\theta_0\le\pi$作为$z$的辐角主值, 则$\arg z=\begin{cases}\arctan{\frac{y}{x}}&amp;z\text{在1,4象限}\\arctan{\frac{y}{x}}\pm\pi&amp;z\text{在2,3象限}\end{cases}$</p><p>$\mathrm{Arg}z=\arg{z}+2k\pi$</p><p>$z<sup>n=r</sup>n(\cos{n\theta}+i\sin{n\theta})$</p><p>$w=\sqrt[n]{z}=r^{\frac{1}{n}}\left(\cos{\frac{\theta+2k\pi}{n}}+i\sin{\frac{\theta+2k\pi}{n}}\right)$</p><p>$z\overline{z}=|z|^2$</p><p>$\begin{cases}|z_1z_2|=|z_1||z_2|\<br>\mathrm{Arg}(z_1z_2)=\mathrm{Arg}z_1+\mathrm{Arg}z_2\end{cases}$</p><p>$\begin{cases}|z_1/z_2|=|z_1|/|z_2|\<br>\mathrm{Arg}\frac{z_1}{z_2}=\mathrm{Arg}z_1-\mathrm{Arg}z_2\end{cases}$</p><p>  <strong>定理1</strong><br>$$(1)\ |z_1+z_2|\leq|z_1|+|z_2|$$<br>$$(2)\ ||z_1|-|z_2||\le|z_1-z_2|$$</p><p>  <strong>定理2</strong> 设 $a_k,b_k(k=1,2,\cdots,n)$ 为复数, 则<br>$$\left|\sum_{k=1}<sup>na_kb_k\right|\le\left(\sum_{k=1}</sup>n|a_k|<sup>2\right)\left(\sum_{k=1}</sup>n|b_k|^2\right)$$</p><p>  <strong>证明:</strong> 设$t$为任意复数, 则<br>$$0\le\left|a_k-t\overline{b}<em>k\right|<sup>2=(a_k-t\overline{b}_k)(\overline{a}_k-\overline{t}b_k)\=|a_k|</sup>2-2\operatorname{Re}\overline{t}a_kb_k+|t|<sup>2|b_k|</sup>2$$<br>累加得<br>$$0\le\sum</em>{k=1}<sup>n|a_k|</sup>2-2\operatorname{Re}(\overline{t}\sum_{k=1}<sup>na_kb_k)+|t|</sup>2\sum_{k=1}<sup>n|b_k|</sup>2$$<br>令$t=\sum\limits_{k=1}<sup>na_kb_k/\sum\limits_{k=1}</sup>n|b_k|^2$, 代入得<br>$$0\le\sum_{k=1}<sup>n|a_k|</sup>2-\frac{2\operatorname{Re}\left|\sum\limits_{k=1}<sup>na_kb_k\right|</sup>2}{\sum\limits_{k=1}<sup>n|b_k|</sup>2}+\frac{\left|\sum\limits_{k=1}<sup>na_kb_k\right|</sup>2}{\sum\limits_{k=1}<sup>n|b_k|</sup>2},$$<br>化简即证.</p><h3 id="圆周和直线方程"><a class="header-anchor" href="#圆周和直线方程">¶</a>圆周和直线方程</h3><p>  <strong>定理3</strong> 给定方程 $Az\overline{z}+\overline{B}z+B\overline{z}+C=0$, 其中 $A,C\in\mathbb{R}$, $B\in\mathbb{C}$, 且 $|B|^2-AC\gt 0$, 则方程是一圆周方程, 即 $\left|z+\frac{B}{A}\right|=\frac{\sqrt{|B|^2-AC}}{|A|}$.</p><h3 id="关于圆周的对称点"><a class="header-anchor" href="#关于圆周的对称点">¶</a>关于圆周的对称点</h3><p>  <strong>定理4</strong> 给定两点 $z_1,z_2$ 和圆周 $Az\overline{z}+\overline{B}z+B\overline{z}+C=0$, 其系数满足 $|B|^2-AC\gt0$, 则$z_1,z_2$关于圆周对称的充分必要条件为$Az_2\overline{z_1}+\overline{B}z_2+B\overline{z_1}+C=0$</p><h3 id="复数的球面表示与扩充复平面"><a class="header-anchor" href="#复数的球面表示与扩充复平面">¶</a>复数的球面表示与扩充复平面</h3><p> 考虑 $\mathbb{R}^3$ 中的单位球面 $S={(x,y,z)|x<sup>2+y</sup>2+z^2=1}$，点 $N(0,0,1)$ 称为<strong>北极</strong>，复平面 $\mathbb{C}={(x,y,0)|x,y\in \mathbb{R}}$ 表示复数集。$\forall z\in\mathbb{C}$, 直线 $zN$ 与球面 $S$ 相交于一点 $Z$。若 $|z|&lt;1$, $Z$ 在下半球面; 若 $|z|&gt;1$, $Z$ 在上半球面; 若$|z|=1$, 则 $Z=z$. 在 $\mathbb{C}$ 中引入理想点, 称为<strong>无穷远点</strong>, 记作 $z=\infty$. 扩展复平面 $\overline{\mathbb{C}}=\mathbb{C}\bigcup{\infty}$, $\overline{\mathbb{C}}$ 与 $S$ 上的点建立起一一对应关系, $S$ 称为<strong>黎曼球面</strong>, $\overline{\mathbb{C}}$ 与 $S$ 这种一一对应称为<strong>球极射影</strong>.</p><p>  设 $z=x+iy$, 对应的 $Z=(x_1,x_2,x_3)$, 过 $z,N$ 的直线上的点为<br>$$tN+(1-t)z,\quad-\infty\lt t\lt\infty$$<br>即<br>$$((1-t)x,(1-t)y,t),\quad-\infty\lt t\lt\infty$$<br>$\exists\ t\in(-\infty,\infty)$, 使<br>$$x_1=(1-t)x,\quad x_1=(1-t)y,\quad x_3=t.$$</p><p>$Z$ 在 $S$ 上, 坐标满足</p><p>$$1=(1-t)<sup>2x</sup>2+(1-t)<sup>2y</sup>2+t<sup>2=(1-t)</sup>2|z|<sup>2+t</sup>2$$</p><p>解得 $t=1$ 或 $t=\displaystyle\frac{|z|<sup>2-1}{|z|</sup>2+1}$. 因$Z\neq N$, 与 $Z$ 对应的 $t$ 只能为</p><p>$$t=\displaystyle\frac{|z|<sup>2-1}{|z|</sup>2+1},\quad 1-t=\displaystyle\frac{2}{|z|^2+1}$$</p><p>则 $Z$ 的坐标</p><p>$$\begin{cases}x_1=(1-t)x=\displaystyle\frac{z+\overline{z}}{|z|^2+1},\<br>x_2=(1-t)y=\displaystyle\frac{z-\overline{z}}{i(|z|^2+1)},\<br>x_3=t=\displaystyle\frac{|z|<sup>2-1}{|z|</sup>2+1}\end{cases}$$</p><p>反之, 由 $Z$ 的坐标 $(x_1,x_2,x_3)$求对应点 $z$ 的公式为:<br>$$z=x+iy=\frac{x_1+ix_2}{1-t}=\frac{x_1+ix_2}{1-x_3}.$$</p><h2 id="复平面的拓扑"><a class="header-anchor" href="#复平面的拓扑">¶</a>复平面的拓扑</h2><h3 id="开集与闭集"><a class="header-anchor" href="#开集与闭集">¶</a>开集与闭集</h3><p> open disc $D_r(z_0)$ of radius $r$ centered at $z_0$ : $D_r(z_0)={z\in\mathbb{C}:|z-z_0|\lt r}$, closed disc $\overline{D_r}(z_0)$ of radius r centered at $z_0$ is defined by $\overline{D_r}(z_0)={z\in\mathbb{C}:|z-z_0|\le r}$, boundary $C_r(z_0)={z\in\mathbb{C}:|z-z_0|\le r}$, unit disc $D={z\in\mathbb{C}:|z|\lt1}$.</p><p> The boundary of a set $\Omega$ is equal to its closure minus its interior, and is often denoted by $\partial\Omega$.</p><h3 id="完备性"><a class="header-anchor" href="#完备性">¶</a>完备性</h3><p>  序列${z_n}$收敛于$w\in\mathbb{C}$, 有$\lim\limits_{n\to\infty}|z_n-w|=0$, 记为$w=\lim\limits_{n\to\infty}z_n$, 容易证明其充分必要条件为<br>$$\lim_{n<br>\to\infty}\operatorname{Re}z_n=\operatorname{Re}w,\quad\lim_{n\to\infty}\operatorname{Im}z_n=\operatorname{Im}w$$</p><p>  $\mathbb{C}$中序列${z_n}$称为$Cauchy$序列, 如果$\forall\varepsilon\gt0,\exists$正整数$N$, 使得$n,m\ge N$时, 有$|z_n-z_m|&lt;\varepsilon$.</p><p>  <strong>定理1</strong> 设${z_n}$为$\mathbb{C}$中$Cauchy$序列, 则序列${z_n}$收敛到$w$, 或序列极限存在.</p><p> If $\Omega\subset\mathbb{C}$ is bounded, we define its diameter by<br>$$\operatorname{diam}(\Omega)=\sup_{z,w\in\Omega}|z-w|$$</p><p>  <strong>Cantor定理</strong> 若$\Omega\subset\mathbb{C}(n=1,2,\cdots)$为闭集, 且$\Omega_1\supset\Omega_2\supset\cdots\supset\Omega_n\supset\cdots, \operatorname{diam}(\Omega_n)\to0\quad as\ n\to \infty$, 则$\bigcap\limits_{n=1}^{\infty}\Omega_n$由一点组成.</p><h3 id="紧性"><a class="header-anchor" href="#紧性">¶</a>紧性</h3><p>  $\mathbb{C}$或$\overline{\mathbb{C}}$中集合$E$称为紧集, 如果任一开集族$\mathscr{G}$覆盖$E$, 即$E$中的每一点至少属于$\mathscr{G}$中某一开集, 则必能从$\mathscr{G}$中选出有穷个开集$G_1,G_2,\cdots,G_n$覆盖$E$, 即$E\subset\bigcup\limits_{j=1}^nG_j$.</p><p>  <strong>Heine-Borel定理</strong> 若$E\subset\mathbb{C}$是有界闭集, 则$E$为$\mathbb{C}$中的闭集.</p><p>  <strong>Bolzano-Weierstrass定理</strong> 任一无穷集至少有一极限点(或任一序列至少有一收敛子列, 子列可以收敛到$\infty$)</p><h3 id="曲线"><a class="header-anchor" href="#曲线">¶</a>曲线</h3><p>  <strong>连续曲线</strong> 定义为区间$[a,b]$上的连续复值函数$z(t)=x(t)+iy(t)\quad(a\le t\le b)$</p><p>  <strong>可求长曲线</strong> 给定曲线$\gamma(t):a\le t\le b.$对区间$[a,b]$作分割<br>$$\Delta:a=t_0\le t_1\le\cdots\le t_n=b.$$<br>以$z_j=z(t_j)(0\le j\le n)$为顶点作折线$P$, $P$的长度为<br>$$\sum_{j=1}^n|z(t_j)-z(t_{j-1})|.$$<br>并对$[a,b]$的任意分割$\Delta$, 上式有界, 则称曲线$z(t)$为<strong>可求长曲线</strong>, 并称上确界<br>$$L=\sup_\sum_{j=1}^n|z(t_j)-z(t_{j-1})|$$<br>为曲线$z(t)$的长度.</p><p> We say that the parametrized curve is <strong>smooth</strong> if $z’(t)$ exists and is continuous on $[a,b]$, and $z’(t)\neq0$ for $t\in[a,b]$.</p><p> We can define a curve $\gamma^-$ obtained from the curve $\gamma$ by reversing the orientation. As a particular parametrization for $\gamma^-$ we can take $z<sup>-:[a,b]\to\mathbb{R}</sup>2$ defined by<br>$$z^-(t)=z(b+a-t).$$</p><p> A smooth or piecewise-smooth curve is closed if $z(a)=z(b)$ for any of its parametrizations. Finally, a smooth or piecewise-smooth curve is <strong>simple</strong>(Jordan curve) if it is not self-intersecting, that is, $z(t)\neq z(s)\ unless\ s=t$.</p><p>  <strong>引理</strong> 设$f(t)$为$[a,b]$上的复值连续函数, 则<br>$$\left|\int_a<sup>bf(t)\mathrm{d}t\right|\leq\int_a</sup>b|f(t)|\mathrm{d}t.$$</p><p>  <strong>定理2</strong> 设$z(t)(a\le t\le b)$为光滑曲线, 则必为可求长曲线, 且长度为<br>$$L=\int_{a}^b|z’(t)|\mathrm{d}t.$$</p><h3 id="连通性"><a class="header-anchor" href="#连通性">¶</a>连通性</h3><p>  <strong>定义</strong> 设$E$为$\mathbb{C}$(或$\overline{\mathbb{C}}$)中集合, 称$E$为连通集, 如果不存在$\mathbb{C}$(或$\overline{\mathbb{C}}$)中满足下列条件的开集$G_1,G_2$:</p><p>  (1) $G_1\cap G_2=\varnothing;$</p><p>  (2) $E\cap G_1\neq\varnothing, E\cap G_2\neq\varnothing;$</p><p>  (3) $E\subset(G_1\cup G_2).$</p><p>即不能用两个不相交非空集将其一分为二, 则称$E$为连通集.</p><p>  <strong>定义</strong> 称连通开集为<strong>区域</strong>, 称区域的闭包为<strong>闭区域</strong>.</p><p>  <strong>定理3</strong> 若$D$是开集, 则$D$的连通性与道路连通是等价的.</p><p>  <strong>定义</strong> $D$为区域, 若$\overline{\mathbb{C}}\setminus D$是连通集, 则称$D$为<strong>单连通区域</strong>.</p><p>  <strong>Jordan定理</strong> 设$\gamma\subset D$为Jordan曲线, 它把$\overline{\mathbb{C}}$分成两个单连通区域, 其中一个是有界的, 称为$\gamma$的内部, 另一个是无界的, 称为$\gamma$的外部, $\gamma$是这两个单连通区域的共同边界.</p><p>  <strong>定理4</strong> 设$D\subset\mathbb{C}$为区域, 则$D$为单连通区域的充分必要条件是: 对任一Jordan曲线$\gamma\subset D$, $\gamma$的内部属于$D$.</p><p>  <strong>定义</strong> 集合$E$的最大连通子集称为$E$的一个分支.</p><p>  <strong>定义</strong> 设$D$为区域, 若$\overline{\mathbb{C}}\setminus D$由$n$个连通分支组成, 则称$D$为<strong>n连通区域</strong>.</p><h3 id="连续函数"><a class="header-anchor" href="#连续函数">¶</a>连续函数</h3><p>  如果$f(z_1)=f(z_2)$蕴含着$z_1=z_2$, 即$E$中不同点的像也是$F$中的不同点, 则称映射$f$是一一的, 或<strong>单叶</strong>或<strong>双方单值</strong>的. 在这种情况下, $w=f(z)$有一个定义在$f(E)$上的反函数或逆映射, 记作$z=f^{-1}(w)$.</p><h2 id="解析函数"><a class="header-anchor" href="#解析函数">¶</a>解析函数</h2><p>  <strong>定义:</strong> 当$z\in D$趋于$z_0$时, 若极限<br>$$\lim_{z\to z_0}\frac{f(z)-f(z_0)}{z-z_0}$$<br>存在, 则称$f(z)$在点$z=z_0$<strong>可导</strong>, 极限值称为$f(z)$在$z_0$点的<strong>导数</strong>, 记作$f’(z_0)$.</p><p>  <strong>定义:</strong> 如果函数在$z_0$点的改变量可写成$\Delta f=A(z_0)\Delta z+O(\Delta z)$, 则称$f(z)$在$z=z_0$点<strong>可微</strong>, 微分$\mathbb{d}f(z_0)=A(z_0)\Delta z$.</p><p>  若函数$f(z)$在域$D$内的每一点可导, 则称函数$f(z)$在域$D$内是<strong>解析</strong>的(analytic)或<strong>全纯</strong>的(holomorphic). 函数$f(z)$在$z_0$邻域内解析, 则称$f(z)$在$z_0$点解析.</p><p> we fix $y_0$ and think of $f$ as a complex-valued fuction of the single real variable $x$.</p><p>$$f’(z_0)=\lim_{h_1\to0}\frac{f(x_0+h_1,y_0)-f(x_0,y_0)}{h_1}=\frac{\partial f}{\partial x}(z_0)$$</p><p> Now taking h purely imaginary, say $h=ih_2$, a similar argument yields</p><p>$$f’(z_0)=\lim_{h_2\to0}\frac{f(x_0,y_0+h_2)-f(x_0,y_0)}{ih_2}=\frac{1}{i}\frac{\partial f}{\partial y}(z_0)$$</p><p> Therefore, if $f$ is holomorphic we have shown that</p><p>$$\frac{\partial f}{\partial x}=\frac{1}{i}\frac{\partial f}{\partial y}$$</p><p> Writing $f=u+iv$</p><p>$$f’(z)=\frac{\partial u}{\partial x}+\frac{1}{i}\frac{\partial v}{\partial x}=\frac{1}{i}\frac{\partial u}{\partial y}+\frac{\partial v}{\partial x}$$</p><p>  <strong>定理1</strong> 设函数$f(z)=u(z)+iv(z)$定义在区域$D$内, 则$f(z)$在$z_0\in D$点可微的充要条件为: $u(z),v(z)$在$z_0$点可微, 且在该点偏导数满足<strong>Cauchy-Riemann方程</strong>(简称$C-R$方程)：<br>$$\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y}\quad and\quad\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x}$$</p><p> we can clarify the situation further by defining two differential operators<br>$$\frac{\partial}{\partial z}=\frac{1}{2}\left(\frac{\partial}{\partial x}+\frac{1}{i}\frac{\partial}{\partial y}\right)\quad and\quad\frac{\partial}{\partial{\overline{z}}}=\frac{1}{2}\left(\frac{\partial}{\partial x}-\frac{1}{i}\frac{\partial}{\partial y}\right)$$</p><h3 id="指数函数"><a class="header-anchor" href="#指数函数">¶</a>指数函数</h3><p>  设$z=x+iy$,<strong>指数函数</strong>$e^z$定义为:<br>$$e<sup>z=e</sup>x(\cos{y}+i\sin{y})$$<br>易证如下性质</p><p>  (1) $e<sup>z\gt0,|e</sup>z|=e^x\gt0$</p><p>  (2) $e<sup>{z_1+z_2}=e</sup>{z_1}\cdot e^{z_2}$</p><p>  (3) $e^z$是以$2\pi i$为周期的周期函数</p><p>  (4) $e^z$在$\mathbb{C}$上解析, 且$(e<sup>z)’=e</sup>z$</p><h3 id="儒可夫斯基函数"><a class="header-anchor" href="#儒可夫斯基函数">¶</a>儒可夫斯基函数</h3><p>  称函数<br>$$w=f(z)=\frac{1}{2}\left(z+\frac{1}{z}\right)$$<br>为<strong>儒可夫斯基函数</strong></p><h3 id="分式线性变换"><a class="header-anchor" href="#分式线性变换">¶</a>分式线性变换</h3><p>  称函数<br>$$w=f(z)=\frac{az+b}{cz+d}\quad(ad-bc\neq0)$$<br>为<strong>分式线性变换</strong>, 也称为<strong>Mobius变换</strong></p><h3 id="三角函数"><a class="header-anchor" href="#三角函数">¶</a>三角函数</h3><p>定义正弦函数和余弦函数<br>$$\sin{z}=\frac{e<sup>{iz}-e</sup>{-iz}}{2i},\quad\cos{z}=\frac{e<sup>{iz}+e</sup>{-iz}}{2}.$$<br>则<br>$$\mathrm{ch}{z}=\cos{iz}=\frac{e<sup>z+e</sup>{-z}}{2},\quad\mathrm{sh}{z}=\frac{\sin{iz}}{i}=\frac{e<sup>z-e</sup>{-z}}{2}$$</p><p>$$\begin{cases}\cos{(x+iy)}=\cos{x}\mathrm{ch}{y}-i\sin{x}\mathrm{sh}{y}\<br>\sin{(x+iy)}=\sin{x}\mathrm{ch}{y}+i\cos{x}\mathrm{sh}{y}\end{cases}$$</p><p>$$\begin{cases}\mathrm{ch}{(x+iy)}=\mathrm{ch}{x}\cos{y}+i\mathrm{sh}{x}\sin{y}\<br>\mathrm{sh}{(x+iy)}=\mathrm{sh}{x}\cos{y}+i\mathrm{ch}{x}\sin{y}\end{cases}$$</p><p>具有如下性质</p><p>  (1) $\sin{z},\cos{z}$在$\mathbb{C}$上解析, 且$(\sin{z})’=\cos{z},\quad(\cos{z})’=-\sin{z}$</p><p>  (2) $\sin{z},\cos{z}$以$2\pi$为周期, $\sin{z}$为奇函数, $\cos{z}$为偶函数</p><p>  (3) 和角公式基本关系成立</p><p>  (4) $|\sin{z}|$和$|\cos{z}|$在$\mathbb{C}$上无界</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近世代数-群</title>
      <link href="/Math/Algebra-groups/"/>
      <url>/Math/Algebra-groups/</url>
      
        <content type="html"><![CDATA[<h2 id="半群-semigroups-幺半群-monoids-和群-groups"><a class="header-anchor" href="#半群-semigroups-幺半群-monoids-和群-groups">¶</a>半群(semigroups), 幺半群(monoids)和群(groups)</h2><p>  $G$ 是非空集合, $G$ 上的<strong>二元运算</strong>是映射 $G\times G\to G$.</p><p>  设 $R$ 是 $A$ 上的一个二元关系, 如果满足</p><ol><li>自反性, $aRa\ (\forall a\in A)$</li><li>对称性, $a_1Ra_2$ 蕴含 $a_2Ra_1\ (\forall a_1,a_2\in A)$</li><li>传递性, 即 $a_1Ra_2$ 且 $a_2Ra_3$ 蕴含 $a_1Ra_3\ (\forall a_1,a_2,a_3\in A)$</li></ol><p>则称 $R$ 为 $A$ 上的一个等价关系, $A$ 中互相等价的元素组成的子集称为一个等价类. 任意两个不同等价类的交为空集, 集合 $A$ 等于所有等价类的无交并. 等价关系用 $\sim$ 表示, $A$ 中所有等价类组成的集合记为 $A/\sim$.</p><p><strong>Definition</strong> 一个 <strong>半群</strong> 是一个非空集合 $G$ 和一个 $G$ 上的二元运算满足</p><p>  (i) 结合律: $a(bc)=(ab)c\quad\forall\ a,b,c\in G$;</p><p>一个 <strong>幺半群</strong> 是一个半群 $G$ 包含</p><p>  (ii) (双边的) 幺元 $e\in G$ 满足 $ae=ea=a\quad\forall a\in G$.</p><p>一个 <strong>群</strong> 是一个幺半群 $G$ 满足</p><p>  (iii) 对于任意 $a\in G$ 存在一个 (双边的) 逆元 $a^{-1}\in G$ 满足 $a<sup>{-1}a=aa</sup>{-1}=e$.</p><p>A semigroup $G$ is said to be <strong>abelian</strong> or <strong>commutative</strong> if its binary operation is</p><p>  (iv) 交换律: $ab=ba\quad\forall a,b\in G$.</p><p>  The <strong>order(阶)</strong> of a group $G$ is the cardinal number(基数) $|G|$. $G$ is said to be finite[resp. infinite] if $|G|$ is finite($|G|\lt\infty$)[resp. infinite].</p><p>只含单位元的群称为平凡群.</p><br><p><strong>Theorem</strong> If $G$ is a monoid, then the identity element e is unique. If $G$ is a group, then</p><p>  (i) $c\in G$ and $cc=c\Rightarrow c=e$;</p><p>  (ii) for all $a,b,c\in G$, $ab=ac\Rightarrow b=c$ and $ba=ca\Rightarrow b=c$(left and right cancellation);</p><p>  (iii) for each $a\in G$, 逆元 $a^{-1}$ 唯一;</p><p>  (iv) for each $a\in G$, $(a<sup>{-1})</sup>{-1}=a$;</p><p>  (v) for $a,b\in G$, $(ab)<sup>{-1}=b</sup>{-1}a^{-1}$;</p><p>  (vi) for $a,b\in G$, the equations $ax=b$ and $ya=b$ have unque solutions in $G:x=a^{-1}b$ and $y=ba^{-1}$.</p><p>  <strong>SKETCH OF PROOF.</strong> If $e^{’}$ is also a two-sided identity, then $e=ee<sup>{’}=e</sup>{’}.$ (i) $cc=c\Rightarrow c<sup>{-1}(cc)=c</sup>{-1}c\Rightarrow (c<sup>{-1}c)c=c</sup>{-1}c\Rightarrow ec=e\Rightarrow c=e;$ (ii), (iii) and (vi) are proved similarly. (v) $(ab)(b<sup>{-1}a</sup>{-1})=a(bb<sup>{-1})a</sup>{-1}=(ae)a<sup>{-1}=aa</sup>{-1}=e\Rightarrow(ab)<sup>{-1}=b</sup>{-1}a^{-1}$ by (iii); (iv) is proved similarly.</p><br><p><strong>Proposition</strong> Let $G$ be a semigroup. Then $G$ is a group if and only if the following conditions hold:</p><p>  (i) there exists an element $e\in G$ such that $ea=a$ for all $a\in G$ (left identity element(左单位元)) ;</p><p>  (ii) for each $a\in G$, there exists an element $a^{-1}\in G$ such that $a^{-1}a=e$ (left inverse(左逆)).</p><br><p><strong>Proposition</strong> Let $G$ be a semigroup. Then $G$ is a group if and only if for all $a,b\in G$ the equations $ax=b$ and $ya=b$ have solutions in $G$.</p><p>  Let $G$ and $H$ be groups with identities $e_G,e_H$ respectively, and define the <strong>direct product(直积)</strong> of $G$ and $H$ to be the group whose underlying set is $G\times H$ and whose binary operation is given by:</p><p>$$(a,b)(a<sup>{’}b</sup>{’})=(aa<sup>{’},bb</sup>{’}),\quad where\quad a,a^{’}\in G;b,b^{’}\in H.$$</p><p><strong>Theorem</strong> Let $R(\sim$) be an equivalence relation on a monoid $G$ such that $a_1\sim a_2$ and $b_1\sim b_2$ imply $a_1b_1\sim a_2b_2$ for all $a_i,b_i\in G$. Then the set $G/R$ of all equivalence classes of $G$ under $R$ is a monoid under the binary operation defined by $(\overline{a})(\overline{b})=\overline{ab}$, where $\overline{x}$ denotes the equivalence class of $x\in G$. If $G$ is an [abelian] group, then so is $G/R$.</p><p><strong>Theorem</strong> (Generalized Associative Law) lf $G$ is a semigroup and $a_1,\cdots,a_n\in G$, then any two meaningful products of $a_1,\cdots,a_n$ in this order are equal.</p><p><strong>Corollary</strong> (Generalized Commutative Law) If $G$ is a commutative semigroup and $a_1,\cdots,a_n\in G$, then for any permutation $i_1,\cdots,i_n$ of $1,2,\cdots,n$, $a_1a_2\cdots a_n=a_{i_1}a_{i_2}\cdots a_{i_n}$.</p><p><strong>Definition</strong> Let $G$ be a semigroup, $a\in G$ and $n\in N^<em>$. The element $a^n\in G$ is defined to be the standard n product $\displaystyle\prod_{i=1}^na_i$ with $a_i = a$ for $1&lt;i&lt;n$. If $G$ is a monoid, $a^0$ is defined to be the identity element $e$. lf $G$ is a group, then for each $n\in N^</em>$, $a^{-n}$ is defined to be $(a<sup>{-1})</sup>n\in G$.</p><p>例子</p><p>$\mathbb{Z}_n:=\mathbb{Z}/n\mathbb{Z}={\bar{0},\bar{1},\cdots,\overline{n-1}}$</p><ul><li>全体 $n$ 阶可逆复方阵形成乘法群, 叫做复数上的 $n$ 次一般线性群, 表示成 $GL(n,\mathbb{C})$, 一个子群特殊线性群 $SL(n,\mathbb{C})$ 表示行列式为 1 的 $n$ 阶复方阵全体.</li><li>$n$ 为正整数, $\bar{a}$ 为整数 $a$ 的模 $n$ 同余类, 则集合</li></ul><p>$$\mathbb{Z}_n^*={\bar{a}|(a,n)=1}$$</p><p>对于乘法形成阿贝尔群. 这个群有 $\varphi(n)$ 个元素.</p><h2 id="同态-homomorphisms-子群-subgroups"><a class="header-anchor" href="#同态-homomorphisms-子群-subgroups">¶</a>同态(homomorphisms), 子群(subgroups)</h2><p><strong>Definition</strong> Let $G$ and $H$ be semigroups. A function $f:G\to H$ is a <strong>homomorphism</strong> provided<br>$$f(ab) = f(a)f(b)\quad for\ all\ a,b\in G.$$<br>If $f$ is injective as a map of sets(单射), $f$ is said to be a <strong>monomorphism(单同态)</strong>. If $f$ is surjectice(满射), $f$ is called an <strong>epimorphism(满同态)</strong>. If $f$ is bijective(双射), $f$ is called an <strong>isomorphism(同构)</strong>. In this case $G$ and $H$<br>are said to be <strong>isomorphic</strong> (written $G\cong H$). A homomorphism $f:G\to G$ is called an <strong>endomorphism</strong> of $G$ and an isomorphism $f : G\to G$ is called an <strong>automorphism</strong> of $G$.</p><p>$\mathrm{Aut}(G)$ 表示群 $G$ 的自同构全体.</p><p><strong>Definition</strong> Let $f : G\to H$ be a homomorphism of groups. The <strong>kernel(核)</strong> of $f$ (denoted<br>$\mathrm{Ker}\ f$) is ${a\in G | f(a) = e \in H}$. If $A$ is a subset of $G$, then $f(A) = {b\in H | b = f(a)\ for\ some\ a\in A}$ is the <strong>image(象)</strong> of $A$. $f(G)$ is called the image of $f$ and denoted $\mathrm{Im}\ f$. If $B$ is a subset of $H$, $f^{-1}(B) = {a\in G | f(a)\in B}$ is the <strong>inverse image</strong> of B.</p><p><strong>Definition</strong> 设 $H$ 为群 $G$ 的非空子集. 如果 $H$ 在 $G$ 的运算下构成群, 则称 $H$ 为 $G$ 的子群, 记做 $H\leqslant G$. 此外, 若 $H\neq G$, 则称 $H$ 为 $G$ 的真子群, 表示成 $H\lt G$.</p><p><strong>Definition</strong> 设 $G$ 是一个群, $C={c\in G|gc=cg\ \forall g\in G}$, 即 $C$ 中元素与 $G$ 中任意一个元素的乘法可交换, 称 $C$ 是 $G$ 的中心.</p><p>群的中心必是子群.</p><h2 id="循环群-cyclic-groups"><a class="header-anchor" href="#循环群-cyclic-groups">¶</a>循环群(cyclic groups)</h2><p><strong>Definition</strong> 设 $G$ 为一个群，如果存在 $a$, 使得 $G$ 可以表示为 $G={a^n|n\in\mathbb{Z}}$, $G$ 被称为循环群.</p><h2 id="陪集-cosets-和计数-counting"><a class="header-anchor" href="#陪集-cosets-和计数-counting">¶</a>陪集(cosets) 和计数(counting)</h2><p>$a\equiv b\pmod m$ if and only if $m\mid a-b$, that is, if and only if $a-b$ is an element of the subgroup $<m>={mk|k\in\mathbb{Z}}$. More generally, we have</m></p><p><strong>Lemma</strong> 设 $G$ 是群, $H\leqslant G$, 定义 $G$ 上的关系为: 对于 $g,h\in G,g\sim h\Leftrightarrow gh^{-1}\in H$, 则 $\sim$ 是 $G$ 上的等价关系, 并且元素 $g$ 对此等价关系的等价类是 $Hg$.</p><p>  由引理知, 群 $G$ 可以分拆形如 $Hg$ 的一些集合, 每个等价类 $Hg$ 叫做 $G$ 对于子群 $H$ 的右陪集. 如果 $R={g_i|i\in I}$ 是 $G$ 对于上述等价元素的完全代表元素, 则它通常叫做 $G$ 对 $H$ 的右陪集代表元素, 有分拆</p><p>$$G=\bigcup_{g\in R}Hg$$</p><p><strong>Definition</strong> 设 $H\leqslant G, a\in G$, 形如 $aH(Ha)$ 的子集为 $H$ 的一个左(右)陪集.</p><p><strong>Definition</strong> Let $H$ be a subgroup of a group $G$. The index of $H$ in $G$, denoted $[G: H]$, is the cardinal number of the set of distinct right [resp. left] cosets of $H$ in $G$.</p><p><strong>Theorem</strong> 设 $H\leqslant G$, 有</p><p>(i) $a\in Hb\Leftrightarrow ab^{-1}\in H\Leftrightarrow Ha=Hb\ (\forall a,b\in G)$</p><p>(ii) $|Ha|=|H|=|aH|\ (\forall a\in G)$</p><p>(iii) If $\mathcal{R}$ is the set of distinct right cosets of $H$ in $G$ and $\mathcal{L}$ is the set of distinct left cosets of $H$ in $G$, then $|\mathcal{R}|=|\mathcal{L}|$</p><p><strong>Theorem</strong> $K,H,G$ are groups with $K &lt; H &lt; G$, then $[G : K] = [G : H][H : K]$. If any two of these indices are finite, then so is the third.</p><p>   <strong>PROOF.</strong> $G=\bigcup\limits_{i\in I}Ha_i, H=\bigcup\limits_{j\in J}Kb_j\ (a_i\in G,b_j\in H), |I|=[G: H],|J|=[H: K]$. we must have $[G:K]=|I\times J|=|I||J|$</p><p><strong>Corollary(Lagrange)</strong> If $H$ is a subgroup of a group $G$, then $|G| = [G: H]|H|$. In particular if $G$ is finite, the order $|a|$ of $a\in G$ divides $|G|$.</p><p>由拉格朗日定理我们知道, $1$ 个 $6$ 阶群中只能有 $1,2,3,6$ 阶群, 素数阶群只能有平凡子群.</p><h2 id="正规子群-normal-subgroups-商群-quotient-groups-和同态定理-homomorphisms"><a class="header-anchor" href="#正规子群-normal-subgroups-商群-quotient-groups-和同态定理-homomorphisms">¶</a>正规子群(normal subgroups), 商群(quotient groups), 和同态定理(homomorphisms)</h2><p><strong>Definition</strong> 群 $G$ 的子群 $N$ 叫做 $G$ 的正规子群, 是指对每个 $g\in G$, $g^{-1}Ng=N$. 如果 $N$ 是 $G$ 的正规子群, 则表示成 $N\lhd G$.</p><p><strong>Lemma</strong> 设 $N\leqslant G$, 则下列条件等价</p><p>(i) $N\lhd G$</p><p>(ii) 对每个 $g\in G$, $gN=Ng$</p><p>(iii) $N_G(N)=G$</p><p>(iv) $G$ 对 $N$ 的每个左陪集均是右陪集</p><p><strong>Theorem(同态基本定理)</strong> 设 $f:G\to G^<code>$ 是群的同态. 则 $\mathrm{Im}f=f(G)$ 是 $G^</code>$ 的子群, $\mathrm{Ker}f=f^{-1}(1)={g\in G|f(g)=1}$ 是 $G$ 的正规子群, 并且有群同构</p><p>$$\bar{f}: G/\mathrm{Ker}f\cong\mathrm{Im}f$$</p><h2 id="置换群"><a class="header-anchor" href="#置换群">¶</a>置换群</h2><p>  集合 $\Sigma$ 到自身上的每一个一一对应 $\sigma$ 叫做 $\Sigma$ 上的一个置换. 如果 $\Sigma={a_1,\cdots,a_n}$ 是有限集, 置换可表示成</p><p>$$\sigma=<br>\begin{pmatrix} a_1&amp;a_2&amp;\cdots&amp;a_n\<br>\sigma(a_1)&amp;\sigma(a_2)&amp;\cdots&amp;\sigma(a_n)\end{pmatrix}$$</p><p>  若 $\sigma$ 和 $\tau$ 是 $\Sigma$ 上的两个置换, 则置换 $\sigma\tau$ 定义为</p><p>$$(\sigma\tau)(a_i)=\sigma(\tau(a_i))\quad(1\le i\le n)$$</p><p>  例如</p><p>$$\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;a_4\a_1&amp;a_3&amp;a_4&amp;a_2\end{pmatrix}<br>\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;a_4\a_4&amp;a_3&amp;a_2&amp;a_1\end{pmatrix}=<br>\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;a_4\a_2&amp;a_4&amp;a_3&amp;a_1\end{pmatrix}$$</p><p>以 $S(\Sigma)$ 表示 $\Sigma$ 上全部置换构成的集合, 这是一个 $n!$ 元群, $n=|\Sigma|$, 幺元素是恒等置换</p><p>$$1_{\Sigma}=\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;a_4\a_1&amp;a_2&amp;a_3&amp;a_4\end{pmatrix}$$</p><p>$S(\Sigma)$ 称为集合 $\Sigma$ 上的对称群, 它的每个子群均叫做集合 $\Sigma$ 上的置换群.</p><p>任意 $n$ 元置换都可以表示成不交的轮换之积, 例如</p><p>$$\sigma=\begin{pmatrix}<br>1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\<br>5&amp;3&amp;6&amp;4&amp;2&amp;1&amp;8&amp;7<br>\end{pmatrix}$$</p><p>可表示为 $\sigma=\begin{pmatrix}1&amp;5&amp;2&amp;3&amp;6\end{pmatrix}\begin{pmatrix}4\end{pmatrix}\begin{pmatrix}7&amp;8\end{pmatrix}$</p><h2 id="群在集合上的作用"><a class="header-anchor" href="#群在集合上的作用">¶</a>群在集合上的作用</h2><p>  设 $\Sigma$ 是一个集合, $S(\Sigma)$ 是 $\Sigma$ 上的对称群, 群 $G$ 到 $S(\Sigma)$ 的每个同态 $f:G\to S(\Sigma)$ 都叫做群 $G$ 在集合 $\Sigma$ 上的一个置换表示. 如果 $f$ 是单同态, 则称 $f$ 是忠实表示.</p><p>  设 $\pi:G\to S(\Sigma)$ 是一个置换表示. 在 $\Sigma$ 上定义如下的关系: 对于 $a,b\in \Sigma, a\sim b\Leftrightarrow \exists g\in G, ga=b$. 这是一个等价关系. 因为 (1) $a\sim a$; (2) 若$a\sim b$, 则$b\sim a$; (3) 若 $a\sim b,b\sim c$, 则 $a\sim c$.</p><p>  对上述等价关系, $\Sigma$ 中元素 $a$ 所在的等价类是 $[a]=Ga={ga|g\in G}$. 每个等价类叫一个 $G-$ 轨道, 简称轨道. 如果 $G$ 在 $\Sigma$ 上的作用只有一个轨道, 则称 $G$ 在 $\Sigma$ 上是传递的.</p><p><strong>Theorem(Cayley)</strong> 每个群同构于某个置换群.</p><p>  设群 $G$ 作用于集合 $\Sigma$ 上, 则对每个元素 $a\in G$, $G_a={g\in G|ga=a}$ 是 $G$ 的一个子群, 叫做元素 $a$ 的固定子群.</p><p><strong>Theorem(轨道公式)</strong> 设有限群 $G$ 作用于集合 $\Sigma$ 上, $a\in\Sigma$, 则 $|G|=|G_a||[a]|$.</p><p><strong>Theorem(Burnside引理)</strong> 设 $G$ 是一个有限群, $X$ 是一个有限 $G-$ 集合, 则</p><p>$$|X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g|$$</p><p>其中 $X^g={x\in X|gx=x}$.</p><p><strong>PROOF.</strong> 对 $\sum\limits_{g\in G}|X^g|$ 改变求和方式</p><p>$$\sum_{g\in G}|X^g|=|{(g,x)\in G\times X|gx=x}|=\sum_{x\in X}|G_x|$$</p><p>由轨道公式</p><p>$$\sum_{x\in X}=\sum_{x\in X}\frac{|G|}{|[x]|}=|G|\sum_{x\in X}\frac{1}{|Gx|}$$</p><p>将 $x$ 按等价类划分再求和, $Gx$ 就是 $x$ 所在等价类</p><p>$$\sum_{x\in X}\frac{1}{|Gx|}=\sum_{A\in X/G}\sum_{x\in A}\frac{1}{|A|}=\sum_{A\in X/G}1=|X/G|$$</p><p>  对于有 $m$ 种颜色的染色问题, $|X<sup>g|=m</sup>{c(g)}$, $|X^g|$ 表示在置换 $g$ 的作用下, 保持不变的染色方案数. 将 $g$ 分解为不相交的 $c(g)$ 个循环的乘积, 某个染色方案不变, $g$ 的每个循环对应元素要染相同的颜色. 一共 $m$ 种颜色, $c(g)$ 个循环, 故共有 $m^{c(g)}$ 种方案, $|X<sup>g|=m</sup>{c(g)}$.</p><p><strong>Theorem(Polya计数定理)</strong> 设 $N={1,2,\cdots,n}$ 是被染色物体的集合, $G={\sigma_1,\sigma_2,\cdots,\sigma_n}$ 是 $N$ 上的置换群, 用 $m$ 种颜色对 $N$ 中的元素进行染色, 在 $G$ 的作用下不同染色方案数是</p><p>$$l=\frac{1}{|G|}\sum_{k=1}<sup>{|G|}m</sup>{c(\sigma_k)}$$</p><p>其中 $c(\sigma_k)$ 是置换 $\sigma_k$ 的轮换表示式中含 1 阶轮换在内的轮换个数.</p><p>  2 种颜色对 4 个方个染色, 允许方格围绕中心旋转, 围绕中心逆时针旋转有 $4$ 种可能:<br>$0\degree: \sigma_1=\begin{pmatrix}1\end{pmatrix}$,<br>$90\degree:\sigma_2=\begin{pmatrix}1&amp;2&amp;3&amp;4\end{pmatrix}$,<br>$180\degree: \sigma_3=\begin{pmatrix}1&amp;3\end{pmatrix}\begin{pmatrix}2&amp;4\end{pmatrix}$,<br>$270\degree: \sigma_4=\begin{pmatrix}1&amp;4&amp;3&amp;2\end{pmatrix}$,<br>由 Polya 定理</p><p>$$l=\frac{1}{4}(2<sup>4+2</sup>1+2<sup>2+2</sup>1)=6$$</p><h2 id="sylow-定理"><a class="header-anchor" href="#sylow-定理">¶</a>Sylow 定理</h2><p><strong>Definition</strong> 设 $G$ 为有限群, $p$ 为素数, $p^l\mid|G|$, 则称 $G$<br>的 $p^l$ 阶子群为 $G$ 的 Sylow p 子群.</p><p><strong>Theorem(第一定理)</strong> 设 $G$ 为有限群, $p$ 为素数, $p^k\mid|G|$, 则 $G$<br>有 $p^k$ 阶子群. 特别地, $G$ 中存在 Sylow p 子群.</p><p><strong>Theorem(第二定理)</strong> 设 $G$ 为有限群, $p$ 为素数, $P$ 为 $G$ 的一个 Sylow p 子群. 又设 $p^k\mid|G|$, 则 $G$ 的 $p^k$ 阶子群必含于 $P$ 的某个共轭子群中.</p><p><strong>Theorem(第三定理)</strong> 设 $G$ 为有限群, $p$ 为素数, $|G|=p^lm,(p,m)=1$. 以 $r$ 记 $G$ 的 Sylow p 子群个数, 则 $r\equiv1\pmod p$ 且 $r|m$.</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python科学计算-NumPy</title>
      <link href="/Python/Python-NumPy/"/>
      <url>/Python/Python-NumPy/</url>
      
        <content type="html"><![CDATA[<p>参考文献:</p><ol><li><p><a href="https://numpy.org/doc/stable/reference/index.html" target="_blank" rel="noopener">NumPy Reference</a></p></li><li><p><a href="https://numpy.org/doc/stable/user/index.html" target="_blank" rel="noopener">NumPy User Guide</a></p></li><li><p><a href="https://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="noopener">Python Numpy Tutorial (with Jupyter and Colab)</a></p></li><li><p><a href="https://www.runoob.com/numpy/numpy-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p></li><li><p><a href="https://aistudio.baidu.com/aistudio/projectDetail/118377" target="_blank" rel="noopener">挑战NumPy100关</a></p></li></ol><hr><p>  我们知道 Python 用 list 结构保存一组值，可以当作数组用，列表的元素可以是任何对象，因此列表中保存的是对象的指针。对数值运算而言，这种结构比较耗费内存和CPU。此外还有 array 模块，能直接保存数值，但不支持多维数组，也没有各种运算函数，也不适合做数值运算。</p><p>  NumPy 的诞生弥补了这些不足，它提供 ndarray(n-dimensional array object) 和 ufunc(universal function object) 两种基本对象。以下为本文的导入方式和 NumPy 版本号:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.__version__</span><br><span class="line"><span class="hljs-string">'1.16.4'</span></span><br></pre></td></tr></table></figure><h1>ndarray 对象</h1><h2 id="创建"><a class="header-anchor" href="#创建">¶</a>创建</h2><p>  通过给 array()函数传递 Python 的序列对象来创建数组。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = np.array((<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</span><br></pre></td></tr></table></figure><p>  数组的形状通过 shape 属性获得 它是一个描述数组各个轴的长度的元组(tuple):</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.shape b.shape c.shape</span><br><span class="line">(<span class="hljs-number">4</span>,)    (<span class="hljs-number">4</span>,)    (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span><br></pre></td></tr></table></figure><p>  下面的例子将数组c 的 shape 属性改为(4,3)，并不是对数组进行转置，而是改变每个轴大小，数组元素在内存中的位置并没有改变。此外，当设置某个轴元素个数为-1时，将自动计算此轴长度。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.shape = <span class="hljs-number">4</span>, <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c</span><br><span class="line">array([[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">7</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]])</span><br></pre></td></tr></table></figure><p>  使用数组的 reshape()方法，可以创建指定形状的新数组，而原数组形状保持不变。数组 a 和 d 共享数据存储空间，修改任意一个数组元素会同时修改另一个数组的内容。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>d = a.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span></span><br><span class="line">     d             a</span><br><span class="line">------------ --------------</span><br><span class="line">[[  <span class="hljs-number">1</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="line"> [  <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure><h2 id="元素类型"><a class="header-anchor" href="#元素类型">¶</a>元素类型</h2><p>  数组的元素类型可以通过 dtype 属性获得。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.dtype</span><br><span class="line">dtype(<span class="hljs-string">'int32'</span>)</span><br></pre></td></tr></table></figure><p>  可以通过 dtype 参数在创建数组时指定元素类型，注意 float 是 64 位的双精度浮点类型，complex 是 128 位的双精度复数类型。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ai32 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=np.int32)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>af = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=float)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ac = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=complex)</span><br><span class="line">ai32.dtype af.dtype ac.dtype</span><br><span class="line">int32      float64  complex128</span><br></pre></td></tr></table></figure><p>  在需要指定 dtype 参数时，也可以传递一个字符串来表示元素的数值类型。NumPy 中的每个数值类型都有几种字符串表示方式，字符串和类型之间的对应关系储存在 typeDict 字典中。下面例子获得与 float64 类型对应的所有键值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>[key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> np.typeDict.items() <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> np.float64]</span><br><span class="line">[<span class="hljs-string">'double'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'float64'</span>, <span class="hljs-string">'Float64'</span>, <span class="hljs-string">'f8'</span>, <span class="hljs-string">'float_'</span>, <span class="hljs-string">'float'</span>]</span><br></pre></td></tr></table></figure><p>  完整的类型列表通过下面的语句得到。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set(np.typeDict.values())</span><br><span class="line">---</span><br><span class="line">&#123;numpy.bool_, numpy.bytes_, numpy.complex128, numpy.complex128,</span><br><span class="line"> numpy.complex64, numpy.datetime64, numpy.float16, numpy.float32,</span><br><span class="line"> numpy.float64, numpy.float64, numpy.int16, numpy.int32,</span><br><span class="line"> numpy.int32, numpy.int64, numpy.int8, numpy.object_,</span><br><span class="line"> numpy.str_, numpy.timedelta64, numpy.uint16, numpy.uint32,</span><br><span class="line"> numpy.uint32, numpy.uint64, numpy.uint8, numpy.void&#125;</span><br></pre></td></tr></table></figure><p>  上面显示的数值类型与数组的 dtype 属性是不同的对象。通过 dtype 对象的 type 属性可以获得与其对应的数值类型:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.dtype.type</span><br><span class="line">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">int32</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>  下面创建一个 16 位($-2<sup>{15}\sim2</sup>{15}-1$)的符号整数对象，计算 $200<em>200$ 会溢出，得到一个负数 $200</em>200-2^{16}$ 。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.int16(<span class="hljs-number">200</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a*a</span><br><span class="line">__main__:<span class="hljs-number">1</span>: RuntimeWarning: overflow encountered <span class="hljs-keyword">in</span> short_scalars</span><br><span class="line"><span class="hljs-number">-25536</span></span><br></pre></td></tr></table></figure><p>  NumPy 的数值对象的运算速度比 Python 的内置类型的运算速度慢很多，如果程序中需要大量地对单个数值运算，应避免使用 NumPy 的数值对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v1 = <span class="hljs-number">3.14</span></span><br><span class="line">v2 = np.float64(v1)</span><br><span class="line">%timeit v1*v1</span><br><span class="line">%timeit v2*v2</span><br><span class="line">---</span><br><span class="line"><span class="hljs-number">85.1</span> ns ± <span class="hljs-number">4.1</span> ns per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10000000</span> loops each)</span><br><span class="line"><span class="hljs-number">159</span> ns ± <span class="hljs-number">10.3</span> ns per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10000000</span> loops each)</span><br></pre></td></tr></table></figure><p>  使用 astype() 方法可以对数组元素类型进行转换:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=np.float)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t2 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype=np.complex)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t3 = t1.astype(np.int32)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>t4 = t2.astype(np.complex64)</span><br></pre></td></tr></table></figure><h2 id="自动生成数组"><a class="header-anchor" href="#自动生成数组">¶</a>自动生成数组</h2><p>  前面的例子都是先创建一个 Python 的序列对象，然后通过array()将其转换为数组，这样做显然效率不高。因此NumPy 提供了很多专门用于创建数组的函数。</p><p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html" target="_blank" rel="noopener">arange()</a>类似于内置函数 range()，通过指定开始值、终值和步长来创建表示等差数列的一维数组。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>)</span><br><span class="line">array([<span class="hljs-number">0.</span> , <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>])</span><br></pre></td></tr></table></figure><p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html" target="_blank" rel="noopener">linspace()</a>通过指定开始值、终值和元素个数来创建表示等差数列的一维数组，可通过默认位 True 的 endpoint 参数指定是否包含终值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)</span><br><span class="line">array([<span class="hljs-number">0.</span>        , <span class="hljs-number">0.11111111</span>, <span class="hljs-number">0.22222222</span>, <span class="hljs-number">0.33333333</span>, <span class="hljs-number">0.44444444</span>,</span><br><span class="line">       <span class="hljs-number">0.55555556</span>, <span class="hljs-number">0.66666667</span>, <span class="hljs-number">0.77777778</span>, <span class="hljs-number">0.88888889</span>, <span class="hljs-number">1.</span>        ])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, endpoint=<span class="hljs-keyword">False</span>)</span><br><span class="line">array([<span class="hljs-number">0.</span> , <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>])</span><br></pre></td></tr></table></figure><p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.logspace.html" target="_blank" rel="noopener">logspace()</a>和 linspace()类似，不过创建的是等比数列。下面的例子为从 $10^0$ 到 $10^2$、有 5 个元素的等比数列。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.logspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>)</span><br><span class="line">array([  <span class="hljs-number">1.</span>        ,   <span class="hljs-number">3.16227766</span>,  <span class="hljs-number">10.</span>        ,  <span class="hljs-number">31.6227766</span> ,</span><br><span class="line">       <span class="hljs-number">100.</span>        ])</span><br></pre></td></tr></table></figure><p>  基数可以通过 base 参数指定，默认值为 10。下面创建一个比例为 $2^{1/12}$ 的等比数组，其比值为音乐中相差半音的两个音阶之间的频率比值，可用于计算一个八度中所有半音的频率。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.logspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, base=<span class="hljs-number">2</span>, endpoint=<span class="hljs-keyword">False</span>)</span><br><span class="line">array([<span class="hljs-number">1.</span>        , <span class="hljs-number">1.05946309</span>, <span class="hljs-number">1.12246205</span>, <span class="hljs-number">1.18920712</span>, <span class="hljs-number">1.25992105</span>,</span><br><span class="line">       <span class="hljs-number">1.33483985</span>, <span class="hljs-number">1.41421356</span>, <span class="hljs-number">1.49830708</span>, <span class="hljs-number">1.58740105</span>, <span class="hljs-number">1.68179283</span>,</span><br><span class="line">       <span class="hljs-number">1.78179744</span>, <span class="hljs-number">1.88774863</span>])</span><br></pre></td></tr></table></figure><p>  zeros()、ones()、empty()，eye()可以创建指定形状和类型的数组。其中empty()只分配数组所使用的内存，不对数组元素进行初始化操作，因此它的运行速度是最快的。zeros()将元素初始化为 0，ones()将数组元素初始化为 1。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.empty((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), np.int)</span><br><span class="line">array([[   <span class="hljs-number">4063294</span>,    <span class="hljs-number">2097214</span>, <span class="hljs-number">1469448192</span>],</span><br><span class="line">       [     <span class="hljs-number">32760</span>, <span class="hljs-number">1469454912</span>,      <span class="hljs-number">32760</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.zeros(<span class="hljs-number">4</span>, np.int)</span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])</span><br></pre></td></tr></table></figure><p>  full()将数组元素初始化为指定的值:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.full(<span class="hljs-number">4</span>, np.pi)</span><br><span class="line">array([<span class="hljs-number">3.14159265</span>, <span class="hljs-number">3.14159265</span>, <span class="hljs-number">3.14159265</span>, <span class="hljs-number">3.14159265</span>])</span><br></pre></td></tr></table></figure><p>  此外，zeros_like()、ones_like()、empty_like()等函数可创建与参数数组的形状及类型相同的数组。因此，zeros_like(a)和 zeros(a.shape, a.dtype)的效果相同。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">3</span>, dtype=float)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.zeros_like(a)</span><br><span class="line">array([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>])</span><br></pre></td></tr></table></figure><p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.frombuffer.html" target="_blank" rel="noopener">frombuffer()</a>、<a href="https://numpy.org/devdocs/reference/generated/numpy.fromstring.html" target="_blank" rel="noopener">fromstring()</a>、<a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html" target="_blank" rel="noopener">fromfile()</a>等函数可以从字节序列或文件创建数组，下面以 fromstring()为例介绍它们的用法。Python 的字符串实际上是一个字节序列，每个字符占一个字节，因此如果从字符串s 创建一个 8 位的整数数组，所得到的数组正好就是字符串中每个字符的 ASCII 编码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">"abcdefgh"</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.fromstring(s, dtype=np.int8)</span><br><span class="line">__main__:<span class="hljs-number">1</span>: DeprecationWarning: The binary mode of fromstring <span class="hljs-keyword">is</span> deprecated, <span class="hljs-keyword">as</span> it behaves surprisingly on unicode inputs. Use frombuffer instead</span><br><span class="line">array([ <span class="hljs-number">97</span>,  <span class="hljs-number">98</span>,  <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>], dtype=int8)</span><br></pre></td></tr></table></figure><p>  如果从字符串 s 创建 16 位的整数数组，那么两个相邻的字节就表示一个整数，把字节 98 和字节 97 当作一个16 位的整数，它的值就是$98*256+97=25185$。可以看出，16 位的整数是以低位字节在前(little-endian)的方式保存在内存中的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.fromstring(s, dtype=np.int16)</span><br><span class="line">array([<span class="hljs-number">25185</span>, <span class="hljs-number">25699</span>, <span class="hljs-number">26213</span>, <span class="hljs-number">26727</span>], dtype=int16)</span><br></pre></td></tr></table></figure><p>  <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html" target="_blank" rel="noopener">fromfunction()</a>通过函数创建数组，第一个参数为计算数组元素的函数，第二个参数为 shape。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.fromfunction(<span class="hljs-keyword">lambda</span> i: i % <span class="hljs-number">4</span> + <span class="hljs-number">1</span>, (<span class="hljs-number">10</span>,), dtype=int)</span><br><span class="line">array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], dtype=int32)</span><br></pre></td></tr></table></figure><h2 id="存取元素"><a class="header-anchor" href="#存取元素">¶</a>存取元素</h2><p>  NumPy 切片语法类似于 Python 列表的标准切片语法，即数组 x 切片获取方式：x[start:stop:step]，因此将数组颠倒即 x[::-1]。除了使用切片存取元素之外，NumPy 还提供了整数列表和布尔数组等下标存取方式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = x[[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">8</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="hljs-number">10</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure><p>  整数序列下标也可以用来修改元素的值：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]] = <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="hljs-number">10</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">-2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure><p>  当下标是多维数组时，得到的也是多维数组：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[np.array([[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">8</span>]])]</span><br><span class="line">array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">8</span>]].reshape(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>]])</span><br></pre></td></tr></table></figure><p>  下面是 bool 数组的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[np.array([<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>])]</span><br><span class="line">array([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[x &gt; <span class="hljs-number">5</span>]</span><br><span class="line">array([<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>])</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a class="header-anchor" href="#多维数组">¶</a>多维数组</h2><p>  多维数组与一维数组类似，NumPy 采用元组作为数组的下标。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">10</span>).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>) + np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],</span><br><span class="line">       [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>],</span><br><span class="line">       [<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>, <span class="hljs-number">35</span>],</span><br><span class="line">       [<span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>],</span><br><span class="line">       [<span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">54</span>, <span class="hljs-number">55</span>]])</span><br><span class="line">---</span><br><span class="line">a[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>]     a[<span class="hljs-number">4</span>:, <span class="hljs-number">4</span>:]        a[:, <span class="hljs-number">2</span>]                         a[<span class="hljs-number">2</span>::<span class="hljs-number">2</span>, ::<span class="hljs-number">2</span>]</span><br><span class="line">array([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) array([[<span class="hljs-number">44</span>, <span class="hljs-number">45</span>], array([ <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>, <span class="hljs-number">52</span>]) array([[<span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">24</span>],</span><br><span class="line">                     [<span class="hljs-number">54</span>, <span class="hljs-number">55</span>]])                                       [<span class="hljs-number">40</span>, <span class="hljs-number">42</span>, <span class="hljs-number">44</span>]])</span><br></pre></td></tr></table></figure><p>  如果下标元组中只包含整数和切片，那么得到的数组和原始数组共享数据，它是原数组的视图。下面的例子中，数组 b 是 a 的视图，它们共享数据，因此修改 b[0]时，数组 a 中对应的元素也被修改：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = a[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">0</span>] = -b[<span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">5</span>]</span><br><span class="line">array([<span class="hljs-number">-3</span>,  <span class="hljs-number">4</span>])</span><br></pre></td></tr></table></figure><p>  因为数组的下标是一个元组，所以我们可以将下标元组保存起来，用同一个元组存取多个数组。下面的例子中，a[idx]和 a[::2, 2:]相同，a[idx][idx]和 a[::2, 2:][::2, 2:]相同。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>idx = slice(<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-number">2</span>), slice(<span class="hljs-number">2</span>, <span class="hljs-keyword">None</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[idx]</span><br><span class="line">array([[ <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>],</span><br><span class="line">       [<span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[idx][idx]</span><br><span class="line">array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],</span><br><span class="line">       [<span class="hljs-number">44</span>, <span class="hljs-number">45</span>]])</span><br></pre></td></tr></table></figure><p>  用 Python 内置的 slice() 函数创建下标比较麻烦，因此 NumPy 提供了一个 s_对象来帮助我们创建数组下标，s_实际上是 IndexExpression 类的一个对象：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.s_[::<span class="hljs-number">2</span>, <span class="hljs-number">2</span>:]</span><br><span class="line">(slice(<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>, <span class="hljs-number">2</span>), slice(<span class="hljs-number">2</span>, <span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>))</span><br></pre></td></tr></table></figure><p>  在多维数组的下标元组中，也可以使用整数元组或列表、整数数组和布尔数组。当在下标中使用这些对象时，所获得的数据是原始数据的副本，因此修改结果数组不会改变原始数组。</p><p><img src="/Python/Python-NumPy/Python-NumPy1.jpg" alt></p><p>  当所有轴都用形状相同的整数数组作为下标时，得到的数组和下标数组的形状相同：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[x, y]</span><br><span class="line">array([[ <span class="hljs-number">5</span>, <span class="hljs-number">14</span>],</span><br><span class="line">       [<span class="hljs-number">23</span>, <span class="hljs-number">32</span>]])</span><br><span class="line"><span class="hljs-comment"># or</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>)].reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="结构数组"><a class="header-anchor" href="#结构数组">¶</a>结构数组</h2><p>  在C语言中可以通过 struct 关键字定义结构类型，结构中的字段占据连续的内存空间。类型相同的两个结构体所占用的内存大小相同，因此可以很容易定义结构数组。与C语言类似，NumPy 中也很容易对这种结构数组进行操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">persontype = np.dtype(&#123; <span class="hljs-comment">#1</span></span><br><span class="line">    <span class="hljs-string">'names'</span>:[<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'weight'</span>],</span><br><span class="line">    <span class="hljs-string">'formats'</span>:[<span class="hljs-string">'S32'</span>,<span class="hljs-string">'i'</span>, <span class="hljs-string">'f'</span>]&#125;, align=<span class="hljs-keyword">True</span>)</span><br><span class="line">a = np.array([(<span class="hljs-string">"Zhang"</span>, <span class="hljs-number">32</span>, <span class="hljs-number">75.5</span>), (<span class="hljs-string">"Wang"</span>, <span class="hljs-number">24</span>, <span class="hljs-number">65.2</span>)], <span class="hljs-comment">#2</span></span><br><span class="line">             dtype = persontype)</span><br></pre></td></tr></table></figure><p>  <strong>#1</strong> 先创建一个 dtype 对象 persontype，它的参数是一个描述结构类型的各个字段的字典。字典有两个键：‘names’和’formats’。每个键对应的值都是一个列表。'names’定义结构中每个字段的名称，而’formats’则定义每个字段的类型。这里使用类型字符串定义字段类型：</p><ul><li><code>'S32'</code> ：长度为32 字节的字符串类型，由于结构中每个元素的大小必须固定，因此需要指定字符串的长度。</li><li><code>'i'</code> ：32 bit 的整数类型，相当于 np.int32。</li><li><code>'f'</code> ：32 bit 的单精度浮点数类型，相当于 np.float32。</li></ul><p>  <strong>#2</strong> 然后调用array()创建数组，通过 dtype 参数指定所创建数组的元素类型为 persontype。数组a 的元素类型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'S32'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'weight'</span>, <span class="hljs-string">'&lt;f4'</span>)], align=<span class="hljs-keyword">True</span>)</span><br></pre></td></tr></table></figure><p>  因此还可以用多个元组的列表描述结构的类型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persontype = np.dtype([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'|S32'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'weight'</span>, <span class="hljs-string">'&lt;f4'</span>)])</span><br></pre></td></tr></table></figure><p>  类型字符串前面的’|’、’&lt;’、’&gt;'等字符表示字段值的字节顺序：</p><ul><li><code>|</code> ：忽视字节顺序</li><li><code>&lt;</code> ：低位字节在前，即小端模式(little endian)</li><li><code>&gt;</code> ：高位字节在前，即大端模式(big endian)</li></ul><p>  下面的例子是两种修改方式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = a[<span class="hljs-number">1</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c[<span class="hljs-string">"name"</span>] = <span class="hljs-string">"Li"</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>][<span class="hljs-string">"name"</span>]</span><br><span class="line"><span class="hljs-string">b'Li'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = a[<span class="hljs-string">"age"</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">0</span>] = <span class="hljs-number">40</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>][<span class="hljs-string">"age"</span>]</span><br><span class="line"><span class="hljs-number">40</span></span><br></pre></td></tr></table></figure><p>  通过 a.tostring() 或 a.tofile() 方法，可以将数组 a 以二进制的方式转换成字符串或写入文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.tofile(<span class="hljs-string">"test.bin"</span>)</span><br></pre></td></tr></table></figure><p>  在 IPyton 中运行以下程序读取 test.bin 中数据。%%file 为 IPython 的 <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="noopener">magic command</a>, 它将单元格中文本保存成文件read_struct_array.c</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%%file read_struct_array.c</span><br><span class="line"><span class="hljs-comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">struct person &#123;</span><br><span class="line">    char name[<span class="hljs-number">30</span>];</span><br><span class="line">    int age;</span><br><span class="line">    float weight;</span><br><span class="line">&#125;p[<span class="hljs-number">3</span>];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="hljs-string">"test.bin"</span>, <span class="hljs-string">"rb"</span>);</span><br><span class="line">    fread(p, sizeof(struct person), <span class="hljs-number">2</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;</span><br><span class="line">        printf(<span class="hljs-string">"%s %d %f\n"</span>, p[i].name, p[i].age, p[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在 IPython 中可以通过!执行系统命令</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!gcc read_struct_array.c -o read_struct_array.exe</span><br><span class="line">!read_struct_array.exe</span><br><span class="line">---</span><br><span class="line">Zhang <span class="hljs-number">40</span> <span class="hljs-number">75.500000</span></span><br><span class="line">Li <span class="hljs-number">24</span> <span class="hljs-number">65.199997</span></span><br></pre></td></tr></table></figure><p>  结构类型中可以包括其他的结构类型，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.dtype([(<span class="hljs-string">'f1'</span>, [(<span class="hljs-string">'f2'</span>, <span class="hljs-string">'&lt;i2'</span>)])])</span><br><span class="line">dtype([(<span class="hljs-string">'f1'</span>, [(<span class="hljs-string">'f2'</span>, <span class="hljs-string">'&lt;i2'</span>)])])</span><br></pre></td></tr></table></figure><p>  当某个字段的类型为数组时，用元组的第三个参数表示其形状：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.dtype([(<span class="hljs-string">'f0'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'f1'</span>, <span class="hljs-string">'&lt;f8'</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))])</span><br><span class="line">dtype([(<span class="hljs-string">'f0'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'f1'</span>, <span class="hljs-string">'&lt;f8'</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))])</span><br></pre></td></tr></table></figure><p>  用下面的字典参数也可以定义结构类型，字典的键为结构中的字段名，值为字段的类型描述，但是由于字典的键是没有顺序的，因此字段的顺序需要在类型描述中给出。类型描述是一个元组，它的第二个值给出字段的以字节为单位的偏移量。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.dtype(&#123;<span class="hljs-string">'name'</span>:(<span class="hljs-string">'S25'</span>, <span class="hljs-number">0</span>), <span class="hljs-string">'age'</span>:(np.uint8, <span class="hljs-number">25</span>)&#125;)</span><br><span class="line">dtype([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'S25'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'u1'</span>)])</span><br></pre></td></tr></table></figure><h1>ufunc 函数</h1><p>  ufunc 是一种能对数组每个元素进行运算的函数。NumPy 中许多函数都是由 C 语言编写，计算速度非常快。</p><h2 id="四则运算"><a class="header-anchor" href="#四则运算">¶</a>四则运算</h2><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">ufunc 函数</th></tr></thead><tbody><tr><td style="text-align:center">y=x1+x2</td><td style="text-align:center">add(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=x1-x2</td><td style="text-align:center">subtract(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=x1*x2</td><td style="text-align:center">multiply(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=x1/x2</td><td style="text-align:center">divide(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=x1/x2</td><td style="text-align:center">true_divide(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=x1//x2</td><td style="text-align:center">floor_divide(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=-x</td><td style="text-align:center">negative(x[,y])</td></tr><tr><td style="text-align:center">y=x1**x2</td><td style="text-align:center">power(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=x1%x2</td><td style="text-align:center">remainder(x1,x2[,y]), mod(x1,x2[,y])</td></tr></tbody></table><p>  一些例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x1 = np.arange(<span class="hljs-number">9.0</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x2 = np.arange(<span class="hljs-number">3.0</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.multiply(x1, x2)</span><br><span class="line">array([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">4.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">4.</span>, <span class="hljs-number">10.</span>],</span><br><span class="line">       [ <span class="hljs-number">0.</span>,  <span class="hljs-number">7.</span>, <span class="hljs-number">16.</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.divmod(np.arange(<span class="hljs-number">5</span>), <span class="hljs-number">3</span>)</span><br><span class="line">(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], dtype=int32), array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], dtype=int32))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.gcd(np.arange(<span class="hljs-number">6</span>), <span class="hljs-number">20</span>)</span><br><span class="line">array([<span class="hljs-number">20</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>])</span><br></pre></td></tr></table></figure><h2 id="比较运算和布尔运算"><a class="header-anchor" href="#比较运算和布尔运算">¶</a>比较运算和布尔运算</h2><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">ufunc 函数</th></tr></thead><tbody><tr><td style="text-align:center">y=(x1==x2)</td><td style="text-align:center">equal(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=(x1!=x2)</td><td style="text-align:center">not_equal(x1,x2[,y])</td></tr><tr><td style="text-align:center">y=(x1&lt;x2)</td><td style="text-align:center">less(x1,x2,[,y])</td></tr><tr><td style="text-align:center">y=(x1&lt;=x2)</td><td style="text-align:center">less_equal(x1,x2,[,y])</td></tr><tr><td style="text-align:center">y=(x1&gt;x2)</td><td style="text-align:center">greater(x1,x2,[,y])</td></tr><tr><td style="text-align:center">y=(x1&gt;=x2)</td><td style="text-align:center">greater_equal(x1,x2,[,y])</td></tr></tbody></table><p>  由于 Python 中的 bool 运算使用 and、or 和 not 等关键字，它们无法被重载，因此数组的 bool 运算只能通过相应的 ufunc 函数进行。这些函数名都以“logical_”开头，在 IPython 中使用自动补全找到它们：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.logical <span class="hljs-comment"># Press Tab</span></span><br><span class="line">np.logical_and np.logical_not np.logical_or np.logical_xor</span><br></pre></td></tr></table></figure><p>  位运算函数包括 bitwise_and、bitwise_or、bitwise_xor、invert、left_shift 和 right_shift。</p><p>  对整数 0，在 32 位符号整数中按位取反的结果是 0xFFFFFFFF，这个值表示 -1。而在 8 位无符号整数中结果为 0xFF，为 255。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>~ np.arange(<span class="hljs-number">5</span>)</span><br><span class="line">array([<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">-5</span>], dtype=int32)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>~ np.arange(<span class="hljs-number">5</span>, dtype=np.uint8)</span><br><span class="line">array([<span class="hljs-number">255</span>, <span class="hljs-number">254</span>, <span class="hljs-number">253</span>, <span class="hljs-number">252</span>, <span class="hljs-number">251</span>], dtype=uint8)</span><br></pre></td></tr></table></figure><p>  left_shift 例子如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.binary_repr(<span class="hljs-number">5</span>)</span><br><span class="line"><span class="hljs-string">'101'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.left_shift(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])</span><br><span class="line">array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>], dtype=int32)</span><br></pre></td></tr></table></figure><h2 id="自定义-ufunc-函数"><a class="header-anchor" href="#自定义-ufunc-函数">¶</a>自定义 ufunc 函数</h2><p><img src="/Python/Python-NumPy/Python-NumPy2.jpg" alt></p><p>  如图，我们用一个分段函数计算三角波上某点 y 坐标：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">triangle_wave</span><span class="hljs-params">(x, c, c0, hc)</span>:</span></span><br><span class="line">    x = x - int(x)</span><br><span class="line">    <span class="hljs-keyword">if</span> x &gt;= c: r = <span class="hljs-number">0.0</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> x &lt; c0: r = x / c0 * hc</span><br><span class="line">    <span class="hljs-keyword">else</span>: r = (c - x) / (c - c0) * hc</span><br><span class="line">    <span class="hljs-keyword">return</span> r</span><br></pre></td></tr></table></figure><p>  若考虑以下方法，每次都要用列表推导式调用函数，对于多维数组很麻烦</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>)</span><br><span class="line">y1 = np.array([triangle_wave(t, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1.0</span>) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> x])</span><br></pre></td></tr></table></figure><p>  通过 frompyfunc() 可以将计算单个值的函数转换为能对数组的每个元素进行计算的 ufunc 函数。它的格式为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frompyfunc(func, nin, nout)</span><br></pre></td></tr></table></figure><p>  其中：func 是计算单个元素的函数，nin 是 func 输入参数的个数，nout 是 func 返回值的个数。下面的例子使用 frompyfunc()将 triangle_wave 转换为一个 ufunc 函数对象 triangle_ufunc1：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>triangle_ufunc1 = np.frompyfunc(triangle_wave, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y2 = triangle_ufunc1(x, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1.0</span>)</span><br></pre></td></tr></table></figure><p>  值得注意的是，triangle_ufunc1()所返回数组的元素类型是 object，因此还需要再调用数组的 astype()方法以将其转换为双精度浮点数组：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y2.dtype   y2.astype(np.float).dtype</span><br><span class="line">dtype(<span class="hljs-string">'O'</span>) dtype(<span class="hljs-string">'float64'</span>)</span><br></pre></td></tr></table></figure><p>  使用 vectorize()可以实现和 frompyfunc()类似的功能，但它可以通过 otypes 参数指定返回数组的元素类型。otypes 参数可以是一个表示元素类型的字符串，也可以是一个类型列表，使用列表可以描述多个返回数组的元素类型。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>triangle_ufunc2 = np.vectorize(triangle_wave, otypes=[np.float])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y3 = triangle_ufunc2(x, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1.0</span>)</span><br></pre></td></tr></table></figure><p>  验证结果如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.all(y1 == y2) np.all(y2 == y3)</span><br><span class="line"><span class="hljs-keyword">True</span>             <span class="hljs-keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="广播-broadcasting"><a class="header-anchor" href="#广播-broadcasting">¶</a>广播 (Broadcasting)</h2><p>  当使用 ufunc 函数对两个数组进行计算时，ufunc 函数会对这两个数组的对应元素进行计算，因此要求这两个数组的形状相同。如果形状不同，会进行如下的广播处理：</p><ol><li>让所有输入数组都向其中维数最多的数组看齐，shape 属性中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的 shape 属性是输入数组的 shape 属性在各个轴上的最大值。</li><li>如果输入数组的某个轴长度为 1 或与输出数组对应轴的长度相同，这个数组就能够用来计算，否则出错。</li><li>当输入数组的某个轴长度为 1 时，沿着此轴运算时都用此轴上的第一组值。</li></ol><p>  我们举一个例子，先创建二维数组 a，形状为(6, 1)：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">10</span>).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)：</span><br><span class="line">a      a.shape</span><br><span class="line">[[ <span class="hljs-number">0</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">1</span>)</span><br><span class="line"> [<span class="hljs-number">10</span>],</span><br><span class="line"> [<span class="hljs-number">20</span>],</span><br><span class="line"> [<span class="hljs-number">30</span>],</span><br><span class="line"> [<span class="hljs-number">40</span>],</span><br><span class="line"> [<span class="hljs-number">50</span>]]</span><br></pre></td></tr></table></figure><p>  在创建一维数组 b，形状为(5,)：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)</span><br><span class="line">b               b.shape</span><br><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] (<span class="hljs-number">5</span>,)</span><br></pre></td></tr></table></figure><p>  计算 a 与 b 的和，得到一个加法表，它相当于计算两个数组中所有元素对的和，得到一个形状为(6, 5)的数组：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = a + b</span><br><span class="line">c                      c.shape</span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span><br><span class="line"> [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],</span><br><span class="line"> [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>],</span><br><span class="line"> [<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>],</span><br><span class="line"> [<span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>],</span><br><span class="line"> [<span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">54</span>]]</span><br></pre></td></tr></table></figure><p>  由于数组 a 和 b 的维数不同，根据规则 1，需要让数组 b 的 shape 属性向数组 a 对齐，于是将数组 b 的 shape 属性前面加 1，补齐为(1,5)，相当于做了如下计算：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b.shape = <span class="hljs-number">1</span>, <span class="hljs-number">5</span></span><br><span class="line">b                 b.shape</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]] (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)</span><br></pre></td></tr></table></figure><p>  做加法运算的两个输入数组的 shape 属性分别为(6,1)和(1,5)，根据规则 2，输出数组各个轴的长度为输入数组各个轴长度的最大值，可知输出数组的 shape 属性为(6,5)。</p><p>  由于数组 b 第 0 轴的长度为 1，而数组 a 第 0 轴的长度为 6，因此为了让它们在第 0 轴上能够相加，需要将数组 b 第 0 轴的长度扩展为 6，这相当于：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = b.repeat(<span class="hljs-number">6</span>, axis=<span class="hljs-number">0</span>)</span><br><span class="line">b                 b.shape</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure><p>  由于数组 a 第 1 轴的长度为 1，而数组 b 第 1 轴的长度为 5，因此为了让它们在第 1 轴上能够相加，需要将数组 a 第 1 轴的长度扩展为5，这相当于：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = a.repeat(<span class="hljs-number">5</span>, axis=<span class="hljs-number">1</span>)</span><br><span class="line">a                      a.shape</span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>], (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span><br><span class="line"> [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],</span><br><span class="line"> [<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],</span><br><span class="line"> [<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>],</span><br><span class="line"> [<span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>],</span><br><span class="line"> [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>]]</span><br></pre></td></tr></table></figure><p>  经过上述处理之后，数组 a 和 b 就可以按对应元素进行相加运算了。当然，在执行 a + b 运算时，NumPy 内部并不会真正将长度为 1 的轴用 repeat() 进行扩展，这样太浪费内存空间了。由于这种广播计算很常用，因此 NumPy 提供了快速产生能进行广播运算的数组的 ogrid 对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = np.ogrid[:<span class="hljs-number">5</span>, :<span class="hljs-number">5</span>]</span><br><span class="line">x     y</span><br><span class="line">[[<span class="hljs-number">0</span>], [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</span><br><span class="line"> [<span class="hljs-number">1</span>],</span><br><span class="line"> [<span class="hljs-number">2</span>],</span><br><span class="line"> [<span class="hljs-number">3</span>],</span><br><span class="line"> [<span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure><p>  mgrid 对象的用法和 ogrid 对象类似，但是它所返回的是进行广播之后的数组：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = np.mgrid[:<span class="hljs-number">5</span>, :<span class="hljs-number">5</span>]</span><br><span class="line">x                 y</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line"> [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]] [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</span><br></pre></td></tr></table></figure><p>  ogrid 切片下标有两种形式：</p><ul><li>开始值:结束值:步长，和 np.arange(开始值, 结束值, 步长)类似。</li><li>开始值:结束值:长度 j，当第三个参数为虚数时，它表示所返回数组的长度，其和<br>np.linspace(开始值, 结束值, 长度)类似。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = np.ogrid[:<span class="hljs-number">1</span>:<span class="hljs-number">4j</span>, :<span class="hljs-number">1</span>:<span class="hljs-number">3j</span>]</span><br><span class="line">x              y</span><br><span class="line">[[<span class="hljs-number">0.</span>        ], [[<span class="hljs-number">0.</span> , <span class="hljs-number">0.5</span>, <span class="hljs-number">1.</span> ]]</span><br><span class="line"> [<span class="hljs-number">0.33333333</span>],</span><br><span class="line"> [<span class="hljs-number">0.66666667</span>],</span><br><span class="line"> [<span class="hljs-number">1.</span>        ]]</span><br></pre></td></tr></table></figure><p>  利用 ogrid 的返回值，我们很容易计算二元函数在等间距网格上的值。下面是绘制三维曲面 $f(x,y)=xe<sup>{x</sup>2-y^2}$ 的部分程序：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = np.ogrid[<span class="hljs-number">-2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">20j</span>, <span class="hljs-number">-2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">20j</span>]</span><br><span class="line">z = x * np.exp(- x**<span class="hljs-number">2</span> - y**<span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/Python/Python-NumPy/Python-NumPy3.jpg" alt></p><p>  为了充分利用 ufunc 函数的广播功能，我们经常需要调整数组的形状，因此数组支持特殊的下标对象 None，它表示在 None 对应的位置创建一个长度为 1 的新轴，例如对于一维数组 a, a[None, :]和 a.reshape(1，-1)等效，而 a[:, None]和 a.reshape(-1，1)等效：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">4</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-keyword">None</span>, :]</span><br><span class="line">array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[:, <span class="hljs-keyword">None</span>]</span><br><span class="line">array([[<span class="hljs-number">0</span>],</span><br><span class="line">       [<span class="hljs-number">1</span>],</span><br><span class="line">       [<span class="hljs-number">2</span>],</span><br><span class="line">       [<span class="hljs-number">3</span>]])</span><br></pre></td></tr></table></figure><p>  因此可以实现广播运算：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>y = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-keyword">None</span>, :] + y[:, <span class="hljs-keyword">None</span>]</span><br><span class="line">array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">12</span>],</span><br><span class="line">       [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">13</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>]])</span><br></pre></td></tr></table></figure><p>  还可以使用 ix_()将两个一维数组转换成可广播的二维数组：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>gy, gx = np.ix_(y, x)</span><br><span class="line">gx                 gy     gx + gy</span><br><span class="line">[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">10</span>]] [[<span class="hljs-number">2</span>],  [[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">12</span>],</span><br><span class="line">                    [<span class="hljs-number">3</span>],   [ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">13</span>],</span><br><span class="line">                    [<span class="hljs-number">8</span>]]   [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>]]</span><br></pre></td></tr></table></figure><p>  注意数组 y 对应广播运算结果中的第 0 轴，而数组 x 与第 1 轴对应。ix_()的参数可以是 N 个一维数。</p><h2 id="ufunc-的方法"><a class="header-anchor" href="#ufunc-的方法">¶</a>ufunc 的方法</h2><p>  ufunc 函数对象本身还有一些方法，这些方法只对两个输入、一个输出的 ufunc 对象有效，其他的 ufunc 对象调用这些方法时会抛出 ValueError 异常。</p><p>  reduce()方法和 Python 的 reduce()函数类似，它沿着axis 参数指定的轴对数组进行操作，相当于将<code>&lt;op&gt;</code>运算符插入到沿 axis 轴的所有元素之间：<code>&lt;op&gt;.reduce(array, axis=0, dtype=None)</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>r1 = np.add.reduce([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>r2 = np.add.reduce([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], axis=<span class="hljs-number">1</span>)</span><br><span class="line">r1 r2</span><br><span class="line"><span class="hljs-number">6</span>  [ <span class="hljs-number">6</span>, <span class="hljs-number">15</span>]</span><br></pre></td></tr></table></figure><p>  accumulate()和 reduce()类似，只是它返回的数组和输入数组的形状相同，保存所有的中间计算结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a1 = np.add.accumulate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a2 = np.add.accumulate([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], axis=<span class="hljs-number">1</span>)</span><br><span class="line">a1        a2</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>] [[ <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>],</span><br><span class="line">           [ <span class="hljs-number">4</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">15</span>]]</span><br></pre></td></tr></table></figure><p>  reduceat()计算多组reduce()的结果，通过 indices 参数指定一系列的起始和终止位置。它的计算有些特别，参考下面例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>res = np.add.reduceat(a, indices=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>res</span><br><span class="line">array([ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure><p>  它按照如下计算得出：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> indices[i] &lt; indices[i+<span class="hljs-number">1</span>]:</span><br><span class="line">    res[i] = &lt;op&gt;.reduce(a[indices[i]:indices[i+<span class="hljs-number">1</span>]])</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    res[i] = a[indices[i]]</span><br></pre></td></tr></table></figure><p>  而最后一个元素则按照<code>&lt;op&gt;.reduce(a[indices[-1]:])</code>计算得出。</p><p>  在例子中，可以看出 res[::2]和 a 相等，而 res[1::2]和 np.add.accumulate(a) 相等。</p><p>  ufunc 函数的 outer()方法等同于：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.shape += (<span class="hljs-number">1</span>,)*b.ndim</span><br><span class="line">&lt;op&gt;(a, b)</span><br><span class="line">a = a.squeee()</span><br></pre></td></tr></table></figure><p>  其中 squeeze()方法剔除数组 a 中长度为 1 的轴，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.multiply.outer([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])</span><br><span class="line">array([[ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">       [ <span class="hljs-number">4</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">8</span>],</span><br><span class="line">       [ <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>],</span><br><span class="line">       [ <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>],</span><br><span class="line">       [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>]])</span><br></pre></td></tr></table></figure><p>  通过 outer()计算得到的结果是乘法表。</p><h1>多维数组的下标存取</h1><h2 id="下标对象"><a class="header-anchor" href="#下标对象">¶</a>下标对象</h2><p>  多维数组的下标应该是一个长度上与数组的维数相同的元组。如果下标元组的长度比数组的维数大，就会出错。如果小，就需要在下标元组的后面补“:”，使得它的长度与数组维数相同。</p><p>  如果下标对象不是元组，NumPy 会首先把它转换为元组。这种转换可能会和用户所希望的不一致。数组 a 是一个三维数组，下面的例子用二维列表 lidx 和一个二维数组 aidx 作为下标，得到的结果是不一样的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">3</span> * <span class="hljs-number">4</span> * <span class="hljs-number">5</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>lidx = [[<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>aidx = np.array(lidx)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[lidx]</span><br><span class="line">__main__:<span class="hljs-number">1</span>: FutureWarning: Using a non-tuple sequence <span class="hljs-keyword">for</span> multidimensional indexing <span class="hljs-keyword">is</span> deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted <span class="hljs-keyword">as</span> an array index, `arr[np.array(seq)]`, which will result either <span class="hljs-keyword">in</span> an error <span class="hljs-keyword">or</span> a different result.</span><br><span class="line">array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[aidx]</span><br><span class="line">array([[[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],</span><br><span class="line">         [ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],</span><br><span class="line">         [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>],</span><br><span class="line">         [<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       [[[<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>],</span><br><span class="line">         [<span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>],</span><br><span class="line">         [<span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>],</span><br><span class="line">         [<span class="hljs-number">35</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>, <span class="hljs-number">38</span>, <span class="hljs-number">39</span>]]]])</span><br></pre></td></tr></table></figure><p>  下标元组各个元素有如下几种类型：切片、整数、整数数组和布尔数组。如果元素不是这些类型，如列表或元组，就将其转换成整数数组。如果下标元组的所有元素都是切片和整数，那么用它作为下标得到的是原始数组的一个视图，即它和原始数组共享数据存储空间。</p><h2 id="整数数组作为下标"><a class="header-anchor" href="#整数数组作为下标">¶</a>整数数组作为下标</h2><p>  下面讨论下标元组中的元素由切片和整数数组构成的情况。假设整数数组有 $N_c$ 个，切片有 $N_s$ 个。$N_c+N_s$ 为数组的维数 $D$。首先这 $N_c$ 个整数数组必须满足广播条件，假设它们进行广播之后的维数为 $M$，形状为$(d_0,d_1,\cdots,d_{M-1})$。如果 $N_s$ 为0，即没有切片元素，那么下标得到的结果数组 $res$ 的形状和整数数组广播之后的形状相同。它的每个元素值可按照下面的公式得出：<br>$$res[i_0,i_1,\cdots,i_{M-1}]=X[ind_0[i_0,i_1,\cdots,i_{M-1}],\cdots,ind_{N_t-1}[i_0,i_1,\cdots,i_{M-1}]]$$</p><p>  其中 $ind0$ 到 $ind_{N_t-1}$ 为进行广播之后的整数数组。</p><blockquote><p>若只需沿着指定轴通过整数数组获取元素，可以使用<a href="https://numpy.org/doc/1.18/reference/generated/numpy.take.html" target="_blank" rel="noopener"><code>numpy.take()</code></a>函数，运算速度比整数数组下标略快，支持下标越界处理。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i0 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i1 = np.array([[[<span class="hljs-number">0</span>]], [[<span class="hljs-number">1</span>]]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i2 = np.array([[[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b = a[i0, i1, i2]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[[<span class="hljs-number">22</span>, <span class="hljs-number">43</span>, <span class="hljs-number">22</span>],</span><br><span class="line">        [ <span class="hljs-number">2</span>, <span class="hljs-number">23</span>,  <span class="hljs-number">2</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="hljs-number">27</span>, <span class="hljs-number">48</span>, <span class="hljs-number">27</span>],</span><br><span class="line">        [ <span class="hljs-number">7</span>, <span class="hljs-number">28</span>,  <span class="hljs-number">7</span>]]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b.shape</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure><p>  i0、i1、i2 三个整数数组的 shape 属性分别为(2,3)、(2,1,1)、(1,1,3)，根据广播规则，先在长度不足 3 的 shape 属性前面补 1，使它们的维数相同，广播之后的shape 属性为各个轴的最大值，即三个整数数组广播之后的 shape 属性为(2,2,3)。</p><p>  可以使用 broadcast_arrays()查看广播之后的数组：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ind0, ind1, ind2 = np.broadcast_arrays(i0, i1, i2)</span><br><span class="line">ind0                 ind1                 ind2</span><br><span class="line">array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],   array([[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],   array([[[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],</span><br><span class="line">        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]],          [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]],          [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],          [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],          [[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>],</span><br><span class="line">        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]])         [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]])         [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]])</span><br></pre></td></tr></table></figure><p>  对于数组 b 中的任意一个元素 b[i,j,k]，它是数组 a 中经过 ind0、ind1 和 ind2 进行下标转换之后的值：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>i, j, k = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>print(b[i, j, k], a[ind0[i, j, k], ind1[i, j, k], ind2[i, j, k]])</span><br><span class="line"><span class="hljs-number">28</span> <span class="hljs-number">28</span></span><br></pre></td></tr></table></figure><p>  下面考虑 $N_s$ 不为 0 的情况。当存在切片下标时，可以细分为两种情况：下标元组中的整数数组之间没有切片，即整数数组只有一个或者是连续的。这时结果数组的 shape 属性为：将原始数组的 shape 属性中整数数组所占据的部分替换为它们广播之后的 shape 属性。例如，假设原始数组 a 的 shape 属性为(3,4,5)，i0 和 i1 广播之后的形状为(2, 2, 3)，则 a[1:3, i0, i1]的形状为(2, 2, 2, 3)：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c = a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, i0, i1]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>c.shape</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure><p>  其中，数组 c 的 shape 属性中的第一个 2 是切片 “1:3” 的长度，后面的(2,2,3)则是 i0 和 i1 广播之后数组的形状。</p><p>  当下标元组中的整数数组不是连续的，结果数组的 shape 属性为整数数组广播之后的形状后面再加上切片元素对应的形状。例如，a[i0, :, i1]的 shape 属性为(2, 2, 3, 4)。其中(2, 2, 3)是 i0 和 i1 广播之后的形状，而 4 是数组 a 第 1 轴的长度：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>d = a[i0, :, i1]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>d.shape</span><br><span class="line">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="布尔数组作为下标"><a class="header-anchor" href="#布尔数组作为下标">¶</a>布尔数组作为下标</h2><p>  当使用布尔数组直接作为下标对象或者元组下标对象中有布尔数组时，都相当于用 nonzero()将布尔数组转换成一组整数数组，然后使用整数数组进行下标运算。</p><p>  nonzeros(a)返回数组 a 中值不为零的元素的下标，它的返回值是一个长度为 a.ndim(数组 a 的轴数)的元组，元组的每个元素都是一个整数数组，其值为非零元素的下标在对应轴上的值。对于一维布尔数组b1，nonzero(b1)得到的是一个长度为 1 的元组:</p><blockquote><p>若只需沿着指定轴通过整数数组获取元素，可以使用<a href="https://numpy.org/doc/1.18/reference/generated/numpy.compress.html" target="_blank" rel="noopener"><code>numpy.compress()</code></a>函数。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b1 = np.array([<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.nonzero(b1)</span><br><span class="line">(array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], dtype=int64),)</span><br></pre></td></tr></table></figure><p>  对于二维数组 b2，nonzero(b2)得到的是一个长度为 2 的元组。它的第 0 个元素是数组 a 中值不为 0 的元素的第 0 轴的下标，第 1 个元素则是第 1 轴的下标，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>b2 = np.array([[<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>], [<span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">False</span>]])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>np.nonzero(b2)</span><br><span class="line">(array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], dtype=int64), array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>], dtype=int64))</span><br></pre></td></tr></table></figure><h1>庞大的函数库</h1><h2 id="随机数"><a class="header-anchor" href="#随机数">¶</a><a href="https://numpy.org/doc/stable/reference/random/index.html" target="_blank" rel="noopener">随机数</a></h2><ul><li><a href="https://numpy.org/doc/stable/reference/random/generator.html" target="_blank" rel="noopener">Random Generator</a></li><li><a href="https://numpy.org/doc/stable/reference/random/legacy.html" target="_blank" rel="noopener">Legacy Generator (RandomState)</a></li></ul><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">功能</th><th style="text-align:center">函数名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">rand</td><td style="text-align:center">0到1之间的随机数</td><td style="text-align:center">randn</td><td style="text-align:center">标准正态分布的随机数</td></tr><tr><td style="text-align:center">randint</td><td style="text-align:center">指定范围内随机整数</td><td style="text-align:center">normal</td><td style="text-align:center">正态分布</td></tr><tr><td style="text-align:center">uniform</td><td style="text-align:center">均匀分布</td><td style="text-align:center">poisson</td><td style="text-align:center">泊松分布</td></tr><tr><td style="text-align:center">permutation</td><td style="text-align:center">随机排列</td><td style="text-align:center">shuffle</td><td style="text-align:center">随机打乱顺序</td></tr><tr><td style="text-align:center">choice</td><td style="text-align:center">随机抽取样本</td><td style="text-align:center">seed</td><td style="text-align:center">设置随机数种子</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树学习</title>
      <link href="/Algorithm/Learing-Segment-Tree/"/>
      <url>/Algorithm/Learing-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<h1>基础</h1><h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2><p>  线段树(<a href="https://en.wikipedia.org/wiki/Segment_tree" target="_blank" rel="noopener">Segment tree</a>)是基于分治的二叉树，用于在区间上进行信息统计。线段树每个节点都代表一个区间，每个叶节点代表长度为1的区间，每个内部节点$[l,r]$，左子节点$[l,mid]$，右子节点$[mid+1,r]$，其中$mid=\lfloor\frac{l+r}{2}\rfloor$。</p><p>  除去树的最后一层，整棵线段树一定是一颗完全二叉树，树的深度为$O(\log{N})$。我们将根节点编号为$1$，编号为$x$的节点左子节点为$x<em>2$，右子节点编号为$x</em>2+1$。$N$个叶节点的满二叉树有$1+2+\cdots+\frac{N}{2}+N=2N-1$个节点，而最后一层有空余，故保存线段树数组长度不小于$4N$。</p><p>  以区间最大值为例</p><ul><li>建树</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> l, r;</span><br><span class="line">    <span class="hljs-keyword">int</span> dat;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="hljs-number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123; t[p].dat = a[l]; <span class="hljs-keyword">return</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>, l, mid);</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">    t[p].dat = max(t[p&lt;&lt;<span class="hljs-number">1</span>].dat, t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单点修改</li></ul><p>  从根节点出发，递归找到区间$[x,x]$的节点，从下往上更新$[x,x]$及所有父节点的信息，复杂度$O(\log{N})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (t[p].l == t[p].r) &#123; t[p].dat = v; <span class="hljs-keyword">return</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x &lt;= mid) update(p&lt;&lt;<span class="hljs-number">1</span>, x, v);</span><br><span class="line">    <span class="hljs-keyword">else</span> update(p&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);</span><br><span class="line">    t[p].dat = max(t[p&lt;&lt;<span class="hljs-number">1</span>].dat, t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间查询</li></ul><ol><li>若$[l,r]$完全覆盖当前节点区间，立即回溯，该节点$dat$为候选答案。</li><li>若左子节点与$[l,r]$有重叠，递归访问左子节点。</li><li>若右子节点与$[l,r]$有重叠，递归访问右子节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="hljs-keyword">return</span> t[p].dat;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = -INF;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt;= mid) ans = max(ans, query(p&lt;&lt;<span class="hljs-number">1</span>, l, r));</span><br><span class="line">    <span class="hljs-keyword">if</span> (r &gt; mid) ans = max(ans, query(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r));</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>延迟标记(lazy-tag)</li></ul><p>  一般用于处理线段树的区间更新，如果某个节点被修改区间$[l,r]$完全覆盖，以该节点为根的子树所有节点信息会发生变化，若逐一更新，一次区间修改时间复杂度为$O(N)$，为了提高效率，每次更新只更新到更新区间完全覆盖线段树节点区间为止，在被更新节点打上标记，下次访问节点再将标记传给子节点。</p><p>  什么时候用？统计量可合并、修改量可合并、通过修改量可直接修改统计量，即满⾜区间加法即可使用线段树维护信息。</p><hr><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">P3372 线段树1</a></p><p><a href="https://paste.ubuntu.com/p/dp6XmZdkqs/" target="_blank" rel="noopener">参考代码</a></p><hr><p><a href="https://www.luogu.com.cn/problem/P3373" target="_blank" rel="noopener">P3373 线段树2</a></p><p>  本题有两种修改、一种查询取模后的结果共三种操作，向下传递lazy-tag时需考虑先后顺序，如果先加后乘则会有小数运算损失精度，所以先乘后加。</p><p><a href="https://paste.ubuntu.com/p/nYWWrvcqws/" target="_blank" rel="noopener">参考代码</a></p><h2 id="经典应用"><a class="header-anchor" href="#经典应用">¶</a>经典应用</h2><h3 id="区间最值"><a class="header-anchor" href="#区间最值">¶</a>区间最值</h3><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1067" target="_blank" rel="noopener">bzoj1067 [SCOI2007]降雨量</a></p><blockquote><p>题意：给出$n(1\le n\le50000)$条信息，第$y_i(-10^9\le y_i\le10<sup>9)$年降雨量为$r_i(-10</sup>9\le r_i\le10^9)$，给出$m(1\le m\le10000)$条询问，格式$Y$和$X$，$X$年是自$Y$年以来降雨量最多的。这句话是真、假或有可能。</p></blockquote><p>  难点主要在分类讨论。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> l, r;</span><br><span class="line">    <span class="hljs-keyword">int</span> dat;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="hljs-number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> y[N], a[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123; t[p].dat = a[l]; <span class="hljs-keyword">return</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>, l, mid);</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">    t[p].dat = max(t[p&lt;&lt;<span class="hljs-number">1</span>].dat, t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) <span class="hljs-keyword">return</span> t[p].dat;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = -INF;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt;= mid) ans = max(ans, query(p&lt;&lt;<span class="hljs-number">1</span>, l, r));</span><br><span class="line">    <span class="hljs-keyword">if</span> (r &gt; mid) ans = max(ans, query(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r));</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;y[i], &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> p, q;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;p, &amp;q);</span><br><span class="line">        <span class="hljs-keyword">if</span> (q &lt; p) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">"false"</span>); <span class="hljs-keyword">continue</span>; &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> l = lower_bound(y + <span class="hljs-number">1</span>, y + n + <span class="hljs-number">1</span>, p) - y;</span><br><span class="line">        <span class="hljs-keyword">int</span> r = lower_bound(y + <span class="hljs-number">1</span>, y + n + <span class="hljs-number">1</span>, q) - y;</span><br><span class="line">        <span class="hljs-keyword">if</span> (y[l] == p &amp;&amp; y[r] == q) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (a[l] &lt; a[r] || query(<span class="hljs-number">1</span>, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>) &gt;= a[r]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"false"</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q - p == r - l) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"true"</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"maybe"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y[l] != p &amp;&amp; y[r] != q) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"maybe"</span>);</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y[r] != q) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (query(<span class="hljs-number">1</span>, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>) &gt;= a[l]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"false"</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"maybe"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (query(<span class="hljs-number">1</span>, l, r - <span class="hljs-number">1</span>) &gt;= a[r]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"false"</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"maybe"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间求和"><a class="header-anchor" href="#区间求和">¶</a>区间求和</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4288" target="_blank" rel="noopener">hdu4288 Coder</a></p><blockquote><p>题意：有3种操作（1）add x:向序列添加x，添加后仍然有序；（2）del x:删除序列中值为x的元素；（3）sum:求下标模5为3的元素和。</p></blockquote><p>  由于线段树不支持添加删除，采用离线做法。先离散化数组，用$sum$数组记录模5的5种情况和，从而添加或删除一个元素时对$sum[1]$修改，$cnt$表示线段树某节点区间数的个数，右子节点下标$i$在父节点对应下标$i+lson.cnt$，那么父节点$sum[i]$等于左子节点$sum[i]$加上右子节点$sum[(i+lson.cnt)%5]$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> l, r, cnt;</span><br><span class="line">    ll sum[<span class="hljs-number">5</span>];</span><br><span class="line">&#125;t[N&lt;&lt;<span class="hljs-number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> q[N];</span><br><span class="line"><span class="hljs-keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    t[p].cnt = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(t[p].sum, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(t[p].sum));</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123; <span class="hljs-keyword">return</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>, l, mid);</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)</span><br><span class="line">        t[p].sum[i] = t[p&lt;&lt;<span class="hljs-number">1</span>].sum[i] + t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum[((i-t[p&lt;&lt;<span class="hljs-number">1</span>].cnt)%<span class="hljs-number">5</span>+<span class="hljs-number">5</span>)%<span class="hljs-number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    t[p].cnt += y;</span><br><span class="line">    <span class="hljs-keyword">if</span> (t[p].l == t[p].r) &#123;</span><br><span class="line">        t[p].sum[<span class="hljs-number">1</span>] += y * b[x];</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x &lt;= mid) update(p&lt;&lt;<span class="hljs-number">1</span>, x, y);</span><br><span class="line">    <span class="hljs-keyword">else</span> update(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, x, y);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n;</span><br><span class="line">    <span class="hljs-keyword">char</span> op[<span class="hljs-number">5</span>];</span><br><span class="line">    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, op);</span><br><span class="line">            q[i] = op[<span class="hljs-number">0</span>];</span><br><span class="line">            <span class="hljs-keyword">if</span> (q[i] != <span class="hljs-string">'s'</span>) &#123;</span><br><span class="line">                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">                b[++num] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b + <span class="hljs-number">1</span>, b + num + <span class="hljs-number">1</span>);</span><br><span class="line">        num = unique(b + <span class="hljs-number">1</span>, b + num + <span class="hljs-number">1</span>) - b - <span class="hljs-number">1</span>;</span><br><span class="line">        build(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> pos = lower_bound(b + <span class="hljs-number">1</span>, b + num + <span class="hljs-number">1</span>, a[i]) - b;</span><br><span class="line">            <span class="hljs-keyword">if</span> (q[i] == <span class="hljs-string">'s'</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, t[<span class="hljs-number">1</span>].sum[<span class="hljs-number">3</span>]);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q[i] == <span class="hljs-string">'a'</span>) update(<span class="hljs-number">1</span>, pos, <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> update(<span class="hljs-number">1</span>, pos, <span class="hljs-number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="http://poj.org/problem?id=3225" target="_blank" rel="noopener">poj3225 Help with Intervals</a></p><blockquote><p>题意：给定初始集合为$\varnothing$，给出一系列（$0\sim65535$条）并(U)、交(I)、减(D)、被减©、异或(S)一个区间（区间$[0,65535]$的子区间）命令，输出执行命令后的集合。</p></blockquote><p>  建立线段树，区间包括的为1，不包括的为0。将区间扩大为两倍，线段数中偶数存点，奇数存线段，即0号表示$[0,0]$，1号表示$(0,1)$，2号表示$[1,1]$，3号表示$(1,2)\cdots$。那么</p><p>  U:区间$[l,r]$置1</p><p>  I:区间$[-\infty,l)(r,\infty]$置0</p><p>  D:区间$[l,r]$置0</p><p>  C:区间$[-\infty,l)(r,\infty]$置0，区间$[l,r]$翻转$0/1$</p><p>  S:区间$[l,r]$翻转$0/1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">65536</span> * <span class="hljs-number">2</span>, INF = <span class="hljs-number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> l, r;</span><br><span class="line">    <span class="hljs-keyword">int</span> flip, dat;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="hljs-number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> id[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[p].l = l, t[p].r = r;</span><br><span class="line">    t[p].flip = <span class="hljs-number">0</span>, t[p].dat = <span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123; id[l] = p; <span class="hljs-keyword">return</span>; &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>, l, mid);</span><br><span class="line">    build(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (t[p].dat != <span class="hljs-number">-1</span>) &#123;</span><br><span class="line">        t[p&lt;&lt;<span class="hljs-number">1</span>].dat = t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].dat = t[p].dat;</span><br><span class="line">        t[p&lt;&lt;<span class="hljs-number">1</span>].flip = t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].flip = <span class="hljs-number">0</span>;</span><br><span class="line">        t[p].dat = <span class="hljs-number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (t[p].flip) &#123;</span><br><span class="line">        t[p&lt;&lt;<span class="hljs-number">1</span>].flip ^= <span class="hljs-number">1</span>;</span><br><span class="line">        t[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].flip ^= <span class="hljs-number">1</span>;</span><br><span class="line">        t[p].flip = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (v != <span class="hljs-number">-1</span>) &#123;</span><br><span class="line">            t[p].dat = v;</span><br><span class="line">            t[p].flip = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> t[p].flip ^= <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p);</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt;= mid) update(p&lt;&lt;<span class="hljs-number">1</span>, l, r, v);</span><br><span class="line">    <span class="hljs-keyword">if</span> (r &gt; mid) update(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (t[p].l == t[p].r) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (t[p].dat == <span class="hljs-number">-1</span>) t[p].dat = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p);</span><br><span class="line">    query(p&lt;&lt;<span class="hljs-number">1</span>);</span><br><span class="line">    query(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> op, a, b;</span><br><span class="line">    <span class="hljs-keyword">int</span> l, r;</span><br><span class="line">    build(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, N);</span><br><span class="line">    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c %c%d,%d%c\n"</span>, &amp;op, &amp;a, &amp;l, &amp;r, &amp;b)) &#123;</span><br><span class="line">        l = (l&lt;&lt;<span class="hljs-number">1</span>) + (a == <span class="hljs-string">'('</span>);</span><br><span class="line">        r = (r&lt;&lt;<span class="hljs-number">1</span>) - (b == <span class="hljs-string">')'</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'U'</span>) update(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'I'</span>) &#123;</span><br><span class="line">            update(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, l - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line">            update(<span class="hljs-number">1</span>, r + <span class="hljs-number">1</span>, N, <span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'D'</span>) update(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">'C'</span>) &#123;</span><br><span class="line">            update(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, l - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line">            update(<span class="hljs-number">1</span>, r + <span class="hljs-number">1</span>, N, <span class="hljs-number">0</span>);</span><br><span class="line">            update(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> update(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    query(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> pre, flag = <span class="hljs-number">0</span>, ok = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> p = id[i];</span><br><span class="line">        <span class="hljs-keyword">int</span> tmp = t[p].dat ^ t[p].flip;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!tmp &amp;&amp; flag) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (ok) <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> ok = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (pre &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"("</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"["</span>);</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d,%d"</span>, pre / <span class="hljs-number">2</span>, i / <span class="hljs-number">2</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">")"</span>);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"]"</span>);</span><br><span class="line">            flag = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &amp;&amp; !flag) &#123;</span><br><span class="line">            pre = i;</span><br><span class="line">            flag = <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!ok) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"empty set"</span>);</span><br><span class="line">    <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构-线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳舞链</title>
      <link href="/Algorithm/Dancing-Links/"/>
      <url>/Algorithm/Dancing-Links/</url>
      
        <content type="html"><![CDATA[<h1>精确覆盖问题<a href="https://en.wikipedia.org/wiki/Exact_cover" target="_blank" rel="noopener">(Exact Cover)</a></h1><p>  定义:给定一个$R\times C$的$0,1$矩阵，问是否存在一个行集合，使得集合每一列<strong>恰好</strong>有一个$1$。</p><p>![](Dancing Links/fig1.jpg)</p><ul><li>穷举法</li></ul><p>  每一行都有选与不选两种状态，枚举行的时间复杂度为$O(2^R)$，每次选行时需要遍历之前已选行的所有列以检查是否有冲突，检查需要的时间复杂度为$O(RC)$，因此总的复杂度为$O(RC\times 2^R)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N][N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ok = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> state = <span class="hljs-number">1</span>; state &lt; <span class="hljs-number">1</span> &lt;&lt; n; ++state) &#123;</span><br><span class="line">        <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));</span><br><span class="line">        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-keyword">if</span> (flag &amp;&amp; ((<span class="hljs-number">1</span> &lt;&lt; i - <span class="hljs-number">1</span>) &amp; state))</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (v[j]) &#123; flag = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; &#125;</span><br><span class="line">                    <span class="hljs-keyword">else</span> v[j] = <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) <span class="hljs-keyword">if</span> (!v[i]) flag = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            ok = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; i - <span class="hljs-number">1</span>) &amp; state) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, i);</span><br><span class="line">            <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!ok) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No Solution!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>状态压缩</li></ul><p>  把每一行看作一个$C$位二进制数，问题转化为在$R$个$C$位二进制数中, 选择数使得 (1)任意两个数的与为0；(2)所有数的或为$2^C-1$；令$tmp$表示当前所有被选择了的$C$位二进制数的或。时间复杂度$O(R\times 2^R)$</p><p>![](Dancing Linkss/fig2.jpg)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N][N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ok = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= <span class="hljs-number">1</span>; --j)</span><br><span class="line">            num[i] = num[i] &lt;&lt; <span class="hljs-number">1</span> | a[i][j];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> state = <span class="hljs-number">1</span>; state &lt; <span class="hljs-number">1</span> &lt;&lt; n; ++state) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; i - <span class="hljs-number">1</span>) &amp; state) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(tmp &amp; num[i]) <span class="hljs-keyword">break</span>;</span><br><span class="line">            tmp |= num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(tmp == (<span class="hljs-number">1</span> &lt;&lt; m) - <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            ok = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; i - <span class="hljs-number">1</span>) &amp; state)</span><br><span class="line">                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, i);</span><br><span class="line">            <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(!ok) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No Solution!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Dancing Links(<a href="https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X" target="_blank" rel="noopener">Algorithm X</a>)</h1><p>红色的框代表选中的行，蓝色的框代表删除的列，绿色的框代表删除的行</p><p>![](Dancing Links/fig3.jpg)</p><p><a href="https://www.youtube.com/watch?v=R9gRLnddOBg" target="_blank" rel="noopener">Dancing Links(2000)</a></p><p><a href="https://www.youtube.com/watch?v=_cR9zDlvP88" target="_blank" rel="noopener">Dancing Links(2018)</a></p><p>  算法大师Donald Knuth提出了“X算法”，Dancing Links翻译成舞蹈链，并不是算法本身，而是一种链式的数据结构，利用<strong>十字链表</strong>缓存和回溯矩阵，不需要额外开辟空间。</p><p><a href="https://www.luogu.com.cn/problem/P4929" target="_blank" rel="noopener">【模板】舞蹈链（DLX）</a></p><p>这里给出我个人的板子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLX</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> n, m, cnt;</span><br><span class="line">    <span class="hljs-keyword">int</span> l[maxnode], r[maxnode], u[maxnode], d[maxnode], row[maxnode], col[maxnode];</span><br><span class="line">    <span class="hljs-keyword">int</span> h[maxn], s[maxm];</span><br><span class="line">    <span class="hljs-keyword">int</span> ansd, ans[maxn];</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _n, <span class="hljs-keyword">int</span> _m)</span> </span>&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            l[i] = i - <span class="hljs-number">1</span>;</span><br><span class="line">            r[i] = i + <span class="hljs-number">1</span>;</span><br><span class="line">            u[i] = d[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        r[m] = <span class="hljs-number">0</span>; l[<span class="hljs-number">0</span>] = m;</span><br><span class="line">        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(h));</span><br><span class="line">        <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));</span><br><span class="line">        cnt = m + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        s[C]++;</span><br><span class="line">        row[cnt] = R, col[cnt] = C;</span><br><span class="line">        u[cnt] = C;</span><br><span class="line">        d[cnt] = d[C];</span><br><span class="line">        u[d[C]] = cnt;</span><br><span class="line">        d[C] = cnt;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h[R] == <span class="hljs-number">-1</span>) h[R] = l[cnt] = r[cnt] = cnt;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            r[cnt] = h[R];</span><br><span class="line">            l[cnt] = l[h[R]];</span><br><span class="line">            r[l[h[R]]] = cnt;</span><br><span class="line">            l[h[R]] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        l[r[C]] = l[C], r[l[C]] = r[C];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d[C]; i != C; i = d[i])</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = r[i]; j != i; j = r[j]) &#123;</span><br><span class="line">                u[d[j]] = u[j];</span><br><span class="line">                d[u[j]] = d[j];</span><br><span class="line">                s[col[j]]--;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">(<span class="hljs-keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = u[C]; i != C; i = u[i])</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l[i]; j != i; j = l[j]) &#123;</span><br><span class="line">                u[d[j]] = j;</span><br><span class="line">                d[u[j]] = j;</span><br><span class="line">                s[col[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        l[r[C]] = r[l[C]] = C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> deep)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!r[<span class="hljs-number">0</span>]) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; deep; ++i) str[(ans[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">9</span>] = <span class="hljs-string">'1'</span> + (ans[i] - <span class="hljs-number">1</span>) % <span class="hljs-number">9</span>;</span><br><span class="line">            <span class="hljs-built_in">puts</span>(str);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> c = r[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">0</span>; i = r[i]) <span class="hljs-keyword">if</span> (s[i] &lt; s[c]) c = i;</span><br><span class="line">        remove(c);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d[c]; i != c; i = d[i]) &#123;</span><br><span class="line">            ans[deep] = row[i];</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = r[i]; j != i; j = r[j]) remove(col[j]);</span><br><span class="line">            <span class="hljs-keyword">if</span> (dance(deep + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l[i]; j != i; j = l[j]) resume(col[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        resume(c);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dlx;</span><br></pre></td></tr></table></figure><h1>精确覆盖的应用</h1><p>  求解实际问题时，应考虑行与列的意义，即行表示<strong>决策</strong>，列表示<strong>状态</strong>。</p><h2 id="n皇后问题"><a class="header-anchor" href="#n皇后问题">¶</a>N皇后问题</h2><p><a href="https://vjudge.net/problem/SPOJ-NQUEEN" target="_blank" rel="noopener">SPOJ 1771</a></p><p>在一个N×N的棋盘上放置N个皇后(N &lt;= 50)，使得任何两个皇后之间不相互攻击（即同一行、同一列、同一对角线不能有大于1个皇后）。求一种摆放方案。</p><p>  每个皇后能放置的位置共有$N<sup>2$种，即有$N</sup>2$行。列有$4$种约束条件：</p><ol><li>$[1,N]$表示棋盘N行的占据情况</li><li>$[N+1,2N]$表示棋盘N列的占据情况</li><li>$[2N+1,4N-1]$表示棋盘2N-1条主对角线的占据情况</li><li>$[4N,6N-2]$表示棋盘2N-1条副对角线的占据情况</li></ol><p>故共有$6N-2$列。</p><div style="width: 400px; margin: auto">![](Dancing Links/queen.jpg)</div><p>  对于$(i,j)$的位置，占据的行为$i$；占据的列为$j$；主对角线可以通过$i$和$j$的相对情况来判断，所有$i-j$相同的占据的主对角线为$N+i-j$；副对角线类似，所有$i+j$相同的位置占据的副对角线为$i+j-1$；</p><p>  然而，N皇后问题不能直接求精确覆盖，这是因为行和列必须完全覆盖到，但是主和副对角线没有要求一定要全部覆盖，所以算法走到N步停止, 每次消除代表着行或者列的那些列的1, 而不是优先考虑对角线。</p><p><a href="https://paste.ubuntu.com/p/NHwtvcKpqn/" target="_blank" rel="noopener">代码</a></p><h2 id="数独问题"><a class="header-anchor" href="#数独问题">¶</a>数独问题</h2><ol><li><a href="http://poj.org/problem?id=3074" target="_blank" rel="noopener">POJ3074 Sudoku</a></li></ol><ul><li>$DFS$</li></ul><p>  现实生活中，我们玩数独的策略是先填能唯一确定的位置，然后从选项少的位置突破。从而有我们的搜索策略：在每个状态下，从所有未填位置里选择能填合法数字最少的位置，考虑该位置填什么数，作为搜索的分支。考虑以下优化：(1)每行、列、宫用一个9位二进制数保存，当一个位置填上数后，将对应行、列、宫变为0更新状态，回溯时改为1；(2)对每个位置，将所在行、列、宫的数进行与运算得到还能填哪些数，并用$lowbit$取出；</p><p><a href="https://paste.ubuntu.com/p/q2wK48rR2w/" target="_blank" rel="noopener">代码</a></p><ul><li>$DLX$</li></ul><p>  每一个决策可由三元组$(r,c,w)$表示，这是因为每个宫可由$(r,c)$确定，故共有$9<em>9</em>9$行。其次，每个决策有四个影响(1)$(r,c)$填了一个数字；(2)第$r$行用了一个$w$；(3)第$c$列用了一个$w$；(4)第$a$宫用了一个$w$。共$9<em>9</em>4$列。</p><ol><li>$[1, 81]$列，分别对应了81个格子是否被放置了数字。</li><li>$[82, 2*81]$列，分别对应了9行，每行[1, 9]个数字的放置情况。</li><li>$[2<em>81+1, 3</em>81]$列，分别对应了9列，每列[1, 9]个数字的放置情况。</li><li>$[3<em>81+1, 4</em>81]$列，分别对应了9个“宫”，每“宫”[1, 9]个数字的放置情况。</li></ol><p><a href="https://paste.ubuntu.com/p/KN4zkt26F7/" target="_blank" rel="noopener">代码</a></p><ol start="2"><li><a href="https://www.luogu.com.cn/problem/P1074" target="_blank" rel="noopener">noip2009-靶形数独</a></li></ol><p>  与上题类似，只需添加一个权值数组，并更新答案，此时将<code>bool dance(int deep)</code>中改为<code>void</code>型，否则会返回搜到的第一组解而无法更新答案。</p><p><a href="https://paste.ubuntu.com/p/Hsn5DWdvzZ/" target="_blank" rel="noopener">代码</a></p><h1>重复覆盖</h1><p>  定义:给定一个$R\times C$的$0,1$矩阵，问是否存在一个行集合，使得集合每一列<strong>至少</strong>有一个$1$。</p><p>  精确覆盖是重复覆盖的特殊情况，参照精确覆盖的算法构建跳舞链，对行进行枚举，不同的是，我们仅删除该行上有“1”的列，但不再删除列对应的行。为了满足搜索的行数最小，我们引入<b>迭代加深(IDA*)</b>。</p><ul><li><p>迭代加深：枚举一个最大深度，然后对问题进行搜索，搜索过程记录当前深度，如果当前深度大于最大深度则无条件返回。</p></li><li><p>启发式函数：设计一个估价函数$f(\ )$，函数返回的是至少还需要多少行才能完成重复覆盖。实际值 &gt; 估计值$f(\ )&gt;K$</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLX</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> n, m, cnt;</span><br><span class="line">    <span class="hljs-keyword">int</span> l[mx], r[mx], u[mx], d[mx], row[mx], col[mx];</span><br><span class="line">    <span class="hljs-keyword">int</span> h[maxn], s[maxm];</span><br><span class="line">    <span class="hljs-keyword">int</span> ans;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _n, <span class="hljs-keyword">int</span> _m)</span> </span>&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            l[i] = i - <span class="hljs-number">1</span>;</span><br><span class="line">            r[i] = i + <span class="hljs-number">1</span>;</span><br><span class="line">            u[i] = d[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        l[<span class="hljs-number">0</span>] = m, r[m] = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(h));</span><br><span class="line">        <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));</span><br><span class="line">        cnt = m + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        s[C]++;</span><br><span class="line">        row[cnt] = cnt, col[cnt] = C;</span><br><span class="line">        u[cnt] = C;</span><br><span class="line">        d[cnt] = d[C];</span><br><span class="line">        u[d[C]] = cnt;</span><br><span class="line">        d[C] = cnt;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h[R] == <span class="hljs-number">-1</span>) h[R] = l[cnt] = r[cnt] = cnt;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            l[cnt] = l[h[R]];</span><br><span class="line">            r[cnt] = h[R];</span><br><span class="line">            r[l[h[R]]] = cnt;</span><br><span class="line">            l[h[R]] = cnt;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d[C]; i != C; i = d[i])</span><br><span class="line">            l[r[i]] = l[i], r[l[i]] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">(<span class="hljs-keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = u[C]; i != C; i = u[i])</span><br><span class="line">            l[r[i]] = r[l[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> v[maxm];</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = r[<span class="hljs-number">0</span>]; c != <span class="hljs-number">0</span>; c = r[c]) v[c] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = r[<span class="hljs-number">0</span>]; c != <span class="hljs-number">0</span>; c = r[c])</span><br><span class="line">            <span class="hljs-keyword">if</span> (v[c]) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">                v[c] = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d[c]; i != c; i = d[i])</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = r[i]; j != i; j = r[j])</span><br><span class="line">                        v[col[j]] = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> deep)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (deep + f() &gt;= ans) <span class="hljs-keyword">return</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!r[<span class="hljs-number">0</span>]) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (deep &lt; ans) ans = deep;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> c = r[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">0</span>; i = r[i]) <span class="hljs-keyword">if</span> (s[i] &lt; s[c]) c = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = d[c]; i != c; i = d[i]) &#123;</span><br><span class="line">            remove(i);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = r[i]; j != i; j = r[j]) remove(j);</span><br><span class="line">            dance(deep + <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l[i]; j != i; j = l[j]) resume(j);</span><br><span class="line">            resume(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dlx;</span><br></pre></td></tr></table></figure><h1>重复覆盖的应用</h1><p><a href="http://acm.fzu.edu.cn/problem.php?pid=1686" target="_blank" rel="noopener">fzu1686-神龙的难题</a></p><p>  每一个1看成列，每个位置作为左上角的矩阵看成行</p><p><a href="https://paste.ubuntu.com/p/fWByWbrTf7/" target="_blank" rel="noopener">代码</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2295" target="_blank" rel="noopener">hdu2295-Radar</a></p><p>  扫描半径越大，雷达覆盖城市越容易，我们可以二分枚举半径R，然后根据这个半径来建立雷达和城市之间的关系矩阵$A$。$A[i][j]=1$当且仅当第i个雷达到第j个城市的距离小于等于R，问题z转化为看能不能选择K行（每行代表每个雷达）满足每行上的列都至少有一个“1”（每个列代表每个城市）。</p><p><a href="https://paste.ubuntu.com/p/Kdkg3vwCXT/" target="_blank" rel="noopener">代码</a></p><p><font size="6"><strong>参考资料</strong></font></p><p><a href="DLX.pdf">Donald E. Knuth的原稿</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索-DLX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Catalan数的原理与应用</title>
      <link href="/Math/Theory-and-application-of-Catalan-Number/"/>
      <url>/Math/Theory-and-application-of-Catalan-Number/</url>
      
        <content type="html"><![CDATA[<h1>卡特兰数(<a href="https://en.wikipedia.org/wiki/Catalan_number" target="_blank" rel="noopener">Catalan number</a>)的原理</h1><h2 id="问题引入"><a class="header-anchor" href="#问题引入">¶</a>问题引入</h2><p>  在一个平面直角坐标系中，只能往右或往上走一个单位长度。问有多少种不同的路径可以从左下角 $(0,0)$ 走到右上角 $(n,n)$，并且要求路径不能经过直线 $y=x$ 上方的点。</p><p><img src="/Math/Theory-and-application-of-Catalan-Number/Catalan1.png" alt></p><p>  总方案数为$\binom{2n}{n}$，考虑不合法方案数，不合法路径必然经过$y=x+1$，找到该路径与$y=x+1$的第一个交点，将后面的路径关于$y=x+1$对称，每一条不合法方案对应一条 $(0,0)$ 到 $(n-1,n+1)$ 的路径，故不合法方案数为$\binom{2n}{n-1}$。</p><p>  卡特兰数即为：<br>$$C_n=\binom{2n}{n}-\binom{2n}{n-1}=\frac{1}{n+1}\binom{2n}{n}$$<br>它的前几项为：$1,1,2,5,14,42,132,429,1430,4862,16796,58786\cdots$</p><p>  若终点为$(m,n)$，同理有方案数为<br>$$\binom{m+n}{n}-\binom{m+n}{n-1}$$</p><p><img src="/Math/Theory-and-application-of-Catalan-Number/Catalan2.png" alt></p><h2 id="其他形式"><a class="header-anchor" href="#其他形式">¶</a>其他形式</h2><h3 id="括号序列"><a class="header-anchor" href="#括号序列">¶</a>括号序列</h3><p>求由$n$对括号形成的合法括号表达式？</p><p>  将长度为$2n$的括号序列映射为路径：左括号向右，右括号向上，那么合法的括号序列不会在 $y=x$ 上方，因此长度为$2n$的括号序列个数为$C_n$。</p><h3 id="出栈顺序"><a class="header-anchor" href="#出栈顺序">¶</a>出栈顺序</h3><p>有 $n$ 个元素（无区别）和一个栈，每次可以将一个元素入栈，或者将栈顶元素弹出，问有多少种不同的操作序列。</p><p>  进栈看作左括号，出栈看作右括号，方案数为$C_n$。</p><h3 id="二叉树计数"><a class="header-anchor" href="#二叉树计数">¶</a>二叉树计数</h3><p>有多少种不同的 $n$ 个节点的二叉树？$n=3$时如图所示。</p><p><img src="/Math/Theory-and-application-of-Catalan-Number/Catalan3.png" alt></p><p>  定义$f_n$表示有$n$个节点的二叉树，那么枚举子树大小可得方程：<br>$$f_n=\sum_{i=0}^{n-1}f_if_{n-i-1}\quad(f_0=1)$$</p><p>  直接计算时间为$O(n^2)$，对二叉树进行遍历，当第一次遇到节点表示加一个左括号，从左子树返回在序列加一个右括号，对应为括号序列问题，故 $n$ 个节点的二叉树种数为 $C_n$。</p><h3 id="凸多边形剖分"><a class="header-anchor" href="#凸多边形剖分">¶</a>凸多边形剖分</h3><p>求 $n+2$ 条边的凸多边形的三角剖分方案数？下图为 $n=4$ 的情况。</p><p><img src="/Math/Theory-and-application-of-Catalan-Number/Catalan4.png" alt></p><p>  设$f_n$为$n$边的方案数，取多边形一条边，从剩余顶点选一个，多边形分成三部分，则</p><p>$$f_n=\sum_{i=2}^{n-1}f_if_{n-i+1}\quad(f_2=1)$$</p><p>故$n+2$条边的凸多边形三角剖分方案数为 $C_n$。</p><h3 id="n-阶梯状图填充"><a class="header-anchor" href="#n-阶梯状图填充">¶</a>$n$阶梯状图填充</h3><p>求用$n$个长方形去填充一个高度为$n$的阶梯图形的方法数。下图为 $n=4$ 的情况。</p><p><img src="/Math/Theory-and-application-of-Catalan-Number/Catalan5.png" alt></p><p>  方案数为$f_n$，取包含左上角的矩形，同理得递推可得其为卡特兰数。</p><p>$$f_n=\sum_{i=0}^{n-1}f_if_{n-i-1}\quad(f_0=1)$$</p><h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2><ol><li>$C_n=\frac{1}{n+1}\binom{2n}{n}=\binom{2n}{n}-\binom{2n}{n-1}$</li><li>$C_n=\frac{1}{n+1}\sum\limits_{i=0}<sup>n\binom{n}{i}</sup>2$</li><li>$C_{n+1}=\frac{2(2n+1)}{n+2}C_n$，且$C_0=1$</li><li>$C_{n+1}=\sum\limits_{i=0}^nC_iC_{n-i}$，且$C_0=1$</li><li>渐近增长 $C_n\sim\frac{4<sup>n}{n</sup>{3/2}\sqrt{\pi}}$</li><li>$(n-3)C_n=\frac{n}{2}(C_3C_{n-1}+C_4C_{n-2}+\cdots+C_{n-1}C_3)$</li></ol><h2 id="数学推导"><a class="header-anchor" href="#数学推导">¶</a>数学推导</h2><p>由于$C_2=C_3=1$</p><p>设$G(x)=C_2+C_3x+C_4x^2+\cdots$<br>$$x^2:C_4=C_2C_3+C_3C_2\<br>x^3:C_5=C_2C_4+C_3C_3+C_4C_2\<br>x^4:C_6=C_2C_5+C_3C_4+C_4C_3+C_5C_2\<br>\vdots$$<br>$$\begin{array}{l}<br>G(x)-x-1&amp;=&amp;C_2(C_3x<sup>2+C_4x</sup>3+\cdots)\<br>&amp;&amp;+C_3x(C_2x+C_3x^2+\cdots)\<br>&amp;&amp;+C_4x<sup>2(C_2x+C_3x</sup>2+\cdots)+\cdots\<br>&amp;=&amp;-x+C_2(C_2x+C_3x^2+\cdots)\<br>&amp;&amp;+C_3x(C_2x+C_3x^2+\cdots)+\cdots<br>\end{array}$$</p><p>$$\Longrightarrow\quad\quad \begin{array}{l}<br>G(x)-1&amp;=&amp;(C_2+C_3x+C_4x<sup>2+\cdots)(C_2x+C_3x</sup>2+\cdots)\<br>&amp;=&amp;x[G(x)]2<br>\end{array}$$</p><p>$$xG^2(x)-G(x)+1=0\<br>G(x)=\frac{1-\sqrt{1-4x}}{2x}$$</p><p>  而$\displaystyle(1-4x)<sup>{\frac{1}{2}}=1+\frac{1}{2}(-4x)-\frac{\displaystyle\frac{1}{2}(\frac{1}{2}-1)}{2!}(-4x)</sup>2+\frac{\displaystyle\frac{1}{2}(\frac{1}{2}-1)(\frac{1}{2}-2)}{3!}(-4x)^3+\cdots$</p><p>所以$(1-4x)<sup>{\frac{1}{2}}$中$x</sup>{n+1}$项的系数为<br>$$\begin{array}{l}<br>&amp;&amp;\displaystyle\frac{1}{(n+1)!}\frac{1}{2}\left(\frac{1}{2}-1\right)\left(\frac{1}{2}-2\right)\cdots\left(\frac{1}{2}-n\right)(-4)^{n+1}\<br>&amp;=&amp;\displaystyle\frac{(-1)<sup>{2n+1}}{(n+1)!}\frac{1\cdot3\cdot\cdots\cdot(2n-1)}{2</sup>{n+1}}2^{2n+2}\<br>&amp;=&amp;\displaystyle\frac{-2}{n+1}\frac{(2n)!}{(n!)^2}=\frac{-2}{n+1}\begin{pmatrix}2n\n\end{pmatrix}<br>\end{array}$$</p><p>故$\displaystyle G(x)=\frac{1-\sqrt{1-4x}}{2x}$且<br>$$C_{n+1}=\frac{1}{n}\begin{pmatrix}2n-2\n-1\end{pmatrix}$$</p><hr><p>由递推关系<br>$$nC_{n+1}=(4n-6)C_n$$<br>$$G(x)=C_2x+C_3x<sup>2+C_4x</sup>3+\cdots\<br>x:2C_3=4\cdot2C_2-6C_2\<br>x^2:3C_4=4\cdot3C_3-6C_3\<br>\vdots$$<br>$$G’(x)-1=4[xG(x)]’-6G(x)$$<br>$$G(x)=C\sqrt{1-4x}+\frac{1}{2}$$<br>由$G(0)=0,$有$\displaystyle C=-\frac{1}{2},$即$\displaystyle G(x)=\frac{1-\sqrt{1-4x}}{2}$</p><h1>应用</h1><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1485" target="_blank" rel="noopener">[BZOJ1485][HNOI2009]有趣的数列</a></p><p>  从小到大添加每个数，放在奇数项视为进栈，偶数项视为出栈，问题转化为求卡特兰数，答案即$C_n=\frac{1}{n+1}\binom{2n}{n}=\frac{\prod_{i=n+2}<sup>{2n}i}{\prod_{i=1}</sup>ni}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, p, cnt;</span><br><span class="line"><span class="hljs-keyword">int</span> pri[N/<span class="hljs-number">10</span>], v[N], c[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getpri</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">2</span> * n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!v[i]) &#123; pri[++cnt] = i; id[i] = cnt; &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= <span class="hljs-number">2</span> * n; ++j) &#123;</span><br><span class="line">            v[i*pri[j]] = <span class="hljs-number">1</span>;</span><br><span class="line">            id[i*pri[j]] = j;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i % pri[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        c[id[x]] += t;</span><br><span class="line">        x /= pri[id[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">    getpri();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n; i &gt; n; --i) add(i, <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) add(i, <span class="hljs-number">-1</span>);</span><br><span class="line">    add(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);</span><br><span class="line">    ll ans = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (c[i]--)</span><br><span class="line">            ans = (ll)ans * pri[i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些字符串算法小结</title>
      <link href="/Algorithm/Summary-of-string-algorithm/"/>
      <url>/Algorithm/Summary-of-string-algorithm/</url>
      
        <content type="html"><![CDATA[<h1>回文串</h1><h2 id="manacher-算法"><a class="header-anchor" href="#manacher-算法">¶</a>$Manacher$算法</h2><p>  <s>众所周知</s>, $Manacher$算法是一个求字符串中最长回文子序列问题的算法, 可以想到一个比较显然的做法: 长度为奇数的回文串以最中间字符的位置为对称轴, 而长度为偶数的回文串的对称轴在中间两个字符之间的空隙处. 于是我们考虑遍历这些对称轴, 并且同时向左右扩展, 直到左右两边的字符不同或到达边界.</p><p>  这个算法的复杂度是$O(n^2)$, 是无法过一些较大数据范围的题, 我们来思考一下这个算法的缺点, 显然, 回文串长度的奇偶性造成了对称轴的位置可能在某字符上, 也可能在两个字符之间的空隙处，要对两种情况分别处理. 为了解决这个问题, 可以强行在原字符串中插入其他本字符串不会出现的字符, 如<code>&quot;#&quot;</code>.</p><a id="more"></a> <p>  对于整个算法的主体, 定义 $p[i]$ 表示以字符 $i$ 为回文中心的最长回文串的半径, 那么 $p[i]-1$ 就是字符串中最长回文串的长度(除去<code>'#'</code>), 定义 $maxr$ 为目前找到回文串的最右端, 中心为 $id$, 当我们扫描到的位置 $i$, 若$id\leq i\leq maxr$, 可以找到对称点 $2<em>id-i$ 求出其最长半径, 那么 $p[i] = \min(p[2</em>id-i], maxr-i)$，之后再进行扩展即可。</p><p><img src="/Algorithm/Summary-of-string-algorithm/manacher1.png" alt></p><p><a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">[模板]$Manacher$算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e7</span> + <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> n, ans, p[N];</span><br><span class="line"><span class="hljs-keyword">char</span> s[N], str[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    str[<span class="hljs-number">0</span>] = str[<span class="hljs-number">1</span>] = <span class="hljs-string">'#'</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        str[(i&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">2</span>] = s[i];</span><br><span class="line">        str[(i&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">3</span>] = <span class="hljs-string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = (n&lt;&lt;<span class="hljs-number">1</span>) + <span class="hljs-number">2</span>; str[n] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> maxr = <span class="hljs-number">0</span>, id = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; str[i] != <span class="hljs-number">0</span>; ++i) str[i] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (maxr &gt; i) p[i] = min(p[<span class="hljs-number">2</span>*id-i], maxr - i);</span><br><span class="line">        <span class="hljs-keyword">else</span> p[i] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; str[i+p[i]] == str[i-p[i]]; ++p[i]);</span><br><span class="line">        <span class="hljs-keyword">if</span> (p[i] + i &gt; maxr) &#123; maxr = p[i] + i; id = i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(s);</span><br><span class="line">    init();</span><br><span class="line">    manacher();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ans = max(ans, p[i]);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans - <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>String Matching Problem</h1><p> Given a text $T$ and a pattern $P$, if $n$=strlen($T$) &gt; strlen($P$) = $m$，find all of occurrences of $P$ within $T$。For example:</p><ul><li>T = ABC ABCDAB ABCD<font color="#FFFF00">ABCDABD</font>E</li><li>P = ABCDABD</li><li>$P$ appears one time in $T$</li></ul><p> We can easily get a naive method takes $O(nm)$ time，that is, initiate string comparison at every starting point, and each comparison takes $O(m)$ time.</p><h2 id="hash-function"><a class="header-anchor" href="#hash-function">¶</a>Hash Function</h2><p>  Hash function is a function that take a string and outputs a number(i.e. ASCII value). We take a constant number $B$, view the string as base-$B$ number, and distribute a positive number to denote a character. Take a const number $Mod$，use the base-$B$ number mod $Mod$ to get hash value.</p><p>$$h(x_1\cdots x_k)=x_1B<sup>{k-1}+x_2B</sup>{k-2}+\cdots+x_{k-1}B+x_k\pmod {Mod}$$</p><p>  A good hash function has few collisions. Generally, we take $B=131$ or $B=1331$, and that yields few collisions，we view string is the same as hash value is equal. If we take $Mod=2^{64}$, we can straight use $unsigned\ long\ long$ integer type to store hash value, automatically mod $2^{64}$ when get overfow error to avoid mod operation that takes time.</p><p>  To figure out the problem, we preprocess $P$ to speedup queries, figure out suffix hash value of $T$ to avoid hash every substing of length $m$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">2e9</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ull B = <span class="hljs-number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> a[N], b[N];</span><br><span class="line">ull Hash[N], hb;</span><br><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line"><span class="hljs-keyword">int</span> Next[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calcNext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (j &amp;&amp; b[i] != b[j+<span class="hljs-number">1</span>]) j = Next[j];</span><br><span class="line">        <span class="hljs-keyword">if</span> (b[i] == b[j+<span class="hljs-number">1</span>]) j++;</span><br><span class="line">        Next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, a + <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, b + <span class="hljs-number">1</span>);</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>);</span><br><span class="line">    m = <span class="hljs-built_in">strlen</span>(b + <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i)</span><br><span class="line">        Hash[i] = a[i] + Hash[i+<span class="hljs-number">1</span>] * B;</span><br><span class="line">    ull base = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        hb += base * b[i];</span><br><span class="line">        base *= B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - m + <span class="hljs-number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (hb == Hash[i] - base * Hash[i + m])</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    calcNext();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, Next[i]);</span><br><span class="line">    <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="knuth-morris-pratt-algorithm"><a class="header-anchor" href="#knuth-morris-pratt-algorithm">¶</a><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Knuth–Morris–Pratt algorithm</a></h2><p> Knuth–Morris–Pratt algorithm, a linear time algorithm that solves the string matching problem by preprocessing P in $O(m)$ time. The main idea is to skip some comparisons by using the previous comparison result.</p><ol><li>Uses an auxiliary array $\pi$ that is defined as the following</li></ol><p>   - $\pi[i]$ is the largest integer smaller than i such that $P_1\dots P_{\pi[i]}$ is a suffix of $P_1\dots P_i$</p><ul><li>It’s better to see an example than the definition.</li></ul><table><thead><tr><th style="text-align:center">$i$</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">$P_i$</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">$\pi[i]$</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p> In the former problem $\pi=(0,0,0,0,1,2,0)$, we define$\pi[0]=-1$，Let’s see why this is useful in the .gif below.</p><p><img src="/Algorithm/Summary-of-string-algorithm/KMP1.gif" alt></p><p>Obviously, we can get some conclusions as follows</p><ul><li><p>if $P_1\dots P_{\pi[i]}$ is a suffix of $P_1\dots P_i$, then $P_1\dots P_{\pi[i]-1}$ is a suffix of $P_1\dots P_{i-1}$</p></li><li><p>all the prefixes of $P$ that are a suffix of $P_1\dots P_i$ can be obtained by recursively applying $\pi$ to $i$</p></li></ul><p>   - e.g., $P_1\dots P_{\pi[i]},P_1\dot P_{\pi[\pi[i]]},P_1\dots P_{\pi[\pi[\pi[i]]]}$ are all suffixes of $P_1\dots P_i$</p><ul><li>A non-obvious conclusion:</li></ul><p>   - First, let’s write $\pi^{(k)}[i]$ as $\pi[\cdot]$ applied k times to i.  e.g. $\pi^{(2)}[i]=\pi[\pi[i]]$</p><p>   - $\pi[i]$ is equal to $\pi^{(k)}[i-1]+1$, where $k$ is the smallest integer that satisfies $P_{\pi^{(k)}[i-1]+1}=P_i$</p><p>   - if there is no such $k$, $\pi[i]=0$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">function <span class="hljs-title">getfail</span><span class="hljs-params">(P)</span></span></span><br><span class="line"><span class="hljs-function">    m </span>= P.length</span><br><span class="line">    let fail[<span class="hljs-number">0.</span>..m<span class="hljs-number">-1</span>] be a <span class="hljs-keyword">new</span> <span class="hljs-built_in">array</span></span><br><span class="line">    fail[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span></span><br><span class="line">    match = <span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> to m - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> match &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> P[match+<span class="hljs-number">1</span>] != P[i]</span><br><span class="line">            match = fail[match]</span><br><span class="line">        <span class="hljs-keyword">if</span> P[match+<span class="hljs-number">1</span>] = P[i]</span><br><span class="line">            match += <span class="hljs-number">1</span></span><br><span class="line">        fail[i] = match</span><br><span class="line">    <span class="hljs-keyword">return</span> fail</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">fuction <span class="hljs-title">KMP</span><span class="hljs-params">(T, P)</span></span></span><br><span class="line"><span class="hljs-function">    fail </span>= getfail(P)</span><br><span class="line">    match = <span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to T.length - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> match &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> P[match+<span class="hljs-number">1</span>] != T[i]</span><br><span class="line">            match = fail[match]</span><br><span class="line">        <span class="hljs-keyword">if</span> P[match+<span class="hljs-number">1</span>] == T[i]</span><br><span class="line">            match += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> match + <span class="hljs-number">1</span> == m</span><br><span class="line">            <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br></pre></td></tr></table></figure><ul><li>Intuition: we look at all the prefixes of $P$ that are suffixes of $P_1\dots P_{i-1}$ and find the longest one whose next letter mathches $P_i$</li></ul><p><a href="https://www.luogu.org/problem/P3375" target="_blank" rel="noopener">[模板]$KMP$算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, Next[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (j &amp;&amp; b[i] != b[j+<span class="hljs-number">1</span>]) j = Next[j];</span><br><span class="line">        <span class="hljs-keyword">if</span> (b[i] == b[j+<span class="hljs-number">1</span>]) j++;</span><br><span class="line">        Next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, a + <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, b + <span class="hljs-number">1</span>);</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(a + <span class="hljs-number">1</span>), m = <span class="hljs-built_in">strlen</span>(b + <span class="hljs-number">1</span>);</span><br><span class="line">    calc();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] != b[j+<span class="hljs-number">1</span>]) j = Next[j];</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[i] == b[j+<span class="hljs-number">1</span>]) j++;</span><br><span class="line">        <span class="hljs-keyword">if</span> (j == m) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i - m + <span class="hljs-number">1</span>); j = Next[j];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, Next[i]);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exkmp"><a class="header-anchor" href="#exkmp">¶</a>exKMP</h2><ul><li><p>后缀: 从字符串某个位置开始到字符串末尾的子串。</p></li><li><p>后缀数组 <strong>SA</strong>(suffix array): 将字符串所有后缀按字典序排序得到的数组，保存对应位置。</p></li><li><p>LCP(Longest Common Prefix): S[sa[i]…] 与 S[sa[i+1]…] 的最长公共前缀长度为 lcp[i]</p></li><li><p>$z_i$: 从 $i$ 开始的后缀与 $s$ 的最长公共子串长度。</p></li></ul><p>为求 $z_i$，维护 $r$ 最大的 $s[l:r]$，$i\le r$ 时 $z_i$ 可直接初始化为 $\min(r - i + 1, z_{i-l})$，然后暴力拓展，若 $i + z_i - 1 &gt; r$，则更新 $l,r$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getz</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-built_in">memset</span>(z, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(z));</span><br><span class="line">    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &lt;= r) z[i] = min(r - i + <span class="hljs-number">1</span>, z[i-l]);</span><br><span class="line"><span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[i+z[i]] == s[z[i]]) z[i]++;</span><br><span class="line"><span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) l = i, r = i + z[i] - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>其他</h1><h2 id="trie-字典树"><a class="header-anchor" href="#trie-字典树">¶</a>$Trie$(字典树)</h2><p>  $Trie$是一种用于实现字符串快速检索的多叉树结构, 其基本操作如下:</p><ol><li>若$P$的$c$字符指针指向一个已经存在的节点$Q$, 则令$P=Q$</li><li>若$P$的$c$字符指针指向空, 则新建一个节点$Q$, 令$P$的$c$字符指针指向$Q$, 然后令$P=Q$</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> trie[N][<span class="hljs-number">26</span>], tot = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(str), p = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ch = str[k] - <span class="hljs-string">'a'</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(str), p = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">        p = trie[p][str[k]-<span class="hljs-string">'a'</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ans;</span><br><span class="line">        ans += ed[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ac-自动机"><a class="header-anchor" href="#ac-自动机">¶</a>$AC$自动机</h2><p>  $AC$自动机就是在 $trie$ 树上进行 $KMP$</p><h2 id="练习"><a class="header-anchor" href="#练习">¶</a>练习</h2><p><a href="https://loj.ac/problem/10050" target="_blank" rel="noopener">LOJ10050 The XOR Largest Pair</a></p><p>题意：求 $n(1\le n\le10^5)$ 个整数 $a_1,a_2,\cdots,a_n(0\le a_i\le2^{31})$ 中选两个数异或运算的最大值。</p><p>  把每个整数看成 32 位的 01 串，把 $a_1\sim a_{i-1}$ 对应的 32 位二进制串插入一颗 Trie 树，对 $a_i$ 对应的 32 位二进制串，在 Trie 树中检索，每次尽量沿着与 $a_i$ 当前位相反的字符指针向下访问，若相反的字符指针为空，则访问相同指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-meta-string">" is "</span> &lt;&lt; x &lt;&lt; endl</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>, N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, tot = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N], trie[N*<span class="hljs-number">32</span>][<span class="hljs-number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">30</span>; k &gt;= <span class="hljs-number">0</span>; --k) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ch = val &gt;&gt; k &amp; <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!trie[p][ch]) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">30</span>; k &gt;= <span class="hljs-number">0</span>; --k) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ch = val &gt;&gt; k &amp; <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (trie[p][ch^<span class="hljs-number">1</span>]) &#123;</span><br><span class="line">            p = trie[p][ch^<span class="hljs-number">1</span>];</span><br><span class="line">            ans |= <span class="hljs-number">1</span> &lt;&lt; k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        Insert(a[i]);</span><br><span class="line">        ans = max(ans, Search(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学基础</title>
      <link href="/Math/The-basis-of-combinatorics/"/>
      <url>/Math/The-basis-of-combinatorics/</url>
      
        <content type="html"><![CDATA[<h1>组合数(<a href="https://en.wikipedia.org/wiki/Binomial_coefficient" target="_blank" rel="noopener">Binomial coefficient</a>)</h1><h2 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h2><p>  首先我们回顾一下一些简单性质</p><ol><li>$\begin{pmatrix}n\k\end{pmatrix}=\displaystyle\frac{n!}{k!(n-k)!}$</li><li>$\begin{pmatrix}n\k\end{pmatrix}=\displaystyle\frac{n}{k}\begin{pmatrix}n-1\k-1\end{pmatrix}$</li><li>$\begin{pmatrix}n\k\end{pmatrix}=\begin{pmatrix}n-1\k\end{pmatrix}+\begin{pmatrix}n-1\k-1\end{pmatrix}$</li><li>$\begin{pmatrix}n\m\end{pmatrix}\begin{pmatrix}m\k\end{pmatrix}=\begin{pmatrix}n\k\end{pmatrix}\begin{pmatrix}n-k\m-k\end{pmatrix}$</li><li>$\displaystyle\sum_{m=0}^n\begin{pmatrix}m\k\end{pmatrix}=\begin{pmatrix}n+1\k+1\end{pmatrix}$</li><li>$\displaystyle\sum_{k=0}<sup>nk\begin{pmatrix}n\k\end{pmatrix}=n2</sup>{n-1},\quad\sum_{k=0}<sup>nk</sup>2\begin{pmatrix}n\k\end{pmatrix}=n(n+1)2^{n-2}$</li></ol><a id="more"></a><h2 id="组合数的计算"><a class="header-anchor" href="#组合数的计算">¶</a>组合数的计算</h2><h3 id="直接算"><a class="header-anchor" href="#直接算">¶</a>直接算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">ll <span class="hljs-title">binom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span> || m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    ll res = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        res *= n - i + <span class="hljs-number">1</span>; res /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用性质3"><a class="header-anchor" href="#利用性质3">¶</a>利用性质3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    C[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j) C[i][j] = C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + C[i<span class="hljs-number">-1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预处理阶乘和阶乘逆元"><a class="header-anchor" href="#预处理阶乘和阶乘逆元">¶</a>预处理阶乘和阶乘逆元</h3><h4 id="费马小定理-a-href-https-en-wikipedia-org-wiki-fermat-27s-little-theorem-fermat-s-little-theorem-a"><a class="header-anchor" href="#费马小定理-a-href-https-en-wikipedia-org-wiki-fermat-27s-little-theorem-fermat-s-little-theorem-a">¶</a>费马小定理(<a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem" target="_blank" rel="noopener">Fermat’s little theorem</a>)</h4><p>  $p$为质数，且$p\nmid a$，则</p><p>$$a^{p-1}\equiv1\pmod p$$</p><p>$$inv(a)\equiv a^{p-2}\pmod p$$</p><p>$$\begin{pmatrix}n\m\end{pmatrix}=fac(n)*inv(m!)*inv((n-m)!)$$</p><p>$$inv(i!)\equiv inv((i+1)!)*(i+1)\pmod p$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> fac[n] * power(fac[m], p - <span class="hljs-number">2</span>) % p * power(fac[n-m], p - <span class="hljs-number">2</span>) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求解$C_n^m mod\ p$，该法要求p为质数</p><h3 id="lucas定理-lucas-s-theorem"><a class="header-anchor" href="#lucas定理-lucas-s-theorem">¶</a>Lucas定理(<a href="https://en.wikipedia.org/wiki/Lucas%27s_theorem" target="_blank" rel="noopener">Lucas’s theorem</a>)</h3><p>$$\begin{pmatrix}n\m\end{pmatrix}\equiv\begin{pmatrix}\lfloor n/p\rfloor\\lfloor m/p\rfloor\end{pmatrix}\begin{pmatrix}n\mod p\m\mod p\end{pmatrix}\pmod p\qquad (p为素数)$$</p><p>$proof:\quad$设$n=sp+q,m=tp+r\ (q,r\leq p)$,那么<br>$$\begin{array}{l}<br>(1+x)<sup>n&amp;=&amp;\left((1+x)</sup>p\right)<sup>s(1+x)</sup>q\<br>&amp;\equiv&amp;(1+x<sup>p)</sup>s(1+x)^q\pmod p\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>s\begin{pmatrix}s\i\end{pmatrix}x</sup>{ip}\sum_{j=0}<sup>q\begin{pmatrix}q\j\end{pmatrix}x</sup>j\<br>\end{array}$$</p><p>可以得到</p><p>$$(1+x)<sup>{sp+q}\equiv\sum_{i=0}</sup>s\begin{pmatrix}s\i\end{pmatrix}x<sup>{ip}\sum_{j=0}</sup>q\begin{pmatrix}q\j\end{pmatrix}x^j\pmod p$$</p><p>$LHS$中$(1+x)<sup>{sp+q}$中的$x</sup>{tp+r}$系数为$\begin{pmatrix}sp+q\tp+r\end{pmatrix}$, $RHS$中的$x^{tp+r}$系数为$\begin{pmatrix}s\t\end{pmatrix}\begin{pmatrix}q\r\end{pmatrix}$, 从而</p><p>$$\begin{pmatrix}sp+q\tp+r\end{pmatrix}\equiv\begin{pmatrix}s\t\end{pmatrix}\begin{pmatrix}q\r\end{pmatrix}\pmod p$$</p><p>这与原命题等价, 证毕.</p><p><a href="https://www.luogu.org/problem/P3807" target="_blank" rel="noopener">Lucas定理模板题</a></p><p><a href="https://paste.ubuntu.com/p/WS4v7wh9dH/" target="_blank" rel="noopener">code</a></p><h3 id="lucas定理-crt合并"><a class="header-anchor" href="#lucas定理-crt合并">¶</a>Lucas定理+CRT合并</h3><h4 id="crt合并"><a class="header-anchor" href="#crt合并">¶</a>CRT合并</h4><p>  对同余方程</p><p>$$\begin{cases}x\equiv{a_1}\pmod{p_1}\x\equiv{a_2}\pmod{p_2}\end{cases}$$</p><p>令$x=mp_1+a_1,$代入方程2得</p><p>$$mp_1\equiv{a_2-a_1}\pmod{p_2}$$</p><p>即</p><p>$$mp_1-np_2=a_2-a_1$$</p><p>由贝祖定理(<a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity" target="_blank" rel="noopener">Bezout’s identity</a>)，若$m$有解$m_0$(即$\gcd(p_1,p_2)|a_2-a_1,m_0$可用exgcd求)，则$m$满足通项</p><p>$$m=m_0+k\frac{p_2}{\gcd(p_1,p_2)}\quad k\in\Bbb{Z}$$</p><p>代入$x$表达式有</p><p>$$x=m_0p_1+k{\rm{lcm}}(p_1,p_2)+a_1$$</p><p>故</p><p>$$x\equiv m_0p_1+a_1\pmod{ {\rm lcm}(p_1,p_2) }$$</p><h4 id="孙子定理-a-href-https-en-wikipedia-org-wiki-chinese-remainder-theorem-chinese-remainder-theorem-a"><a class="header-anchor" href="#孙子定理-a-href-https-en-wikipedia-org-wiki-chinese-remainder-theorem-chinese-remainder-theorem-a">¶</a>孙子定理(<a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem" target="_blank" rel="noopener">Chinese remainder theorem</a>)</h4><p>  对同余方程组，其中$p_i$两两互质</p><p>$$\begin{cases}x\equiv{a_1}\pmod{p_1}\x\equiv{a_2}\pmod{p_2}\\quad\vdots\x\equiv{a_n}\pmod{p_n}<br>\end{cases}$$</p><p>设$\displaystyle P=\prod_{i=1}^np_i,\ P_i=\frac{P}{p_i}$，则方程组有通解</p><p>$$x\equiv\sum_{i=1}^na_iP_i{\rm inv}(P_i)\pmod{P}$$</p><p><a href="https://www.luogu.com.cn/problem/P2480" target="_blank" rel="noopener">P2840</a></p><h3 id="勒让德定理-a-href-https-en-wikipedia-org-wiki-legendre-27s-formula-legendre-s-formula-a-或者叫扩展lucas"><a class="header-anchor" href="#勒让德定理-a-href-https-en-wikipedia-org-wiki-legendre-27s-formula-legendre-s-formula-a-或者叫扩展lucas">¶</a>勒让德定理(<a href="https://en.wikipedia.org/wiki/Legendre%27s_formula" target="_blank" rel="noopener">Legendre’s formula</a>) (或者叫扩展Lucas)</h3><p>  考虑计算</p><p>$$\begin{pmatrix}n\m\end{pmatrix}\mod{p}$$</p><p>对$p$进行唯一分解$p=\prod p_i^{c_i}$</p><p>  我们想知道$n!$分解里$p_i$的最高指数，设$f(n)$表示$n!$分解里$p$的最高指数，我们这样考虑：先将$p$的倍数($\lfloor\frac{n}{p}\rfloor$个)全部除以$p$，再考虑除$p$后的子问题，有递推</p><p>$$f(n)=f(\lfloor\frac{n}{p}\rfloor)+\lfloor\frac{n}{p}\rfloor$$</p><p>  勒让德定理：在正数$n!$的素因子标准分解式中，素数$p$的最高指数为<br>$$v_p(n!)=\displaystyle\sum_{i=1}<sup>\infty\lfloor\frac{n}{p</sup>i}\rfloor$$</p><h2 id="一些应用"><a class="header-anchor" href="#一些应用">¶</a>一些应用</h2><blockquote><p>给定$n,m$输出$C_n^m$的后十位。其中$0&lt;m\le n\le 30000$，输出时不足十位数也按十位输出，此时高位补0。<br><b>input</b>：29999 27381<br><b>output</b>：4531330240</p></blockquote><p>  将分子分母进行分解并进行约分，数组$c$记录重数</p><p><a href="https://paste.ubuntu.com/p/fhXvk2wHz5/" target="_blank" rel="noopener">code</a></p><h1>生成函数(<a href="https://en.wikipedia.org/wiki/Generating_function" target="_blank" rel="noopener">Generating function</a>)</h1><p>  对于有限数列$a_0,a_1,a_2,\cdots,a_n,$多项式$f(z)=\displaystyle\sum_{k=0}<sup>na_kz</sup>k$称为数列${a_k}$的生成函数。无穷数列相关定义类似。</p><h2 id="技巧"><a class="header-anchor" href="#技巧">¶</a>技巧</h2><ul><li>乘积</li></ul><p>$$f(z)g(z)=\sum_{i&gt;=0}a_iz<sup>i\sum_{j&gt;=0}b_jz</sup>j\=(a_0b_0)+(a_0b_1+a_1b_0)z+(a_0b_2+a_1b_1+a_2b_0)z^2$$</p><p>$f(z)g(z)$是${c_n}$的生成函数，其中</p><p>$$c_n=\sum_{k=0}^na_kb_{n-k}$$</p><p>其中一个特例是</p><p>$$\frac{1}{1-z}f(z)=a_0+(a_0+a_1)z+(a_0+a_1+a_2)z^2+\cdots$$</p><p>三个函数乘积的生成函数遵循</p><p>$$d_n=\sum_{\begin{array}{c}i,j,k&gt;0\i+j+k=n\end{array} }a_ib_jc_k$$</p><p>一般地，任意函数乘积遵循</p><p>$$\prod_{j\geq0}\sum_{i\geq0}a_{ij}z<sup>i=\sum_{n\geq0}\left(z</sup>n\sum_{\begin{array}{c}i_0,i_1,\cdots\geq0\i_0+i_1+\cdots=n\end{array} }a_{0i_0}a_{ai_1}\cdots\right)$$</p><p>$$$$</p><ul><li>变换</li></ul><p>$$\frac{1}{2}(f(z)+f(-z))=\sum_{n\geq0}a_{2n}z^{2n}$$<br>$$\frac{1}{2}(f(z)-f(-z))=\sum_{n\geq0}a_{2n+1}z^{2n+1}$$</p><p>利用复数根$w=e^{\frac{2\pi i}{m} }=\cos{\frac{2\pi}{m} }+i\sin{\frac{2\pi}{m} }$，我们可以扩展得到</p><p>$$\sum_{n\geq0,n\bmod m=r}a_nz^n=\frac{1}{m}\sum_{0\leq k&lt;m}w<sup>{-kr}f(w</sup>kz)$$</p><p>例如$m=3$，$w=-\frac{1}{2}+\frac{\sqrt{3}}{2}i$，有</p><p>$$a_1z+a_4z<sup>4+a_7z</sup>7+\cdots=\frac{1}{3}(f(z)+w<sup>{-1}f(wz)+w</sup>{-2}f(w^2z))$$</p><h2 id="生成函数举例"><a class="header-anchor" href="#生成函数举例">¶</a>生成函数举例</h2><p>$$(1+z)<sup>n=\sum_{k\geq0}\begin{pmatrix}n\k\end{pmatrix}z</sup>k$$</p><p>$$\frac{1}{(1-z)^{n+1} }=\sum_{k\geq0}\begin{pmatrix}n+k\n\end{pmatrix}z^k$$</p><p>$$e<sup>z=\sum_{k\geq0}\frac{1}{k!}z</sup>k$$</p><p>$$\ln{(1+z)}=z-\frac{1}{2}z<sup>2+\cdots=\sum_{k\geq1}\frac{(-1)</sup>{k+1} }{k}z^k$$</p><p>$$\frac{z}{e<sup>z-1}=1-\frac{1}{2}z+\frac{1}{12}z</sup>2+\cdots=\sum_{k\geq0}\frac{B_k}{k!}z^k$$</p><p>其中$B_k$为<a href="https://en.wikipedia.org/wiki/Bernoulli_number" target="_blank" rel="noopener">伯努利数</a>，以下函数涉及到<a href="https://en.wikipedia.org/wiki/Stirling_number" target="_blank" rel="noopener">斯特林数</a></p><p>$$(e<sup>z-1)</sup>n=z<sup>n+\frac{1}{n+1}\begin{Bmatrix}n+1\n\end{Bmatrix}z</sup>{n+1}+\cdots=n!\sum_{k}\begin{Bmatrix}k\n\end{Bmatrix}\frac{z^k}{k!}$$</p><p>$$\left(\ln\frac{1}{1-z}\right)<sup>n=z</sup>n+\frac{1}{n+1}\begin{bmatrix}n+1\n\end{bmatrix}z<sup>{n+1}+\cdots=n!\sum_{k}\begin{bmatrix}k\n\end{bmatrix}\frac{z</sup>k}{k!}$$</p><p>$$z(z+1)\cdots(z+n-1)=\sum_{k}\begin{bmatrix}n\k\end{bmatrix}z^k$$</p><p>$$\frac{z<sup>n}{(1-z)(1-2z)\cdots(1-nz)}=\begin{Bmatrix}k\n\end{Bmatrix}z</sup>k$$</p><h2 id="证明组合恒等式"><a class="header-anchor" href="#证明组合恒等式">¶</a>证明组合恒等式</h2><p>$$(1)\sum_{k=1}<sup>nC_n</sup>kC_n<sup>{n+1-k}=C_{2n}</sup>{n+1}$$</p><details><summary>proof</summary><p>$\displaystyle\left(\sum_{i=0}<sup>nC_n</sup>iz<sup>i\right)\left(\sum_{j=0}</sup>nC_n<sup>jz</sup>j\right)=(1+z)<sup>{2n}=\sum_{k=0}</sup>{2n}C_{2n}<sup>kz</sup>k$, 两边$z^{n+1}$系数相等。</p></details><p>$$(2)\sum_{k=0}<sup>{[\frac{n}{2}]}(-1)</sup>kC_{n+1}<sup>kC_{2n-2k}</sup>n=n+1$$</p><details><summary>proof</summary><p>$$\displaystyle\sum_{k=0}<sup>{n+1}C_{n+1}</sup>kz<sup>k=(1+z)</sup>{n+1}\=\frac{(1-z<sup>2)</sup>{n+1}}{(1-z)<sup>{n+1}}=\left(\sum_{k=0}</sup>{n+1}(-1)<sup>kC_{n+1}</sup>kz<sup>{2k}\right)\left(\sum_{j=0}</sup>\infty C_{n+j}<sup>nz</sup>j\right),$$</p><p>右边$z<sup>n$系数$=\displaystyle\sum_{k=0}</sup>{[\frac{n}{2}]}(-1)<sup>kC_{n+1}</sup>kC_{n+(n-2k)}<sup>n=\sum_{k=0}</sup>{[\frac{n}{2}]}(-1)<sup>kC_{n+1}</sup>kC_{2n-2k}<sup>n=$左边$z</sup>n$系数$=n+1$</p></details><p>$$(3)\sum_{k=p}<sup>n(-1)</sup>kC_n<sup>kC_k</sup>p=(-1)^n\delta_{pn},\text{其中}\delta_{ij}=\begin{cases}1\quad ,i=j\0\quad ,i\neq j\end{cases}$$</p><details><summary>proof</summary><p>$$\displaystyle\because k\geq p\text{时}(1+z)<sup>k=\sum_{i=0}</sup>kC_k<sup>iz</sup>i\text{中}z<sup>p\text{系数}C_k</sup>p,0\leq k &lt; p\text{时}(1+z)<sup>k\text{中}z</sup>p\text{系数}0$$<br>$\displaystyle\therefore\sum_{k=0}<sup>n(-1)</sup>kC_n<sup>k(1+z)</sup>k中z<sup>p系数为\sum_{k=p}</sup>n(-1)<sup>kC_n</sup>kC_k<sup>p$并且$\displaystyle\sum_{k=0}</sup>n(-1)<sup>kC_n</sup>k(1+z)<sup>k=[1-(1+z)]</sup>n=(-1)<sup>nz</sup>n$中$z^p$系数为$(-1)\delta_{pn}$,即证。</p></details><h2 id="实际应用"><a class="header-anchor" href="#实际应用">¶</a>实际应用</h2><blockquote><p>将一张$n$元的纸币全部兑换为1元和2元的纸币，问有多少种不同的兑换方法?</p></blockquote><p>  所求方法数为下列多项式中$z^n$的系数$a_n$<br>$$f(z)=\sum_{n=0}^\infty a_nz<sup>n=\left(\sum_{i=0}</sup>\infty z<sup>i\right)\left(\sum_{j=0}</sup>\infty z<sup>{2j}\right)\=\left(\frac{1}{1-z}\right)\left(\frac{1}{1-z</sup>2}\right)=\frac{1}{4(1+z)}+\frac{1}{2(1-z<sup>2)}+\frac{1}{4(1-z)}\=\sum_{n=0}</sup>\infty\left(\frac{n+1}{2}+\frac{1+(-1)<sup>n}{4}\right)z</sup>n$$<br>故所求方法数为$\displaystyle a_n=\frac{n+1}{2}+\frac{1+(-1)^n}{4}=\left[\frac{n+2}{2}\right]$</p><blockquote><p>求$n$位十进制数中出现偶数个5的数的个数。</p></blockquote><p>  设$a_n$表示$n$位十进制数中出现偶数个5的个数，$b_n$表示$n$位十进制数中出现奇数个的个数，则：</p><p>$$\begin{cases}<br>a_n=9a_{n-1}+b_{n-1}\<br>b_n=9b_{n-1}+a_{n-1}\<br>a_1=8,\ b_1=1<br>\end{cases}$$</p><p>设${a_n}$，${b_n}$生成函数分别为$f(z)$，$g(z)$则</p><p>$$(1-9z)f(z)-zg(z)=a_1=8$$<br>$$(1-9z)g(z)-zf(z)=b_1=1$$</p><p>解得</p><p>$$f(z)=\frac{1}{2}\left(\frac{7}{1-8z}+\frac{9}{1-10z}\right)=\frac{1}{2}\left(\sum_{n=0}<sup>\infty7*(8z)</sup>n+\sum_{n=0}<sup>\infty9*(10z)</sup>n\right)$$</p><p>所以<br>$$a_n=\frac{7*8<sup>{n-1}+9*10</sup>{n-1}}{2}$$</p><p><a href="https://www.luogu.com.cn/problem/P2563" target="_blank" rel="noopener">P2563</a>质数分解问题</p><p>构造生成函数</p><p>$$G(z)=\sum_{k=0}<sup>{\infty}z</sup>{2k}<em>\sum_{k=0}<sup>{\infty}z</sup>{3k}\sum_{k=0}<sup>{\infty}z</sup>{5k}</em>\cdots$$</p><p>则$z^n$的系数为所求方案数。</p><p><a href="https://paste.ubuntu.com/p/5VgZ7tsgVX/" target="_blank" rel="noopener">代码</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈几个特殊函数</title>
      <link href="/Math/Talk-about-a-few-special-functions/"/>
      <url>/Math/Talk-about-a-few-special-functions/</url>
      
        <content type="html"><![CDATA[<h1>$\Gamma函数$</h1><p>  在数学中，$\Gamma$函数，是<strong>阶乘函数</strong>在实数与复数域上的扩展。</p><p>  $\Gamma$函数可通过第二类$Euler$积分定义:</p><p>$$\Gamma(z)=\int_0<sup>{\infty}t</sup>{z-1}e^{-t}\mathrm{d}t$$</p><p>![](Talk about a few special functions/gamma1.jpg)</p><h2 id="简单性质"><a class="header-anchor" href="#简单性质">¶</a>简单性质</h2><ol><li>$\displaystyle\Gamma(z+1)=\int_0<sup>{\infty}t</sup>{z}e<sup>{-t}\mathrm{d}t=t</sup>z(-e<sup>{-t})|_0</sup>\infty+z\int_0^\infty t<sup>{z-1}e</sup>{-t}\mathrm{d}t=z\Gamma(z)\ (z&gt;0)$</li></ol><p>  从而$\Gamma(z)=(z-1)!$</p><ol start="2"><li><p>$\Gamma(z)=2\displaystyle\int_0<sup>{+\infty}t</sup>{2z-1}e<sup>{-t</sup>2}\mathrm{d}t$</p></li><li><p>$\Gamma(z)$在$(0,+\infty)$上为严格下凸函数, 它及其任意阶导数都连续, 且<br>$$\Gamma<sup>{(n)}(z)=\int_0</sup>{+\infty}t^{z-1}(\ln t)<sup>ne</sup>{-t}\mathrm{d}t$$</p></li></ol><p><strong>命题[Bohr-Mollerup定理]</strong> 如果$f:(0,\infty)\to(0,\infty)$，且满足：</p><ol><li>$f(z)&gt;0,f(1)=1$</li><li>$f(z+1)=zf(z)$</li><li>$\ln{f(z)}$是凸函数</li></ol><p>则$f(z)\equiv \Gamma(z),z\in(0,\infty)$</p><h2 id="欧拉无穷乘积公式"><a class="header-anchor" href="#欧拉无穷乘积公式">¶</a>欧拉无穷乘积公式</h2><p>  我们考察被积函数$f(t)=t<sup>{z-1}e</sup>{-t}$，设函数序列$f_n(t):[0,+\infty)\rightarrow\Bbb{C}$,且$\displaystyle f_n(t)=\begin{cases}t<sup>{z-1}(1-\frac{t}{n})</sup>n\quad ,t\in[0,n]\0\quad,\text{其他}\end{cases}$，显然$\displaystyle\lim_{n\to\infty}f_n(t)=f(t)$，且$|Re[f_n(t)]|\leq t<sup>{Re(z)-1}e</sup>{-t}, |Im[f_n(t)]|\leq t<sup>{Im(z)-1}e</sup>{-t}$，由<strong>控制收敛定理</strong>得</p><p>$$\lim_{n\to\infty}\int_0<sup>{\infty}f_n(t)\mathrm{d}t=\int_0</sup>{\infty}f(t)\mathrm{d}t$$</p><p>又因为$\displaystyle f_n(t)\equiv0\forall t\notin[0,n],\therefore \int_0<sup>{\infty}f_n(t)\mathrm{d}t=\int_0</sup>{n}f_n(t)\mathrm{d}t$,，所以</p><p>$$\lim_{n\to\infty}\int_0<sup>{n}f_n(t)\mathrm{d}t=\int_0</sup>{\infty}f(t)\mathrm{d}t$$</p><p>定义$\displaystyle P_n(z)=\int_0<sup>{n}t</sup>{z-1}\left(1-\frac{t}{n}\right)^n\mathrm{d}t$，我们由以上结论可得</p><p>$$\lim_{n\to\infty}P_n(z)=\Gamma(z)$$</p><p>  当然我们也可以按如下方式证明：</p><p>$$\Gamma(z)-P_n(z)=\int_0<sup>n[e</sup>{-t}-(1-\frac{t}{n})]t<sup>{z-1}\mathrm{d}t+\int_n</sup>{\infty}e<sup>{-t}t</sup>{z-1}\mathrm{d}t$$</p><p>易知$RHS$第二项极限$n\to\infty$为0，对第一项，我们由以下引理</p><p>$$0\leq e<sup>{-t}-\left(1-\frac{t}{n}\right)</sup>n\leq \frac{t<sup>2}{n}e</sup>{-t}$$</p><p>得</p><p>$$\left|\int_0<sup>n[e</sup>{-t}-(1-\frac{t}{n})]t<sup>{z-1}\mathrm{d}t\right|\leq\int_0</sup>n\frac{1}{n}e<sup>{-t}t</sup>{x+1}\mathrm{d}t&lt;\frac{1}{n}\int_0<sup>{\infty}e</sup>{-t}t^{x+1}\mathrm{d}t\rightarrow0$$</p><p>其中$x=Re(z)$，这样就证明了$\displaystyle\lim_{n\to\infty}P_n(z)=\Gamma(z)$</p><p>  下面证明引理，$0&lt;y&lt;1$时有$1+y\leq e<sup>y\leq(1-y)</sup>{-1}$，令$t=\frac{t}{n}$得</p><p>$$\left(1+\frac{t}{n}\right)^{-n}\geq e<sup>{-t}\geq\left(1-\frac{t}{n}\right)</sup>n$$</p><p>故</p><p>$$0\leq e<sup>{-t}-\left(1-\frac{t}{n}\right)</sup>n=e<sup>{-t}\left[1-e</sup>t\left(1-\frac{t}{n}\right)^n\right]\leq e<sup>{-t}\left[1-\left(1-\frac{t</sup>2}{n<sup>2}\right)</sup>n\right]$$</p><p>又由伯努利不等式$0\leq\alpha\leq1$有$(1-n\alpha)^n\geq1-n\alpha$得</p><p>$$1-\left(1-\frac{t<sup>2}{n</sup>2}\right)<sup>n\leq\frac{t</sup>2}{n}$$</p><p>即证</p><p>在$P_n(z)$中令$t=nx$得</p><p>$$\int_0<sup>{n}t</sup>{z-1}\left(1-\frac{t}{n}\right)<sup>n\mathrm{d}t=n</sup>z\int_0<sup>1x</sup>{z-1}(1-x)<sup>n\mathrm{d}x=n</sup>zI_{n,z}$$</p><p>分部积分得</p><p>$$\begin{array}{l}I_{n,z}&amp;=&amp;\displaystyle\int_0<sup>1(1-x)</sup>n\mathrm{d}\left(\frac{x^z}{z}\right)\<br>&amp;=&amp;\displaystyle\frac{x<sup>z(1-x)</sup>n}{z}|+\frac{n}{z}\int_0<sup>1x</sup>z(1-x)^{n-1}\mathrm{d}x\<br>&amp;=&amp;\displaystyle\frac{n}{z}I_{n-1,z+1}\end{array}$$</p><p>而</p><p>$$I_{0,z+n}=\int_0<sup>1x</sup>{z+n-1}\mathrm{d}x=\frac{1}{z+n}$$</p><p>从而</p><p>$$I_{n,z}=\frac{n!}{z(z+1)\cdots(z+n)}$$</p><p>得到$\Gamma$函数另一个定义: <strong>$Gauss$无穷乘积</strong>分解</p><p>$$\Gamma(z)=\lim_{n\to\infty}\frac{n!n^z}{z(z+1)\cdots(z+n)}$$</p><p>由于$\displaystyle\lim_{n\to\infty}\frac{n}{z+n}=1$，又可以写成</p><p>$$\Gamma(z)=\lim_{n\to\infty}\frac{(n-1)!n^z}{z(z+1)\cdots(z+n-1)}$$</p><p>这就是著名的$Euler-Gauss$公式</p><p>又因为$\displaystyle n<sup>z=\prod_{k=1}</sup>{n-1}\left(1+\frac{1}{k}\right)$, 极限可以改写成</p><p>$$\Gamma(z)=\lim_{n\to\infty}\frac{1}{z}\prod_{k=1}<sup>n\left(1+\frac{z}{k}\right)</sup>{-1}\left(1+\frac{1}{k}\right)^z$$</p><p>我们得到$\Gamma$函数的欧拉乘积形式</p><p>$$\Gamma(z)=\frac{1}{z}\prod_{k=1}<sup>\infty\frac{\left(1+\frac{1}{k}\right)</sup>z}{1+\frac{z}{k}}$$</p><h2 id="weierstrass-无穷乘积"><a class="header-anchor" href="#weierstrass-无穷乘积">¶</a>$Weierstrass$无穷乘积</h2><p>  由于$\Gamma$函数恒不为$0$，有</p><p>$$\begin{array}{l}<br>\displaystyle\frac{1}{\Gamma(z)}&amp;=&amp;\displaystyle\lim_{n\to\infty}\frac{z(z+1)\cdots(z+n)}{n!n^z}\<br>&amp;=&amp;\displaystyle\lim_{n\to\infty}zn<sup>{-z}\prod_{k=1}</sup>n\left(1+\frac{z}{k}\right)\<br>&amp;=&amp;\displaystyle\lim_{n\to\infty}ze^{-z\ln n}\prod_{k=1}^n\left(1+\frac{z}{k}\right)\<br>&amp;=&amp;\displaystyle\lim_{n\to\infty}ze^{-z(\ln n-H_n)}e<sup>{-zH_n}\prod_{k=1}</sup>n\left(1+\frac{z}{k}\right)\<br>&amp;=&amp;\displaystyle\lim_{n\to\infty}ze^{z(H_n-\ln n)}\prod_{k=1}<sup>n\left(1+\frac{z}{k}\right)e</sup>{-\frac{z}{k}}\<br>&amp;=&amp;\displaystyle ze^{z\lim\limits_{n\to\infty}(H_n-\ln n)}\prod_{k=1}<sup>n\left(1+\frac{z}{k}\right)e</sup>{-\frac{z}{k}}\<br>&amp;=&amp;\displaystyle ze^{\gamma z}\prod_{k=1}<sup>n\left(1+\frac{z}{k}\right)e</sup>{-\frac{z}{k}}<br>\end{array}$$</p><p>上式即为$\Gamma$函数的$Weierstrass$定义，其中$\displaystyle H_n=\sum_{k=1}^n\frac{1}{k}$，欧拉常数$\displaystyle\gamma=\lim_{n\to\infty}(H_n-\ln n)=0.577215\cdots$</p><h2 id="与三角函数的关系"><a class="header-anchor" href="#与三角函数的关系">¶</a>与三角函数的关系</h2><p>  由欧拉无穷乘积公式</p><p>$$\Gamma(z)\Gamma(-z)=-\frac{1}{z<sup>2}\prod_{k=1}</sup>\infty\left(1-\frac{z<sup>2}{n</sup>2}\right)^{-1}$$</p><p>由正弦函数无穷乘积公式</p><p>$$\frac{\sin z}{z}=\prod_{k=1}<sup>\infty\left(1-\frac{z</sup>2}{\pi<sup>2k</sup>2}\right)$$</p><p>得</p><p>$$\Gamma(z)\Gamma(-z)=-\frac{\pi}{z\sin{\pi z}}$$</p><p>由$\Gamma(1-z)=-z\Gamma(-z)$得</p><p>$$\Gamma(z)\Gamma(1-z)=\frac{\pi}{\sin{\pi z}}$$</p><p>为余元公式，写成对称形式得</p><p>$$\Gamma(1+z)\Gamma(1-z)=z!*(-z)!=\frac{\pi z}{\sin{\pi z}}$$</p><p>在正弦函数无穷乘积公式中令$\displaystyle z=\frac{\pi}{2}$得$Wallis$乘积</p><p>$$\frac{\pi}{2}=\prod_{k=1}<sup>\infty\frac{(2k)</sup>2}{(2k-1)(2k+1)}=\lim_{n\to\infty}\left(\prod_{k=1}<sup>n\frac{2k}{2k-1}\right)</sup>2\frac{1}{2n+1}$$</p><h2 id="欧拉乘积公式"><a class="header-anchor" href="#欧拉乘积公式">¶</a>欧拉乘积公式</h2><p>  我们应用余元公式证明</p><p>$$\Gamma(z)\Gamma\left(z+\frac{1}{m}\right)\Gamma\left(z+\frac{2}{m}\right)\cdots\Gamma\left(z+\frac{m-1}{m}\right)=(2\pi)<sup>{\frac{m-1}{2}}m</sup>{\frac{1}{2}-mz}\Gamma(mz)$$</p><p>令</p><p>$$C =\frac{m<sup>{mz}}{m\Gamma(mz)}\prod_{k=0}</sup>{m-1}\Gamma\left(z+\frac{k}{m}\right)$$</p><p>由$Euler-Gauss$公式</p><p>$$\begin{array}{l}<br>C&amp;=&amp;\displaystyle m<sup>{mz-1}\lim_{n\to\infty}\frac{\prod\limits_{k=0}</sup>{m-1}\frac{(n-1)!}{(z+\frac{k}{m})(z+\frac{k}{m}+1)\cdots(z+\frac{k}{m}+n-1)}n<sup>{z+\frac{k}{m}}}{\frac{(mn-1)!}{mz(mz+1)\cdots(mz+mn-1)}(mn)</sup>{mz}}\<br>&amp;=&amp;\displaystyle m<sup>{mz-1}\lim_{n\to\infty}\frac{[(n-1)!]</sup>mn<sup>{mz+\frac{1}{2}(m-1)}m</sup>{(n+1)m}}{(mn-1)!(mn)^{mz}}\<br>&amp;=&amp;\displaystyle\lim_{n\to\infty}\frac{[(n-1)!]<sup>mn</sup>{\frac{1}{2}(m-1)}m^{nm-1}}{(mn-1)!}<br>\end{array}$$</p><p>从而$C$与$z$无关，令$z=\frac{1}{n}$得</p><p>$$C=\prod_{k=0}<sup>{m-1}\Gamma\left(\frac{k+1}{m}\right)=\prod_{k=1}</sup>{m-1}\Gamma\left(\frac{k}{m}\right)=\prod_{k=1}^{m-1}\Gamma\left(1-\frac{k}{m}\right)$$</p><p>由余元公式得</p><p>$$C<sup>2=\prod_{k=1}</sup>{m-1}[\Gamma\left(\frac{k}{m}\right)\Gamma\left(1-\frac{k}{m}\right)]=\pi<sup>{m-1}\prod_{k=1}</sup>{m-1}\left(\sin \frac{k\pi}{m}\right)^{-1}$$</p><p>由于$z<sup>m-1=0$的根为$z=e</sup>{\frac{2k\pi i}{m}},k=0,1,\cdots,m-1$</p><p>$$\frac{z<sup>m-1}{z-1}=\sum_{k=0}</sup>{m-1}z<sup>k=\prod_{k=1}</sup>{m-1}\left(z-e^{\frac{2k\pi i}{m}}\right)$$</p><p>令$z=1$得</p><p>$$\begin{array}{l}<br>m&amp;=&amp;\displaystyle\prod_{k=1}<sup>{m-1}\left(1-e</sup>{\frac{2k\pi i}{m}}\right)\<br>&amp;=&amp;\displaystyle\prod_{k=1}<sup>{m-1}e</sup>{\frac{k\pi i}{m}}\left(-2i\sin{\frac{k\pi}{m}}\right)\<br>&amp;=&amp;\displaystyle e^{\frac{m-1}{2}\pi i}2<sup>{m-1}(-i)</sup>{m-1}\prod_{k=1}^{m-1}\sin{\frac{k\pi}{m}}\<br>&amp;=&amp;\displaystyle2<sup>{m-1}\prod_{k=1}</sup>{m-1}\sin{\frac{k\pi}{m}}<br>\end{array}$$</p><p>从而</p><p>$$C<sup>2=\frac{(2\pi)</sup>{m-1}}{m}$$</p><p>取平方根代入即得</p><p>$$\prod_{k=0}<sup>{m-1}\Gamma\left(z+\frac{k}{m}\right)=(2\pi)</sup>{\frac{m-1}{2}}m^{\frac{1}{2}-mz}\Gamma(mz)$$</p><p>令$m=2$得$Legendre$加倍公式</p><p>$$\Gamma(2z)=\frac{2^{2z-1}}{\sqrt{\pi}}\Gamma(z)\Gamma\left(z+\frac{1}{2}\right)$$</p><h2 id="psi-函数"><a class="header-anchor" href="#psi-函数">¶</a>$\Psi$函数</h2><p>  定义$Digamma$函数</p><p>$$\Psi(z)=\frac{\mathrm{d}\ln{\Gamma(z)}}{\mathrm{d}z}=\frac{\Gamma’(z)}{\Gamma(z)}$$</p><p>它有一个漂亮的性质</p><p>$$\Psi(z+1)=\Psi(z)+\frac{1}{z}$$</p><p>由$Weierstrass$对$\Gamma$函数的定义$\displaystyle\Gamma(z)=\frac{e^{-\gamma z}}{z}\prod_{k=1}<sup>\infty\left(1+\frac{z}{k}\right)</sup>{-1}e^{\frac{z}{k}}$得</p><p>$$\ln\Gamma(z)=-\gamma z-\ln z+\sum_{k=1}^\infty[\frac{z}{k}-\ln{(k+z)}+\ln k]$$</p><p>两边求导得</p><p>$$\frac{\Gamma’(z)}{\Gamma(z)}=-\gamma-\frac{1}{z}+\sum_{k=1}^\infty\left(\frac{1}{k}-\frac{1}{k+z}\right)$$</p><p>从而</p><p>$$\Psi(z)=-\gamma+\sum_{k=0}^\infty\left(\frac{1}{k+1}-\frac{1}{k+z}\right)$$</p><p>令$z=1$结合$\Gamma(1)=1$得</p><p>$$\Psi(1)=\Gamma’(1)=-\gamma$$</p><p>注意到</p><p>$$\frac{1}{k+1}-\frac{1}{k+z}=\int_0<sup>1(x</sup>k-x<sup>{k+z-1})\mathrm{d}x=\int_0</sup>1x<sup>k(1-x</sup>{z-1})\mathrm{d}x$$</p><p>那么</p><p>$$\Psi(z)=-\gamma+\int_0<sup>1(1-x</sup>{z-1})\sum_{k=0}^\infty x<sup>k\mathrm{d}x=-\gamma+\int_0</sup>1\frac{1-x^{z-1}}{1-x}\mathrm{d}x$$</p><h1>$\rm{B}函数$</h1><p>  ${\rm{B}}$函数可通过第一类$Euler$积分定义：</p><p>$${\rm{B}}\left(p,q\right)=\int_0<sup>1x</sup>{p-1}(1-x)^{q-1}\mathrm{d}x,\quad p,q&gt;0$$</p><h2 id="简单性质-v2"><a class="header-anchor" href="#简单性质-v2">¶</a>简单性质</h2><ol><li>${\rm{B}}(p,q)={\rm{B}}(q,p)$</li><li>${\rm{B}}(p,q)=\displaystyle\frac{p-1}{p+q-1}{\rm{B}}(p-1,q)$</li><li>${\rm{B}}(p,q)=2\displaystyle\int_0<sup>\frac{\pi}{2}\cos</sup>{2p-1}\theta\sin^{2q-1}\theta\mathrm{d}\theta$</li><li>${\rm{B}}(p,q)=\displaystyle\int_0<sup>{+\infty}\frac{x</sup>{q-1}}{(1+x)^{p+q}}\mathrm{d}x$</li></ol><h2 id="与-gamma-函数的关系"><a class="header-anchor" href="#与-gamma-函数的关系">¶</a>与$\Gamma$函数的关系</h2><p>  设$p&gt;0,q&gt;0$则有${\rm{B}}(p,q)=\displaystyle\frac{\Gamma§\Gamma(q)}{\Gamma(p+q)}$</p><p>  <strong>证明:</strong>  由性质知</p><p>$$\Gamma§=2\int_0<sup>{+\infty}x</sup>{2p-1}e<sup>{-x</sup>2}\mathrm{d}x,\quad\Gamma(q)=2\int_0<sup>{+\infty}x</sup>{2q-1}e<sup>{-x</sup>2}\mathrm{d}x$$</p><p>令$D=\left{(x,y):0\leq x&lt;+\infty,0\leq y&lt;+\infty\right}$, 则有</p><p>$$\Gamma§\Gamma(q)=4\iint_Dx<sup>{2p-1}y</sup>{2q-1}e<sup>{-(x</sup>2+y^2)}\mathrm{d}x\mathrm{d}y$$</p><p>利用极坐标变换, 记$D_1=\displaystyle\left{(r,\theta):0&lt;r&lt;+\infty,0\leq\theta\leq\frac{\pi}{2}\right}$, 则有</p><p>$$\begin{array}{l}<br>\Gamma§\Gamma(q)&amp;=&amp;4\displaystyle\iint_{D1}r<sup>{2(p+q)-1}e</sup>{-r<sup>2}\cos</sup>{2p-1}\theta\sin^{2q-1}\theta\mathrm{d}r\mathrm{d}\theta\<br>&amp;=&amp;\displaystyle\left(2\int_0<sup>\frac{\pi}{2}\cos</sup>{2p-1}\theta\sin<sup>{2q-1}\theta\mathrm{d}\theta\right)\left(2\int_0</sup>{+\infty}r<sup>{2(p+q)-1}e</sup>{-r^2}\mathrm{d}r\right)\<br>&amp;=&amp;\displaystyle{\rm{B}}(p,q)\Gamma(p+q)<br>\end{array}$$</p><p>证毕.</p><hr><p>   <strong>(余元公式)</strong> 设$0&lt;p&lt;1$, 则有</p><p>$${\rm{B} }(p,1-p)=\Gamma§\Gamma(1-p)=\frac{\pi}{\sin p\pi}.$$</p><p>  <strong>证明:</strong>  由于${\rm{B}}(p,1-p)=\displaystyle\int_0<sup>\infty\frac{x</sup>{p-1}}{1+x}\mathrm{d}x$, 利用变量替换$x=\frac{1}{t}$有:</p><p>$$\int_1<sup>\infty\frac{x</sup>{p-1}}{1+x}\mathrm{d}x=\int_0<sup>1\frac{x</sup>{-p}}{1+x}\mathrm{d}x,$$</p><p>将$\displaystyle\frac{1}{1+x}$展开成幂级数, 从而有</p><p>$$\begin{array}{l}<br>{\rm{B} }(p,1-p)&amp;=&amp;\displaystyle\lim_{r\to1<sup>-}\int_0</sup>r\frac{x<sup>{p-1}+x</sup>{-p}}{1+x}\mathrm{d}x\<br>&amp;=&amp;\displaystyle\lim_{r\to1<sup>-}\int_0</sup>r\left[\sum_{k=0}<sup>\infty(-1)</sup>kx<sup>{k+p-1}+\sum_{k=0}</sup>\infty(-1)<sup>kx</sup>{k-p}\right]\mathrm{d}x\<br>&amp;=&amp;\displaystyle\lim_{r\to1<sup>-}\left[\sum_{k=0}</sup>\infty\frac{(-1)<sup>k}{k+p}r</sup>{k+p}+\sum_{k=0}<sup>\infty\frac{(-1)</sup>k}{k-p+1}r^{k-p+1}\right]\<br>&amp;=&amp;\displaystyle\sum_{k=0}<sup>\infty\frac{(-1)</sup>k}{k+p}+\sum_{k=0}<sup>\infty\frac{(-1)</sup>k}{k-p+1}\<br>&amp;=&amp;\displaystyle\frac{1}{p}+\sum_{k=1}<sup>\infty(-1)</sup>k\left(\frac{1}{k+p}+\frac{1}{p-k}\right)\<br>&amp;=&amp;\displaystyle\frac{1}{p}+\sum_{k=1}<sup>\infty(-1)</sup>k\frac{2p}{p<sup>2-k</sup>2}.<br>\end{array}$$</p><p>而$\cos px$的$Fourier$级数为</p><p>$$\cos px=\frac{\sin px}{\pi}\left[\frac{1}{p}+\sum_{k=1}<sup>\infty(-1)</sup>k\frac{2p}{p<sup>2-k</sup>2}\cos kx\right]$$</p><p>在$\left|x\right|\leq\pi$处处收敛, 令$x=0$即得</p><p>$${\rm{B}}(p,1-p)=\frac{1}{p}+\sum_{k=1}<sup>\infty(-1)</sup>k\frac{2p}{p<sup>2-k</sup>2}=\frac{\pi}{\sin p\pi}.$$</p><p>证毕.</p><p><strong>注</strong>:令$p=\displaystyle\frac{1}{2}$, 得<br>$$\Gamma^2\left(\frac{1}{2}\right)=\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma\left(\frac{1}{2}\right)}{\Gamma(1)}={\rm{B}}(\frac{1}{2},\frac{1}{2})=\pi$$<br>则$\displaystyle\int_0^\infty e<sup>{-x</sup>2}\mathrm{d}x=\frac{1}{2}\Gamma\left(\frac{1}{2}\right)=\frac{\sqrt\pi}{2}$, 也是一个得到这个重要等式的方法.</p><hr><p>  求$\Bbb{R}<sup>n$中单位球体$D:x_1</sup>2+x_2^2+\cdots x_n^2\leq1$的体积.</p><p>   <strong>分析:</strong> 考虑用与球面类似的换元求解</p><p>   <strong>解:</strong> 由$n$重积分的集合意义, 所求体积为</p><p>$$V=\iint\cdots\int_D\mathrm{d}x_1\mathrm{d}x_2\cdots\mathrm{d}x_n.$$</p><p>作变换</p><p>$$\begin{cases}<br>x_1&amp;=&amp;r\cos\theta_1,\<br>x_2&amp;=&amp;r\sin\theta_1\cos\theta_2\<br>x_3&amp;=&amp;r\sin\theta_1\sin\theta_2\cos\theta_3\<br>\cdots\cdots\<br>x_{n-1}&amp;=&amp;r\sin\theta_1\sin\theta_2\cdots\sin\theta_{n-2}\cos\theta_{n-1}\<br>x_{n}&amp;=&amp;r\sin\theta_1\sin\theta_2\cdots\sin\theta_{n-2}\sin\theta_{n-1}<br>\end{cases}$$</p><p>其中$\quad 0&lt;r&lt;1, 0&lt;\theta_1,\cdots,\theta_{n-2}&lt;\pi,0&lt;\theta_{n-1}&lt;2\pi$, 则其$Jacobian$行列式</p><p>$$\displaystyle\frac{\partial(x_1,x_2,\cdots,x_n)}{\partial(r,\theta_1,\theta_2,\cdots,\theta_{n-1})}=r<sup>{n-1}\sin</sup>{n-2}\theta_1\sin^{n-3}\theta_2\cdots\sin\theta_{n-2}$$</p><p>由此</p><p>$$\begin{array}{l}<br>V &amp;=&amp; \displaystyle\iint\cdots\int_D\mathrm{d}x_1\mathrm{d}x_2\cdots\mathrm{d}x_n\<br>&amp;=&amp; \displaystyle\int_0<sup>{2\pi}\mathrm{d}\theta_{n-1}\int_0</sup>\pi\mathrm{d}\theta_{n-2}\cdots\int_0<sup>\pi\mathrm{d}\theta_1\int_0</sup>1r<sup>{n-1}\sin</sup>{n-2}\theta_1\sin^{n-3}\theta_2\cdots\sin\theta_{n-2}\mathrm{d}r\<br>&amp;=&amp; \displaystyle\frac{2\pi}{n}\left(\int_0<sup>\pi\sin</sup>{n-2}\theta_1\mathrm{d}\theta_1\right)\left(\int_0<sup>\pi\sin</sup>{n-3}\theta_2\mathrm{d}\theta_2\right)\cdots\left(\int_0^\pi\sin\theta_{n-2}\mathrm{d}\theta_{n-2}\right)\<br>&amp;=&amp; \displaystyle\frac{2\pi}{n}{\rm{B}}\left(\frac{1}{2}, \frac{n-1}{2}\right){\rm{B}}\left(\frac{1}{2},\frac{n-2}{2}\right)\cdots{\rm{B}}\left(\frac{1}{2},1\right)\<br>&amp;=&amp; \displaystyle\frac{2\pi}{n}\cdot\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma\left(\frac{n-1}{2}\right)}{\displaystyle\Gamma\left(\frac{n}{2}\right)}\cdot\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma\left(\frac{n-2}{2}\right)}{\displaystyle\Gamma\left(\frac{n-1}{2}\right)}\cdots\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma(1)}{\displaystyle\Gamma\left(\frac{3}{2}\right)}\<br>&amp;=&amp; \displaystyle\frac{2\pi}{n}\cdot\frac{\displaystyle\Gamma^{n-2}\left(\frac{1}{2}\right)}{\displaystyle\Gamma\left(\frac{n}{2}\right)}\<br>&amp;=&amp; \displaystyle\frac{\displaystyle\pi^{\frac{n}{2}}}{\displaystyle\Gamma\left(\frac{n}{2}+1\right)}.<br>\end{array}$$</p><h1>$\zeta函数$</h1><p>  <strong>$Riemann\ zeta$</strong> 函数$\zeta(s)$, 是一个关于复数$s$的函数, 在在复平面上, $s$的实数部分$\sigma=\scr{R}s&gt;1$时, $\zeta(s)=\displaystyle\sum_{n=1}<sup>\infty\frac{1}{n</sup>s}$</p><h2 id="特殊点取值"><a class="header-anchor" href="#特殊点取值">¶</a>特殊点取值</h2><p>  考虑调和级数$\zeta(1)=\displaystyle\sum_{i=1}^\infty\frac{1}{n}$, 由$Cauchy$判别法, 级数$S_n$收敛当且仅当$\forall \epsilon&gt;0, \exists N, st.\ m,n&gt;N, \left|S_m-S_n\right|&lt;\epsilon$</p><p>$$\left|S_{2n}-S_n\right|=\frac{1}{n+1}+\cdots+\frac{1}{2n}&gt;\frac{1}{2n}+\cdots+\frac{1}{2n}=\frac{1}{2}$$</p><p>故调和级数发散</p><p><strong>$Parseval$等式</strong></p><p>$$\frac{1}{\pi}\int_{-\pi}<sup>\pi\left|f(x)\right|</sup>2=\frac{a_0<sup>2}{2}+\sum_{n=1}</sup>\infty(a_n<sup>2+b_n</sup>2)$$</p><p>$\displaystyle\sum_{n=1}<sup>\infty\frac{1}{n</sup>2}=\frac{\pi^2}{6}$</p><p>$\displaystyle\sum_{n=1}<sup>\infty\frac{1}{n</sup>4}=\frac{\pi^4}{90}$</p><hr><p>  $zeta$函数的积分形式<br>$$\zeta(s)=\sum_{n=1}<sup>\infty\frac{1}{n</sup>{s}}=\frac{1}{\Gamma(s)}\int_0<sup>\infty\frac{x</sup>{s-1}}{e^x-1}\mathrm{d}x,\quad s&gt;1$$</p><p>  <strong>证:</strong> 对$x\gt0$有展开式</p><p>$$\begin{array}{l}<br>\displaystyle\frac{1}{e<sup>x-1}&amp;=&amp;\displaystyle\frac{e</sup>{-x} }{1-e^{-x} }\<br>&amp;=&amp;\displaystyle e<sup>{-x}(1+e</sup>{-x}+e<sup>{-2x}+\cdots)=\sum_{n=1}</sup>\infty e^{-nx}<br>\end{array}$$</p><p>于是$\forall A\gt0$有</p><p>$$\int_0<sup>A\frac{x</sup>{s-1} }{e<sup>x-1}\mathrm{d}x=\int_0</sup>Ax<sup>{s-1}\left(\sum_{n=1}</sup>\infty e^{-nx}\right)\mathrm{d}x$$</p><p>对于固定的$s&gt;1$, 级数$\sum\limits_{n=1}^\infty x<sup>{s-1}e</sup>{-nx}$关于$x\in[0,+\infty)$是一致收敛的, 所以</p><p>$$\begin{array}{l}<br>\displaystyle\int_0<sup>A\frac{x</sup>{s-1} }{e<sup>x-1}\mathrm{d}x&amp;=&amp;\displaystyle\sum_{n=1}</sup>\infty\int_0^A x<sup>{s-1}e</sup>{-nx}\mathrm{d}x\<br>&amp;=&amp;\displaystyle\int_0<sup>{nA}\left(\frac{y}{n}\right)</sup>{s-1}\left(\frac{e^{-y} }{n}\right)\mathrm{d}y\<br>&amp;=&amp;\displaystyle\sum_{n=1}<sup>\infty\frac{1}{n</sup>s}\int_0<sup>{nA}y</sup>{s-1}e^{-y}\mathrm{d}y<br>\end{array}$$</p><p>该级数对于$A\in[0,\infty)$是一致收敛的, 于是令$A\to\infty$, 得</p><p>$$\int_0<sup>\infty\frac{x</sup>{s-1} }{e<sup>x-1}\mathrm{d}x=\Gamma(s)\sum_{n=1}</sup>\infty\frac{1}{n^s}$$</p><hr><p>  求$\displaystyle\int_0^1\frac{\ln x}{1-x}\mathrm{d}x$</p><p>   <strong>解:</strong> 令$x=e^{-t},$ 则<br>$$\int_0^1\frac{\ln x}{1-x}\mathrm{d}x=\int_{+\infty}<sup>0\frac{-t}{1-e</sup>{-t}}e<sup>{-t}(-\mathrm{d}t)=-\int_0</sup>{+\infty}\frac{t}{e^t-1}\mathrm{d}t$$</p><p>在结论中取$s=2$, 则</p><p>$$\int_0^1\frac{\ln x}{1-x}\mathrm{d}x=-\Gamma(2)\sum_{n=1}<sup>{\infty}\frac{1}{n</sup>2}=-\frac{\pi^2}{6}$$</p><h1>习题</h1><ol><li>计算级数$\displaystyle\sum_{n=1}^\infty\frac{1}{n\binom{2n}{n}}$的和。</li></ol><p>  <strong>解:</strong> 利用${\rm{B} }(p,q)=\frac{\Gamma§\Gamma(q)}{\Gamma(p+q)}$得</p><p>$$\begin{array}{l}<br>\displaystyle\sum_{n=1}^\infty\frac{1}{n\binom{2n}{n} }&amp;=&amp;\displaystyle\sum_{n=1}^\infty\frac{1}{n}\frac{n!n!}{(2n)!}\<br>&amp;=&amp;\displaystyle\sum_{n=1}^\infty\frac{\Gamma(n)\Gamma(n+1)}{\Gamma(2n+1)}\<br>&amp;=&amp;\displaystyle\sum_{n=1}^\infty{\rm{B} }(n+1,n)\<br>&amp;=&amp;\displaystyle\sum_{n=1}<sup>\infty\int_0</sup>1t<sup>n(1-t)</sup>{n-1}\mathrm{d}t<br>\end{array}$$</p><p>由于当$0\le t\le 1$时, $0\le t(1-t)\le\frac{1}{4}$, 所以</p><p>$$0\le t<sup>n(1-t)</sup>{n-1}\le\left(\frac{1}{4}\right)^{n-1}$$</p><p>因此级数$\displaystyle\sum_{n=1}^\infty t<sup>n(1-t)</sup>{n-1}$在$[0,1]$一致收敛, 于是有</p><p>$$\begin{array}{l}<br>\displaystyle\sum_{n=1}^\infty\frac{1}{n\binom{2n}{n} }&amp;=&amp;\displaystyle\int_0<sup>1\sum_{n=1}</sup>\infty t<sup>n(1-t)</sup>{n-1}\mathrm{d}t\<br>&amp;=&amp;\displaystyle\int_0<sup>1t\sum_{n=1}</sup>\infty(t(1-t))^{n-1}\mathrm{d}t\<br>&amp;=&amp;\displaystyle\int_0^1\frac{t}{1-t(1-t)}\mathrm{d}t\<br>&amp;=&amp;\displaystyle\int_0<sup>1\frac{t}{t</sup>2-t+1}\mathrm{d}t\<br>&amp;=&amp;\displaystyle\frac{\pi}{3\sqrt{3}}<br>\end{array}$$</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反演原理及应用</title>
      <link href="/Algorithm/Theory-of-Inversion/"/>
      <url>/Algorithm/Theory-of-Inversion/</url>
      
        <content type="html"><![CDATA[<h1>什么是反演</h1><p>  对于数列$\left{f_n\right}$以及数列$\left{g_n\right}$满足</p><p>$$g_n=\sum_{i=0}^na_{ni}f_i \tag{1}$$</p><p>  反演便是利用$\left{g_n\right}$反推出$\left{f_n\right}$, 也即</p><p>$$f_n=\sum_{i=0}^nb_{ni}g_i \tag{2}$$</p><p>  本质上来说这是一个反解线性方程组的过程, 但观察后会发现整个方程组是一个下三角矩阵, 可以思考出更加快捷的方法</p><a id="more"></a> <h1>反演原理</h1><p>  为了便于后面的叙述, 首先引入$\delta(i,j)$函数$(Kronecker’s\ delta)$, 它的定义为</p><p>$$\delta\left(i,j\right)=\begin{cases}1\quad i=j\0\quad i\neq j\end{cases}\qquad(\text{也可记为}[i=j])$$</p><p>  下面考虑反演的过程, 考虑下面的式子应该满足什么条件</p><p>$$<br>\sum_{i=0}^nb_{ni}g_i=f_n \tag{3}<br>$$</p><p>$$<br>\begin{array}{l}<br>LHS&amp;=&amp;\displaystyle\sum_{i=0}^nb_{ni}g_i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>nb_{ni}\sum_{j=0}</sup>ia_{ij}f_j\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>nf_i\sum_{j=i}</sup>nb_{nj}a_{ji}<br>\end{array}<br>$$</p><p>  为了便于理解最后一步, 我们用矩阵进行表示</p><p>$$<br>\begin{bmatrix}<br>b_{n0}a_{00}f_0\<br>b_{n1}a_{10}f_0 &amp; b_{n1}a_{11}f_1\<br>b_{n2}a_{20}f_0 &amp; b_{n2}a_{21}f_1 &amp; b_{n2}a_{22}f_2\<br>\vdots &amp; \vdots &amp; \ddots \<br>b_{nn}a_{n0}f_0 &amp; b_{nn}a_{n1}f_1 &amp; \cdots &amp; b_{nn}a_{nn}f_n<br>\end{bmatrix}<br>$$</p><p>  前一个是<strong>对行</strong>进行, 再将行加起来, 后一个是<strong>对列</strong>进行, 再将列加起来</p><p>  因此, 式$(3)$成立的条件等价于</p><p>$$\sum_{j=i}^nb_{nj}a_{ji}=\delta(n,i) \tag{4}$$</p><p>  同理, 将$f$代入带$g$的求和式中, 可以推出</p><p>$$\sum_{j=i}^na_{nj}b_{ji}=\delta(n,i) \tag{5}$$</p><p>  如果某个数列满足上面的条件, 我们便阔以利用反演公式</p><h1>二项式反演</h1><h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2><p>  二项式反演$(binomial\ inversion)$在容斥中经常用到, 可以表示为</p><p>$$<br>f_n=\sum_{i=0}<sup>n\left(-1\right)</sup>n\begin{pmatrix}n\i\end{pmatrix}g_i\Leftrightarrow<br>g_n=\sum_{i=0}<sup>n\left(-1\right)</sup>n\begin{pmatrix}n\i\end{pmatrix}<br>f_i \tag{6}<br>$$</p><p>  可以写成另一种常见形式</p><p>$$<br>f_n=\sum_{i=0}^n\begin{pmatrix}n\i\end{pmatrix}g_i\Leftrightarrow<br>g_n=\sum_{i=0}<sup>n\left(-1\right)</sup>{n-i}\begin{pmatrix}n\i\end{pmatrix}f_i \tag{7}<br>$$</p><p><strong>证明:</strong></p><p>$$\begin{array}{l}<br>g_n&amp;=&amp;\displaystyle\sum_{i=0}<sup>n\left(-1\right)</sup>{n-i}\begin{pmatrix}n\i\end{pmatrix}f_i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>n\left(-1\right)</sup>{n-i}\begin{pmatrix}n\i\end{pmatrix}\sum_{j=0}^i\begin{pmatrix}i\j\end{pmatrix}g_j\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>ng_i\sum_{j=i}</sup>n\begin{pmatrix}n\j\end{pmatrix}\begin{pmatrix}j\i\end{pmatrix}\left(-1\right)^{n-j}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>ng_i\sum_{j=i}</sup>n\begin{pmatrix}n\i\end{pmatrix}\begin{pmatrix}n-i\j-i\end{pmatrix}\left(-1\right)^{n-j}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>ng_i\begin{pmatrix}n\i\end{pmatrix}\sum_{j=0}</sup>{n-i}\begin{pmatrix}n-i\j\end{pmatrix}\left(-1\right)^{n-i-j}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>ng_i\begin{pmatrix}n\i\end{pmatrix}\left(1-1\right)</sup>{n-i}\<br>&amp;=&amp;g_n<br>\end{array}$$</p><h2 id="应用"><a class="header-anchor" href="#应用">¶</a>应用</h2><ul><li>错位排列</li></ul><p>  对于长度为$n$的序列${a_i}$, 求所有满足$1\leq i\leq n$, 使得$a_i\neq i$的种类数</p><p>  一个高中生想到的常规方法可能是利用递推, 记所求为$D_n$, $n$个错位排列按照第一位是$2,3,\cdots,n$分成$n-1$, 每个组排列个数一样多, 考虑其中一组, 不妨设第一位为$2$, 若第$2$位是$1$,有$D_{n-2}$种, 否则有$D_{n-1}$种, 结合$D_1=0,\ D_2=1$, 从而有</p><p>$$D_n=(n-1)(D_{n-1}+D_{n-2}) \tag{8}$$<br>$$D_n-nD_{n-1}=-\left(D_{n-1}-(n-1)D_{n-2}\right)=\cdots=(-1)^{n-2} \tag{9}$$<br>$$D_n=nD_{n-1}+(-1)<sup>n=\cdots=n!\sum_{i=0}</sup>n\frac{(-1)^i}{i!} \tag{10}$$</p><p>  回到正题, 我们有一个有意思的解法, 设$f_i$为恰好有$i$个位置是不变的排列, 那么<br>$$n!=\sum_{i=0}^n\begin{pmatrix}n\i\end{pmatrix}f_i \tag{11}$$<br>  可以看粗其形式和反演公式很像, 令$g_i=i!$, 有二项式反演<br>$$\begin{array}{l}<br>f_n&amp;=&amp;\displaystyle\sum_{i=0}<sup>n(-1)</sup>{n-i}\begin{pmatrix}n\i\end{pmatrix}g_i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>n(-1)</sup>{n-i}\frac{n!}{(n-i)!}\<br>&amp;=&amp;n!\displaystyle\sum_{i=0}<sup>n\frac{(-1)</sup>i}{i!}<br>\end{array}<br>$$</p><ul><li>染色问题</li></ul><p>  $n$个球排成一行, 有$m$种颜色, 每个球染一个颜色, 相邻两个球染不同颜色, 每种颜色至少使用一次, 求染色方案数</p><p>  不考虑每种颜色至少用一次这一条件, 那么答案显然是$m(m-1)^{n-1}$, 设$f_i$为恰好使用$i(i=0,1,2,\cdots,k)$种颜色的方案数, 那么</p><p>$$m(m-1)<sup>{n-1}=\sum_{i=0}</sup>m\begin{pmatrix}m\i\end{pmatrix}f_i \tag{12}$$</p><p>  经过反演得到</p><p>$$f_m=\sum_{i=0}<sup>m(-1)</sup>{m-i}\begin{pmatrix}m\i\end{pmatrix}g_i \tag{13}$$</p><p><a href="https://bzoj.zcmimi.tk/p/2839.html" target="_blank" rel="noopener">$BZOJ2839$:集合计数</a></p><p>  记$b_i$为交集有至少$i$个集合的个数, 枚举$i$个交集后, 共有$2^{n-i}$个互不相同的集合, 每个集合又有选与不选两种方案, 故$b_i=\begin{pmatrix}n\i\end{pmatrix}2<sup>{2</sup>{n-i}}$, 那么我们开始演了</p><p>$$b_k=\sum_{i=k}^n\begin{pmatrix}i\k\end{pmatrix}a_i\quad\Leftrightarrow\quad a_k=\sum_{i=k}<sup>n(-1)</sup>{n-k}\begin{pmatrix}i\k\end{pmatrix}b_i$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dec(i,l,r) for(int i=r;i&gt;=l;--i)</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(a,v) memset(a,v,sizeof(a))</span></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;</span><br><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    x = <span class="hljs-number">0</span>; ll f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch)) &#123;<span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(ch)) x = (x&lt;&lt;<span class="hljs-number">3</span>) + (x&lt;&lt;<span class="hljs-number">1</span>) + ch - <span class="hljs-string">'0'</span>, ch = getchar();</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, k, ans;</span><br><span class="line">ll fac[N], inv[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">power</span><span class="hljs-params">(ll a, ll b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    ll res = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (; b; a = a * a % MOD, b &gt;&gt;= <span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % MOD;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n, ll m)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> fac[n] * inv[m] % MOD * inv[n-m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    fac[<span class="hljs-number">0</span>] = inv[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    inc(i,<span class="hljs-number">1</span>,n) fac[i] = (ll)fac[i<span class="hljs-number">-1</span>] * i % MOD, p[i] = (ll)p[i<span class="hljs-number">-1</span>] * <span class="hljs-number">2</span> % (MOD - <span class="hljs-number">1</span>);</span><br><span class="line">    inv[n] = power(fac[n], MOD - <span class="hljs-number">2</span>);</span><br><span class="line">    dec(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>) inv[i] = (ll)inv[i+<span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % MOD;</span><br><span class="line">    inc(i,k,n) &#123;</span><br><span class="line">        (ans += MOD + ((i-k) &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * (C(i,k) * C(n,i) % MOD * (power(<span class="hljs-number">2</span>, p[n-i]) % MOD))) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>斯特林反演</h1><h2 id="原理-v2"><a class="header-anchor" href="#原理-v2">¶</a>原理</h2><p>  在这里, 先回顾一下斯特林数($dalao$请自动忽略)</p><ul><li><strong>第一类斯特林数</strong></li></ul><p>  <strong>定义:</strong> 将$n$个元素排成$m$个轮换的方法数</p><p>  从$n-1$的情况推过来, 要么将最后一个元素放进自身的轮换, 要么将最后一个元素放进前$n-1$个元素分成的$\begin{bmatrix}n-1\m\end{bmatrix}$个轮换中的一个, 可以得到:</p><p>$$\begin{bmatrix}n\m\end{bmatrix}=\begin{bmatrix}n-1\m-1\end{bmatrix}+(n-1)*\begin{bmatrix}n-1\m\end{bmatrix} \tag{14}$$</p><p>  由于$\begin{bmatrix}n\<br>k\end{bmatrix}$是$n$个元素恰好包含$k$个轮换的排列个数, 对所有的$k$求和, 必然得到排列的总数</p><p>$$\sum_{k=0}^n\begin{bmatrix}n\<br>k\end{bmatrix}=n! \tag{15}$$</p><p>  下面是与下降幂$x<sup>{\underline{n}}$和阶乘幂$x</sup>{\overline{n}}$的关系</p><p>$$x<sup>{\underline{n}}=\sum_{i=0}</sup>n\begin{bmatrix}n\i\end{bmatrix}(-1)<sup>{n-i}x</sup>i \tag{16}$$</p><p>  用归纳法证明</p><p>$$\begin{array}{l}<br>x<sup>{\underline{n+1}}&amp;=&amp;(x-n)x</sup>{\underline{n}}\<br>&amp;=&amp;(x-n)\displaystyle\sum_{i=0}<sup>n\begin{bmatrix}n\i\end{bmatrix}(-1)</sup>{n-i}x^i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>n\begin{bmatrix}n\i\end{bmatrix}(-1)</sup>{n-i}x<sup>{i+1}-n\sum_{i=0}</sup>{n+1}\begin{bmatrix}n\i\end{bmatrix}(-1)<sup>{n-i}x</sup>i\<br>&amp;=&amp;\displaystyle\sum_{i=1}<sup>{n+1}\begin{bmatrix}n\i-1\end{bmatrix}(-1)</sup>{n-i+1}x<sup>{i}+n\sum_{i=0}</sup>{n+1}\begin{bmatrix}n\i\end{bmatrix}(-1)<sup>{n-i+1}x</sup>i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>{n+1}\left(\begin{bmatrix}n\i-1\end{bmatrix}+n\begin{bmatrix}n\i\end{bmatrix}\right)(-1)</sup>{n-i+1}x^i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>{n+1}\begin{bmatrix}n+1\i\end{bmatrix}(-1)</sup>{n+1-i}x^i<br>\end{array}$$</p><p>  类似可以证明</p><p>$$x<sup>{\overline{n}}=\sum_{i=0}</sup>n\begin{bmatrix}n\i\end{bmatrix}x^i \tag{17}$$</p><ul><li><strong>第二类斯特林数</strong></li></ul><p>  <strong>定义:</strong> 将一个有$n$件物品的集合划分成$m$个非空子集的方法数</p><p>  从$n-1$的情况推过来, 要么将最后一个元素单独放一类, 要么与前$n-1$个元素的某个非空子集放一起, 可以得到:</p><p>$$\begin{Bmatrix}n\m\end{Bmatrix}=\begin{Bmatrix}n-1\m-1\end{Bmatrix}+m*\begin{Bmatrix}n-1\m\end{Bmatrix} \tag{18}$$</p><p>  下面是与下降幂$x<sup>{\underline{n}}$和阶乘幂$x</sup>{\overline{n}}$的关系</p><p>$$m<sup>n=\sum_{i=0}</sup>n\begin{Bmatrix}n\i\end{Bmatrix}m^{\underline{i}} \tag{19}$$</p><p>  用归纳法证明, 由于$x*x<sup>{\underline{i}}=x</sup>{\underline{i+1}}+ix^{\underline{i}}$</p><p>$$\begin{array}{l}<br>m<sup>{n+1}&amp;=&amp;m\displaystyle\sum_{i=0}</sup>n\begin{Bmatrix}n\i\end{Bmatrix}m^{\underline{i}}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>n\begin{Bmatrix}n\i\end{Bmatrix}m</sup>{\underline{i+1}}+\sum_{i=0}<sup>n\begin{Bmatrix}n\i\end{Bmatrix}im</sup>{\underline{i}}\<br>&amp;=&amp;\displaystyle\sum_{i=1}<sup>{n+1}\begin{Bmatrix}n\i-1\end{Bmatrix}m</sup>{\underline{i}}+\sum_{i=0}<sup>{n+1}\begin{Bmatrix}n\i\end{Bmatrix}im</sup>{\underline{i}}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>{n+1}\left(\begin{Bmatrix}n\i-1\end{Bmatrix}+i\begin{Bmatrix}n\i\end{Bmatrix}\right)m</sup>{\underline{i}}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>{n+1}\begin{Bmatrix}n+1\i\end{Bmatrix}m</sup>{\underline{i}}<br>\end{array}$$</p><p>  类似可以证明</p><p>$$m<sup>n=\sum_{i=0}</sup>n\begin{Bmatrix}n\i\end{Bmatrix}(-1)<sup>{n-i}m</sup>{\overline{i}} \tag{20}$$</p><p>  当然还有两个比较显然的东西</p><p>$$x<sup>{\underline{n}}=(-1)(-x)</sup>{\overline{n}} \tag{21}$$<br>$$x<sup>{\overline{n}}=(-1)(-x)</sup>{\underline{n}} \tag{22}$$</p><ul><li><strong>反转公式</strong></li></ul><p>$$\sum_{k=m}<sup>n(-1)</sup>{n-k}\begin{bmatrix}n\k\end{bmatrix}\begin{Bmatrix}k\m\end{Bmatrix}=[m=n] \tag{23}$$</p><p>$$\sum_{k=m}<sup>n(-1)</sup>{n-k}\begin{Bmatrix}n\k\end{Bmatrix}\begin{bmatrix}k\m\end{bmatrix}=[m=n] \tag{24}$$</p><p>$proof\ 1:$</p><p>$$\begin{array}{l}<br>m<sup>{\underline{n}}&amp;=&amp;\displaystyle\sum_{i=0}</sup>n\begin{bmatrix}n\i\end{bmatrix}(-1)<sup>{n-i}m</sup>i\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>n\begin{bmatrix}n\i\end{bmatrix}(-1)</sup>{n-i}\sum_{j=0}<sup>i\begin{Bmatrix}i\j\end{Bmatrix}m</sup>{\underline{j}}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>nm</sup>{\underline{i}}\sum_{j=i}<sup>n(-1)</sup>{n-j}\begin{bmatrix}n\j\end{bmatrix}\begin{Bmatrix}j\i\end{Bmatrix}<br>\end{array}$$</p><p>$proof\ 2:$</p><p>$$\begin{array}{l}<br>m<sup>n&amp;=&amp;\displaystyle\sum_{i=0}</sup>n\begin{Bmatrix}n\i\end{Bmatrix}m^{\underline{i}}\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>n\begin{Bmatrix}n\i\end{Bmatrix}\sum_{j=0}</sup>i(-1)<sup>{i-j}\begin{bmatrix}i\j\end{bmatrix}m</sup>j\<br>&amp;=&amp;\displaystyle\sum_{i=0}<sup>nm</sup>i\sum_{j=i}<sup>n(-1)</sup>{n-j}\begin{Bmatrix}n\j\end{Bmatrix}\begin{bmatrix}j\i\end{bmatrix}<br>\end{array}$$</p><ul><li><strong>斯特林反演</strong></li></ul><p>$$f(n)=\sum_{i=0}^n\begin{Bmatrix}n\k\end{Bmatrix}g(k) \quad\Leftrightarrow\quad g(n)=\sum_{k=0}<sup>n(-1)</sup>{n-k}\begin{bmatrix}n\k\end{bmatrix}f(k) \tag{25}$$</p><p>  $(25)$的证明如下:</p><p>$$\begin{array}{l}<br>f(n)&amp;=&amp;\displaystyle\sum_{k=0}^n\begin{Bmatrix}n\k\end{Bmatrix}g(k)\<br>&amp;=&amp;\displaystyle\sum_{k=0}<sup>n\begin{Bmatrix}n\k\end{Bmatrix}\sum_{j=0}</sup>k(-1)^{k-j}\begin{bmatrix}k\j\end{bmatrix}f(j)\<br>&amp;=&amp;\displaystyle\sum_{k=0}<sup>n\sum_{j=k}</sup>n\begin{Bmatrix}n\j\end{Bmatrix}\begin{bmatrix}j\k\end{bmatrix}(-1)^{j-k}f(k)\<br>&amp;=&amp;\displaystyle\sum_{k=0}^n[k=n]f(k)\<br>&amp;=&amp;f(n)<br>\end{array}$$</p><h1>莫比乌斯反演</h1><h2 id="积性函数"><a class="header-anchor" href="#积性函数">¶</a>积性函数</h2><p>  函数 $f(n)$ 满足 $f(1)=1,\forall x,y\in \mathbb{N}^*,\gcd(x,y)=1$ 有 $f(xy)=f(x)f(y)$，$f(n)$ 为积性函数。</p><p>  仅去掉条件 $\gcd(x,y)=1$ 仍有 $f(xy)=f(x)f(y)$，则 $f(n)$ 为完全积性函数。</p><h3 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h3><p>若 $f(x)$ 和 $g(x)$ 均为积性函数，下列函数也为积性函数:</p><p>$$f(x<sup>p), f</sup>p(x),\ f(x)g(x),\ \sum_{d|x}f(d)g(\frac{x}{d})$$</p><p>设 $x=\prod p_i^{k_i}$</p><p>若 $F(x)$ 为积性函数，则有 $F(x)=\prod F(p_i^{k_i})$</p><p>若 $F(x)$ 为完全积性函数，则有 $F(x)=\prod F(p_i)^{k_i}$</p><h3 id="一些例子"><a class="header-anchor" href="#一些例子">¶</a>一些例子</h3><ul><li>单位函数 $\varepsilon(n)=[n=1]$ (完全积性)</li><li>恒等函数 $\operatorname{id}_k(n)=n^k\operatorname{id}_1(n)$ 通常简记为 $\operatorname{id}(n)$ (完全积性)</li><li>常数函数 $1(n)=1$ (完全积性)</li><li>除数函数 $\displaystyle\sigma_k(n)=\sum_{d|n}d^k\sigma_0(n)$ 通常简记为 $\operatorname{d}(n)$ 或 $\tau(n)$，$\sigma_1(n)$ 通常简记作 $\sigma(n)$</li><li>欧拉函数 $\displaystyle\varphi(n)=\sum_{i=1}^n[\gcd(i,n)=1]$</li><li>莫比乌斯函数 $\displaystyle\mu(n)=\begin{cases}1\quad n=1,\(-1)^k\quad n=p_1p_2\cdots p_k,\0\quad otherwise\end{cases}$，$p_i$ 为互异素数</li></ul><h2 id="dirichlet-卷积"><a class="header-anchor" href="#dirichlet-卷积">¶</a>Dirichlet 卷积</h2><p><strong>定义</strong> 两个数论函数的 Dirichlet 卷积</p><p>$$(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})$$</p><h3 id="性质-v2"><a class="header-anchor" href="#性质-v2">¶</a>性质</h3><ul><li>交换律 $f<em>g=g</em>f$</li><li>结合律 $(f<em>g)<em>h=f</em>(g</em>h)$</li><li>分配律 $f*(g+h)=f<em>g+f</em>h$</li><li>$f*\varepsilon=f$，其中 $\varepsilon$ 为 Dirichlet 卷积的单位元</li></ul><h3 id="一些例子-v2"><a class="header-anchor" href="#一些例子-v2">¶</a>一些例子</h3><p>$$\varepsilon=\mu<em>1\Leftrightarrow\varepsilon(n)=\sum_{d|n}\mu(d)$$<br>$$d=1</em>1\Leftrightarrow d(n)=\sum_{d|n}1$$<br>$$\sigma=\operatorname{id}<em>1\Leftrightarrow\sigma(n)=\sum_{d|n}d$$<br>$$\varphi=\mu</em>\operatorname{id}\Leftrightarrow\sum_{d|n}d\cdot\mu(\frac{n}{d})$$</p><h2 id="原理-v3"><a class="header-anchor" href="#原理-v3">¶</a>原理</h2><p>  <strong>莫比乌斯函数$\mu(m)$</strong> 对所有整数$m\geq1由等式$</p><p>$$\sum_{d|m}\mu(d)=\left[m=1\right] \tag{26}$$</p><p>来定义, 这个等式是一个递归式, 代入$m=1,2,\cdots,12$可以得到前$12$个值:</p><table><thead><tr><th style="text-align:center">$m$</th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th><th style="text-align:center">$9$</th><th style="text-align:center">$10$</th><th style="text-align:center">$11$</th><th style="text-align:center">$12$</th></tr></thead><tbody><tr><td style="text-align:center">$\mu(m)$</td><td style="text-align:center">$1$</td><td style="text-align:center">$-1$</td><td style="text-align:center">$-1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$-1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$-1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$-1$</td><td style="text-align:center">$0$</td></tr></tbody></table><p>$$g(m)=\sum_{d|m}f(d)\quad\Leftrightarrow\quad f(m)=\sum_{d|m}\mu(\frac{m}{d})g(d) \tag{27}$$</p><p>  $(27)$的证明如下:<br>$$\begin{array}{l}<br>g(m)&amp;=&amp;\displaystyle\sum_{d|m}f(d)\<br>&amp;=&amp;\displaystyle\sum_{d|m}\sum_{k|d}\mu(\frac{d}{k})g(k)\<br>&amp;=&amp;\displaystyle\sum_{k|m}g(k)\sum_{d|m,k|d}\mu(\frac{d}{k})\<br>&amp;=&amp;\displaystyle\sum_{k|m}g(k)\sum_{d|(m/k)}\mu(d)\<br>&amp;=&amp;\displaystyle\sum_{k|m}[m/k=1]g(k)\<br>&amp;=&amp;g(m)<br>\end{array}$$</p><p>  若 d 包含平方因子，则 $\mu(d)=0$</p><p>  若 d 不包含平方因子，即$p=p_1p_2\cdots p_k$，$p_i$ 均为互异素数，则 $\mu(d)=(-1)^k$</p><p>  $\forall n\in\mathbb{N}^*$，有 $\displaystyle\sum_{d|n}\frac{\mu(d)}{d}=\frac{\varphi(n)}{n}$</p><p>线性筛求莫比乌斯函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));</span><br><span class="line">    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!vis[i]) &#123; </span><br><span class="line">            prime[++tot] = i;</span><br><span class="line">            mu[i] = <span class="hljs-number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt; N; ++j) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板</title>
      <link href="/Algorithm/Algorithm-template/"/>
      <url>/Algorithm/Algorithm-template/</url>
      
        <content type="html"><![CDATA[<h1>基础</h1><h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2><h3 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> ;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    mergesort(l, mid);</span><br><span class="line">    mergesort(mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">    <span class="hljs-keyword">int</span> p = l, q = mid + <span class="hljs-number">1</span>, cnt = l;</span><br><span class="line">    <span class="hljs-keyword">while</span>(p &lt;= mid &amp;&amp; q &lt;= r)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(a[p] &lt; a[q]) t[cnt++] = a[p++];</span><br><span class="line">        <span class="hljs-keyword">else</span> t[cnt++] = a[q++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span>(p &lt;= mid) t[cnt++] = a[p++];</span><br><span class="line">    <span class="hljs-keyword">while</span>(q &lt;= r) t[cnt++] = a[q++];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r; ++i) a[i] = t[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vis[x] = <span class="hljs-number">-1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y : G[x]) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (vis[y] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在环</span></span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[y] &amp;&amp; !dfs(y)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="hljs-number">1</span>;</span><br><span class="line">a[++cnt] = x;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a class="header-anchor" href="#拓扑排序">¶</a>拓扑排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> head[N], nxt[N], ver[N], deg[N], tot, cnt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y;</span><br><span class="line">    nxt[tot] = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">    deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="hljs-keyword">if</span> (!deg[i]) q.push(i);</span><br><span class="line">    <span class="hljs-keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        a[++cnt] = x;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> y = ver[i];</span><br><span class="line">            <span class="hljs-keyword">if</span> (--deg[y] == <span class="hljs-number">0</span>) q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学"><a class="header-anchor" href="#数学">¶</a>数学</h2><h3 id="素数"><a class="header-anchor" href="#素数">¶</a>素数</h3><ul><li>$Eratosthenes$筛法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//O(nloglogn)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (v[i]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        p[++cnt] = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N / i; ++j) v[i*j] = <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线性筛法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//O(n)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!v[i]) p[++cnt] = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; p[j] * i &lt; N; ++j) &#123;</span><br><span class="line">            v[i*p[j]] = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧几里得"><a class="header-anchor" href="#欧几里得">¶</a>欧几里得</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a / gcd(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得"><a class="header-anchor" href="#扩展欧几里得">¶</a>扩展欧几里得</h3><p>  在求出$gcd(a,b)$的同时求出二元一次不定方程$ax+by=gcd(a,b)$的一组整数解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!b) x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        exgcd(b, a % b, x, y);</span><br><span class="line">        y -= a / b * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘法逆元"><a class="header-anchor" href="#乘法逆元">¶</a>乘法逆元</h3><p><a href="https://www.luogu.com.cn/problem/P3811" target="_blank" rel="noopener">模板题</a></p><ul><li>拓欧</li></ul><p>  若 $a\cdot x\equiv1{\pmod b}$，$a$ 与 $b$ 互质，则 $x$ 为 $a$ 的逆元，记为 $a^{-1}$，也称 $x$ 为 $a$ 在 $\mathrm{mod}\ b$ 下的倒数。</p><p>  利用拓欧求解 $a\cdot x\equiv1{\pmod b}$ 转化为求解 $a\cdot x+b\cdot y = 1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!b) x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">else</span> exgcd(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exgcd(i, p, x, y);</span><br><span class="line">x = (x % p + p) % p;</span><br></pre></td></tr></table></figure><ul><li>费马小定理</li></ul><p>  若 $p$ 为素数，$a$ 为正整数，且 $a$、$p$ 互质，则 $a^{p-1}\equiv1{\pmod p}$</p><p>  对于 $a\cdot x\equiv1\pmod p$，有 $a\cdot x\equiv a^{p-1}\pmod p$，即 $x\equiv a^{p-2}\pmod p$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll b, ll MOD)</span> </span>&#123;</span><br><span class="line">ll res = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, (a *= a) %= MOD)</span><br><span class="line"><span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) (res *= a) %= MOD;</span><br><span class="line"><span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>), x = -x;</span><br><span class="line"><span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>) write(x / <span class="hljs-number">10</span>);</span><br><span class="line"><span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> ^ <span class="hljs-number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write(qpow(i, p - <span class="hljs-number">2</span>, p)), <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);</span><br></pre></td></tr></table></figure><ul><li>线性方法</li></ul><p>  要求一串数字对 $\mathrm{mod}\ p$ 的逆元，设 $p=k\cdot i+r\quad(1\lt r\lt i\lt p)$，则</p><p>$$k\cdot i+r\equiv0\pmod p$$</p><p>乘 $i<sup>{-1},r</sup>{-1}$ 移项得</p><p>$$i^{-1}\equiv-k\cdot r^{-1}\pmod p$$</p><p>$$i<sup>{-1}\equiv-\lfloor\frac{p}{i}\rfloor\cdot(p \mathrm{mod} i)</sup>{-1} \pmod p$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)</span><br><span class="line">inv[i] = (p - p / i) * inv[p % i] % p;</span><br></pre></td></tr></table></figure><ul><li>阶乘逆元 $O(n)$</li></ul><p>若 $inv[i]=\frac{1}{(i+1)!}$，则 $inv[i+1]\times(i+1)=inv[i]$</p><p>$$\frac{1}{i!}\times(i-1)!\equiv\frac{1}{i}\pmod p$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">f[i] = (f[i<span class="hljs-number">-1</span>] * i) % p;</span><br><span class="line">inv[n] = qpow(f[n], p - <span class="hljs-number">2</span>, p);</span><br><span class="line"><span class="hljs-keyword">for</span> (ll i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i)</span><br><span class="line">inv[i] = (inv[i+<span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>)) % p;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, (inv[i] * f[i<span class="hljs-number">-1</span>]) % p);</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a class="header-anchor" href="#欧拉函数">¶</a>欧拉函数</h3><p>  我们知道$\varphi(n)$表示小于$n$且与$n$互素的整数个数, 而$n$可分解为$n=\displaystyle\prod_{i=1}<sup>kp_i</sup>{a_i}$, 根据容斥原理我们有</p><p>$$\varphi(n)=\sum_{S\subseteq\left{p_1,p_2,\cdots,p_k\right}}(-1)^{|S|}\frac{n}{\displaystyle\prod_{p_i\in S}p_i}$$</p><p>  展开后可以得到</p><p>$$\varphi(n)=n*\prod_{i=1}^k\left(1-\frac{1}{p_i}\right)$$</p><ol><li>若$n$是素数 , 有$\varphi(n)=n−1$</li><li>若$gcd(n,m)=1$, 有$\varphi(mn)=\varphi(m)\varphi(n)$</li><li>若$n$和$m$是素数 , 有$\varphi(nm)=nm−1$</li><li>若$p$是素数 , 有$\varphi(p<sup>q)=p</sup>q−p^{q−1}$</li><li>$\displaystyle\sum_{d|m}\varphi(d)=m$</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//单个Euler函数值</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line"><span class="hljs-keyword">int</span> res = n;  </span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123; </span><br><span class="line">res -= res / i; </span><br><span class="line"><span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) res -= res / n; </span><br><span class="line"><span class="hljs-keyword">return</span> res;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//O(nlogn)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) phi[i] = i;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="hljs-keyword">if</span> (phi[i] == i)</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">phi[j] = phi[j] / i * (i - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h2><h3 id="并查集"><a class="header-anchor" href="#并查集">¶</a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (fa[x] == x) <span class="hljs-keyword">return</span> x;</span><br><span class="line">    <span class="hljs-keyword">int</span> root = find(fa[x]);</span><br><span class="line">    d[x] += d[fa[x]];</span><br><span class="line">    <span class="hljs-keyword">return</span> fa[x] = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="hljs-keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span>;</span><br><span class="line">    fa[fx] = fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图论"><a class="header-anchor" href="#图论">¶</a>图论</h2><h3 id="最短路"><a class="header-anchor" href="#最短路">¶</a>最短路</h3><h4 id="dijkstra"><a class="header-anchor" href="#dijkstra">¶</a>$dijkstra$</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> n, m, s;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N][N], d[N], pre[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        d[i] = INF; vis[i] = <span class="hljs-number">0</span>; pre[i] = <span class="hljs-number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = <span class="hljs-number">-1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; (x == <span class="hljs-number">-1</span> || d[j] &lt; d[x])) x = j;</span><br><span class="line">        vis[x] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">1</span>; y &lt;= n; ++y)</span><br><span class="line">            <span class="hljs-keyword">if</span> (d[y] &gt; d[x] + a[x][y]) &#123;</span><br><span class="line">                d[y] = d[x] + a[x][y];</span><br><span class="line">                pre[y] = x;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dijkstra-堆优化"><a class="header-anchor" href="#dijkstra-堆优化">¶</a>$dijkstra(堆优化)$</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> next, to, w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    e[++tot].w = z;</span><br><span class="line">    e[tot].next = head[x];</span><br><span class="line">    e[tot].to = y;</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    d[s] = <span class="hljs-number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="hljs-number">0</span>, s));</span><br><span class="line">    <span class="hljs-keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> y = e[i].to;</span><br><span class="line">            <span class="hljs-keyword">if</span> (d[y] &gt; d[x] + e[i].w) &#123;</span><br><span class="line">                d[y] = d[x] + e[i].w;</span><br><span class="line">                q.push(make_pair(-d[y], y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spfa"><a class="header-anchor" href="#spfa">¶</a>$spfa$</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(d));</span><br><span class="line">    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));</span><br><span class="line">    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; v[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    q.push(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        v[x] = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> y = ver[i];</span><br><span class="line">            <span class="hljs-keyword">if</span> (d[y] &gt; d[x] + edge[i]) &#123;</span><br><span class="line">                d[y] = d[x] + edge[i];</span><br><span class="line">                <span class="hljs-keyword">if</span> (!v[y]) q.push(y), v[y] = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a class="header-anchor" href="#最小生成树">¶</a>最小生成树</h3><h4 id="kruskal-算法"><a class="header-anchor" href="#kruskal-算法">¶</a>$Kruskal$算法</h4><p>  比较适合于稀疏图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5005</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, f[N];</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> u, v, w;</span><br><span class="line">    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (edge a, edge b) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (f[x] == x) <span class="hljs-keyword">return</span> x;</span><br><span class="line">    <span class="hljs-keyword">return</span> f[x] = find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">krusal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sort(e + <span class="hljs-number">1</span>, e + m + <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = find(e[i].u);</span><br><span class="line">        <span class="hljs-keyword">int</span> y = find(e[i].v);</span><br><span class="line">        <span class="hljs-keyword">if</span> (x != y) &#123;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            f[x] = y;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (cnt == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//不连通</span></span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prim-算法"><a class="header-anchor" href="#prim-算法">¶</a>$Prim$算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5005</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, ans;</span><br><span class="line"><span class="hljs-keyword">int</span> a[N][N], d[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="hljs-keyword">if</span> (!v[j] &amp;&amp; (x == <span class="hljs-number">0</span> || d[j] &lt; d[x])) x = j;</span><br><span class="line">        v[x] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">1</span>; y &lt;= n; ++y)</span><br><span class="line">            <span class="hljs-keyword">if</span> (!v[y]) d[y] = min(d[y], a[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>提高</h1><h2 id="图论-v2"><a class="header-anchor" href="#图论-v2">¶</a>图论</h2><h3 id="网络流初步"><a class="header-anchor" href="#网络流初步">¶</a>网络流初步</h3><h4 id="edmonds-karp"><a class="header-anchor" href="#edmonds-karp">¶</a>Edmonds-Karp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> n, m, s, t, maxflow, tot = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ver[M], edge[M], Next[M], head[N], v[N], incf[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">    ver[++tot] = x, edge[tot] = <span class="hljs-number">0</span>, Next[tot] = head[y], head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));</span><br><span class="line">    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s); v[s] = <span class="hljs-number">1</span>;</span><br><span class="line">    incf[s] = INF;</span><br><span class="line">    <span class="hljs-keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[x]; i; i = Next[i])</span><br><span class="line">            <span class="hljs-keyword">if</span> (edge[i]) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> y = ver[i];</span><br><span class="line">                <span class="hljs-keyword">if</span> (v[y]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                incf[y] = min(incf[x], edge[i]);</span><br><span class="line">                pre[y] = i;</span><br><span class="line">                q.push(y);</span><br><span class="line">                v[y] = <span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span> (y == t) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> x = t;</span><br><span class="line">        <span class="hljs-keyword">while</span> (x != s) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> i = pre[x];</span><br><span class="line">            edge[i] -= incf[t];</span><br><span class="line">            edge[i^<span class="hljs-number">1</span>] += incf[t];</span><br><span class="line">            x = ver[i^<span class="hljs-number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow += incf[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dinic"><a class="header-anchor" href="#dinic">¶</a>Dinic</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>附录</h1><h2 id="对拍"><a class="header-anchor" href="#对拍">¶</a>对拍</h2><p>$bat$语言版本</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="hljs-built_in">echo</span> off</span><br><span class="line"><span class="hljs-built_in">set</span> cnt=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> /l <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">do</span> (</span><br><span class="line">  mine.exe &lt; stdin<span class="hljs-variable">%%i</span>.txt &gt; out<span class="hljs-variable">%%i</span>.txt</span><br><span class="line">  fc out<span class="hljs-variable">%%i</span>.txt stdout<span class="hljs-variable">%%i</span>.txt &gt; diff<span class="hljs-variable">%%i</span>.txt</span><br><span class="line">  <span class="hljs-keyword">if</span> <span class="hljs-keyword">errorlevel</span> <span class="hljs-number">1</span> (</span><br><span class="line">    <span class="hljs-built_in">set</span> cnt=<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-variable">%%i</span>:UnAccepted!</span><br><span class="line">  )</span><br><span class="line">  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">errorlevel</span> <span class="hljs-number">1</span> (</span><br><span class="line">    <span class="hljs-built_in">del</span> diff<span class="hljs-variable">%%i</span>.txt</span><br><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-variable">%%i</span>:Accepted!</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-variable">%cnt%</span>==<span class="hljs-number">0</span> <span class="hljs-built_in">color</span> a &amp;&amp; <span class="hljs-built_in">echo</span> *** Totally Accepted! ***</span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-variable">%cnt%</span>==<span class="hljs-number">1</span> <span class="hljs-built_in">color</span> c &amp;&amp; <span class="hljs-built_in">echo</span> *** <span class="hljs-keyword">Not</span> All Accepted! ***</span><br><span class="line"><span class="hljs-built_in">pause</span></span><br></pre></td></tr></table></figure><h2 id="vim配置"><a class="header-anchor" href="#vim配置">¶</a>vim配置</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">syntax</span> enable</span><br><span class="line"><span class="hljs-keyword">syntax</span> <span class="hljs-keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-keyword">nu</span></span><br><span class="line"><span class="hljs-keyword">set</span> ruler</span><br><span class="line"><span class="hljs-keyword">set</span> cul</span><br><span class="line"><span class="hljs-keyword">set</span> tabstop=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-built_in">shiftwidth</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-keyword">set</span> expandtab</span><br><span class="line"><span class="hljs-keyword">set</span> autoindent</span><br><span class="line"><span class="hljs-keyword">set</span> nobackup</span><br><span class="line"><span class="hljs-keyword">set</span> paste</span><br><span class="line"><span class="hljs-keyword">set</span> incsearch</span><br><span class="line"><span class="hljs-keyword">set</span> showcmd</span><br><span class="line"><span class="hljs-keyword">set</span> showmatch</span><br><span class="line"><span class="hljs-keyword">set</span> ignorecase</span><br><span class="line"><span class="hljs-keyword">set</span> cin</span><br><span class="line"><span class="hljs-keyword">colo</span> evening</span><br><span class="line"><span class="hljs-keyword">set</span> mouse=<span class="hljs-keyword">a</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;F9&gt;</span> :<span class="hljs-keyword">call</span> CompileRun()<span class="hljs-symbol">&lt;CR&gt;</span></span><br><span class="line">func! CompileRun()</span><br><span class="line">    exec <span class="hljs-string">"w"</span></span><br><span class="line">    <span class="hljs-keyword">if</span> &amp;<span class="hljs-keyword">filetype</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'cpp'</span> || &amp;<span class="hljs-keyword">filetype</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'c'</span> || &amp;<span class="hljs-keyword">filetype</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'cc'</span></span><br><span class="line">        exec <span class="hljs-string">"!g++ -Wall % -0 %&lt;"</span></span><br><span class="line">        exec <span class="hljs-string">"!time ./%&lt;"</span></span><br><span class="line">    <span class="hljs-keyword">elseif</span> &amp;<span class="hljs-keyword">filetype</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'java'</span></span><br><span class="line">        exec <span class="hljs-string">"!javac\ -d\ .\ %"</span></span><br><span class="line">        exec <span class="hljs-string">"!javac\ %&lt;"</span></span><br><span class="line">    <span class="hljs-keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">call</span> plug#begin(<span class="hljs-string">'~/.vim/plugged'</span>)</span><br><span class="line"></span><br><span class="line">Plug <span class="hljs-string">'itchyny/lightline.vim'</span></span><br><span class="line">Plug <span class="hljs-string">'SirVer/ultisnips'</span></span><br><span class="line">Plug <span class="hljs-string">'honza/vim-snippets'</span></span><br><span class="line">Plug <span class="hljs-string">'preservim/nerdtree'</span>                      <span class="hljs-comment">" 目录树</span></span><br><span class="line">Plug <span class="hljs-string">'tiagofumo/vim-nerdtree-syntax-highlight'</span> <span class="hljs-comment">" 目录树美化</span></span><br><span class="line">Plug <span class="hljs-string">'vim-airline/vim-airline'</span>                 <span class="hljs-comment">" 状态栏美化</span></span><br><span class="line">Plug <span class="hljs-string">'vim-airline/vim-airline-themes'</span>          <span class="hljs-comment">" 状态栏美化主题</span></span><br><span class="line">Plug <span class="hljs-string">'scrooloose/syntastic'</span>                    <span class="hljs-comment">" 语法错误提示</span></span><br><span class="line">Plug <span class="hljs-string">'suan/vim-instant-markdown'</span>               <span class="hljs-comment">" markdown 实时预览</span></span><br><span class="line">Plug <span class="hljs-string">'ryanoasis/vim-devicons'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>POJ1845 Sumdiv</title>
      <link href="/Algorithm/POJ1845-Sumdiv/"/>
      <url>/Algorithm/POJ1845-Sumdiv/</url>
      
        <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1845" target="_blank" rel="noopener">$Sumdiv$</a></p><p>  <strong>题意</strong>: 求$A^B$的所有约数之和$\mod{9901}\left(1\leq A,B \leq5*10^7\right)$</p><p>  <strong>分析</strong>: A分解质因数为$p_1^{c_1}\times p_2^{c_2}\times\cdots\times p_n<sup>{c_n}$。那么$A</sup>B$表示为$p_1^{Bc_1}\times p_2^{Bc_2}\times\cdots\times p_n<sup>{Bc_n}$。$A</sup>B$的所有约数表示为集合${p_1^{k_1}\times p_2^{k_2}\times\cdots\times p_n^{k_n}}$，其中$0\leq k_i \leq B\times c_i\left(1\leq i \leq n\right)$</p><a id="more"></a> <p>  由乘法分配律, $A^B$的所有约数之和为:</p><p>$$\left(1+p_1+\cdots+p_1<sup>{B*c_1}\right)*\left(1+p_2+\cdots+p_2</sup>{B<em>c_2}\right)</em>\cdots\*\left(1+p_n+\cdots+p_n<sup>{B*c_n}\right)=\prod_{i=1}</sup>n\left(\sum_{j=0}<sup>{B*c_i}\left(p_i\right)</sup>j\right)$$</p><p>  括号内为等比数列，直接使用求和公式，需要做除法。答案还需对9901取模，mod运算只对加、减、乘有分配律，不能对分子分母取模后做除法，换一种思路，<strong>用分治法对等比数列求和</strong>。</p><p>  用分治法求$\displaystyle\sum_{i=1}<sup>cp</sup>i\quad\text{若c为奇数:}$<br>$$\sum_{i=1}<sup>cp</sup>i=\left(1+p+\cdots+p<sup>\frac{c-1}{2}\right)+\left(p</sup>\frac{c+1}{2}+\cdots+p<sup>c\right)\=\left(1+p+\cdots+p</sup>\frac{c-1}{2}\right)+p<sup>\frac{c+1}{2}*\left(1+p+\cdots+p</sup>\frac{c-1}{2}\right)\=(1+p<sup>\frac{c+1}{2})*\sum_{i=1}</sup>\frac{c+1}{2}p^i$$</p><p>  若c为偶数，类似有:</p><p>$$\sum_{i=1}<sup>cp</sup>i=(1+p<sup>\frac{c}{2})*\sum_{i=1}</sup>{\frac{c}{2}-1}p<sup>i+p</sup>c$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="hljs-keyword">const</span> ll N = <span class="hljs-number">1005</span>, MOD = <span class="hljs-number">9901</span>;</span><br><span class="line">pair&lt;ll, ll&gt; fac[N];</span><br><span class="line">ll cnt = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    ll res = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a % MOD)</span><br><span class="line">        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % MOD;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(ll p, ll c)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!c) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (c &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (qpow(p, (c + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>) * sum(p, c / <span class="hljs-number">2</span>) % MOD;</span><br><span class="line">    <span class="hljs-keyword">return</span> ((qpow(p, c / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>) * sum(p, c / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) + qpow(p, c)) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(ll n)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            ll num = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            fac[++cnt] = make_pair(i, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) fac[++cnt] = make_pair(n, <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">    divide(a);</span><br><span class="line">    ll ans = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        ll p = fac[i].first, c = fac[i].second;</span><br><span class="line">        ans = ans * sum(p, b * c) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, a == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test post</title>
      <link href="/Others/Test-post/"/>
      <url>/Others/Test-post/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇测试博文</p><p><a href="https://pandoc.org/MANUAL.html#pandocs-markdown" target="_blank" rel="noopener">pandoc教程</a></p><h1>$LaTex$</h1><p>下面教程摘自MITOPENCOURSEWARE</p><ul><li><a href="https://www.maths.tcd.ie/~dwilkins/LaTeXPrimer/" target="_blank" rel="noopener"><u>LaTeX Tutorial</u></a></li><li><a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener"><u>Draw a symbol to get its LaTeX command</u></a></li><li><a href="https://artofproblemsolving.com/wiki/index.php/LaTeX:Symbols" target="_blank" rel="noopener"><u>LaTeX Symbols</u></a></li></ul><a id="more"></a> <h1>Markdown</h1><p>Markdown教程现在已经烂大街了，在这里主要是作为备忘录进行查阅。</p><h2 id="typographic-replacements"><a class="header-anchor" href="#typographic-replacements">¶</a>Typographic replacements</h2><p>Enable typographer option to see result.</p><p>© © ® ® ™ ™ § § ±</p><p>test… test… test… test?.. test!..</p><p>!!! ??? ,  – —</p><h2 id="公式"><a class="header-anchor" href="#公式">¶</a>公式</h2><p>插入公式与代码分别是用$与 ` 符号(～键)包裹所写部分</p><ul><li>同时第一行反引号后面，写代码块所使用的语言。</li><li>使用 <code>\left</code>和 <code>\right</code>来创建自动匹配高度的 ()，[] 和 {} 。<br>在每个公式末尾前使用<code>\tag{行标}</code>来实现行标。</li></ul><h3 id="希腊字母"><a class="header-anchor" href="#希腊字母">¶</a>希腊字母</h3><table><thead><tr><th style="text-align:center">显示</th><th style="text-align:center">大写</th><th style="text-align:center">命令</th><th style="text-align:center">显示</th><th style="text-align:center">大写</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">$\alpha$</td><td style="text-align:center">$\rm{A}$</td><td style="text-align:center"><code>$\alpha$</code></td><td style="text-align:center">$\beta$</td><td style="text-align:center">$\rm{B}$</td><td style="text-align:center"><code>$\beta$</code></td></tr><tr><td style="text-align:center">$\gamma$</td><td style="text-align:center">$\Gamma$</td><td style="text-align:center"><code>$\gamma$</code></td><td style="text-align:center">$\delta$</td><td style="text-align:center">$\Delta$</td><td style="text-align:center"><code>$\delta$</code></td></tr><tr><td style="text-align:center">$\epsilon$</td><td style="text-align:center">$\rm{E}$</td><td style="text-align:center"><code>$\epsilon$</code></td><td style="text-align:center">$\zeta$</td><td style="text-align:center">$\rm{Z}$</td><td style="text-align:center"><code>$\zeta$</code></td></tr><tr><td style="text-align:center">$\eta$</td><td style="text-align:center">$\rm{H}$</td><td style="text-align:center"><code>$\eta$</code></td><td style="text-align:center">$\theta$</td><td style="text-align:center">$\Theta$</td><td style="text-align:center"><code>$\theta$</code></td></tr><tr><td style="text-align:center">$\iota$</td><td style="text-align:center">$\rm{I}$</td><td style="text-align:center"><code>$\iota$</code></td><td style="text-align:center">$\kappa$</td><td style="text-align:center">$\rm{K}$</td><td style="text-align:center"><code>$\kappa$</code></td></tr><tr><td style="text-align:center">$\lambda$</td><td style="text-align:center">$\Lambda$</td><td style="text-align:center"><code>$\lambda$</code></td><td style="text-align:center">$\mu$</td><td style="text-align:center">$\rm{M}$</td><td style="text-align:center"><code>$\mu$</code></td></tr><tr><td style="text-align:center">$\nu$</td><td style="text-align:center">$\rm{N}$</td><td style="text-align:center"><code>$\nu$</code></td><td style="text-align:center">$\xi$</td><td style="text-align:center">$\Xi$</td><td style="text-align:center"><code>$\xi$</code></td></tr><tr><td style="text-align:center">$\pi$</td><td style="text-align:center">$\Pi$</td><td style="text-align:center"><code>$\pi$</code></td><td style="text-align:center">$\rho$</td><td style="text-align:center">$\rm{R}$</td><td style="text-align:center"><code>$\rho$</code></td></tr><tr><td style="text-align:center">$\sigma$</td><td style="text-align:center">$\Sigma$</td><td style="text-align:center"><code>$\sigma$</code></td><td style="text-align:center">$\tau$</td><td style="text-align:center">$\rm{T}$</td><td style="text-align:center"><code>$\tau$</code></td></tr><tr><td style="text-align:center">$\upsilon$</td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center"><code>$\upsilon$</code></td><td style="text-align:center">$\phi$</td><td style="text-align:center">$\Phi$</td><td style="text-align:center"><code>$\phi$</code></td></tr><tr><td style="text-align:center">$\chi$</td><td style="text-align:center">$\rm{X}$</td><td style="text-align:center"><code>$\chi$</code></td><td style="text-align:center">$\psi$</td><td style="text-align:center">$\Psi$</td><td style="text-align:center"><code>$\psi$</code></td></tr><tr><td style="text-align:center">$\omega$</td><td style="text-align:center">$\Omega$</td><td style="text-align:center"><code>$\omega$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>\注:只需将命令的首字母大写即可得大写希腊字母，在命令前加上var前缀即可得到斜体希腊字母如:  $\Gamma\phi$ &amp; $\varGamma\varphi​$</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Gamma\phi$ &amp; $\varGamma\varphi​$</span><br></pre></td></tr></table></figure><h3 id="运算"><a class="header-anchor" href="#运算">¶</a>运算</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">显示</th><th style="text-align:center">命令</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>$\pm$</code></td><td style="text-align:center">$\pm$</td><td style="text-align:center"><code>$\mp$</code></td><td style="text-align:center">$\mp$</td></tr><tr><td style="text-align:center"><code>$\neq$</code></td><td style="text-align:center">$\neq$</td><td style="text-align:center"><code>$\times$</code></td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center"><code>$\div$</code></td><td style="text-align:center">$\div$</td><td style="text-align:center"><code>$\leq$</code></td><td style="text-align:center">$\leq$</td></tr><tr><td style="text-align:center"><code>$\geq$</code></td><td style="text-align:center">$\geq$</td><td style="text-align:center"><code>$\ngeq$</code></td><td style="text-align:center">$\ngeq$</td></tr><tr><td style="text-align:center"><code>$\ast$</code></td><td style="text-align:center">$\ast$</td><td style="text-align:center"><code>$\approx$</code></td><td style="text-align:center">$\approx$</td></tr><tr><td style="text-align:center"><code>$\equiv$</code></td><td style="text-align:center">$\equiv$</td><td style="text-align:center"><code>$bigcup$</code></td><td style="text-align:center">$\bigcup$</td></tr><tr><td style="text-align:center"><code>$\iint$</code></td><td style="text-align:center">$\iint$</td><td style="text-align:center"><code>$\iiint$</code></td><td style="text-align:center">$\iiint$</td></tr><tr><td style="text-align:center"><code>$\oint$</code></td><td style="text-align:center">$\oint$</td><td style="text-align:center"><code>$\mid$</code></td><td style="text-align:center">$\mid$</td></tr><tr><td style="text-align:center"><code>$\because$</code></td><td style="text-align:center">$\because$</td><td style="text-align:center"><code>\therefore</code></td><td style="text-align:center">$\therefore$</td></tr></tbody></table><h3 id="特殊符号"><a class="header-anchor" href="#特殊符号">¶</a>特殊符号</h3><table><thead><tr><th style="text-align:center">显示</th><th style="text-align:center">命令</th><th style="text-align:center">显示</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">$\infty$</td><td style="text-align:center"><code>$\infty$</code></td><td style="text-align:center">$\cup$</td><td style="text-align:center"><code>$\cup$</code></td></tr><tr><td style="text-align:center">$\cap$</td><td style="text-align:center"><code>$\cap$</code></td><td style="text-align:center">$\subset$</td><td style="text-align:center"><code>$\subset$</code></td></tr><tr><td style="text-align:center">$\subseteq$</td><td style="text-align:center"><code>$\subseteq$</code></td><td style="text-align:center">$\supset$</td><td style="text-align:center"><code>$\supset$</code></td></tr><tr><td style="text-align:center">$\in$</td><td style="text-align:center"><code>$\in$</code></td><td style="text-align:center">$\notin$</td><td style="text-align:center"><code>$\notin$</code></td></tr><tr><td style="text-align:center">$\varnothing$</td><td style="text-align:center"><code>$\varnothing$</code></td><td style="text-align:center">$\forall$</td><td style="text-align:center"><code>$\forall$</code></td></tr><tr><td style="text-align:center">$\exists$</td><td style="text-align:center"><code>$\exists$</code></td><td style="text-align:center">$\lnot$</td><td style="text-align:center"><code>$\lnot$</code></td></tr><tr><td style="text-align:center">$\nabla$</td><td style="text-align:center"><code>$\nabla$</code></td><td style="text-align:center">$\partial$</td><td style="text-align:center"><code>$\partial$</code></td></tr><tr><td style="text-align:center">$\angle$</td><td style="text-align:center"><code>$\angle$</code></td><td style="text-align:center">$\bot$</td><td style="text-align:center"><code>$\bot$</code></td></tr><tr><td style="text-align:center">$\bigodot$</td><td style="text-align:center"><code>$\bigodot$</code></td><td style="text-align:center">$\bigotimes$</td><td style="text-align:center"><code>$\bigotimes$</code></td></tr><tr><td style="text-align:center">$n\choose m$</td><td style="text-align:center"><code>$n\choose m$</code></td><td style="text-align:center">$\top$</td><td style="text-align:center"><code>$\top$</code></td></tr></tbody></table><h3 id="空格"><a class="header-anchor" href="#空格">¶</a>空格</h3><ul><li><code>$\,$</code> $\frac{1}{6}$m宽度</li><li><code>$\;$</code> $\frac{2}{7}$m宽度</li><li><code>$\$</code> $\frac{1}{3}$m宽度</li><li><code>$\quad$</code> m宽度</li><li><code>$\qquad$</code> 2m宽度</li></ul><h3 id="括号"><a class="header-anchor" href="#括号">¶</a>括号</h3><ul><li><code>\{</code>和<code>\}</code>或<code>\lbrace</code>和<code>\rbrace</code>: $\lbrace\rbrace$</li><li><code>\langle</code>和<code>\rangle</code>: $\langle\rangle$</li><li><code>\lceil</code>和<code>rceil</code>，<code>\lfoor</code>和 <code>\rfloor</code>: $\lceil\rceil\lfloor\rfloor$</li></ul><h3 id="矢量与箭头"><a class="header-anchor" href="#矢量与箭头">¶</a>矢量与箭头</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">显示</th><th style="text-align:center">命令</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>$\vec{a}$</code></td><td style="text-align:center">$\vec{a}$</td><td style="text-align:center"><code>$\bar{s}$</code></td><td style="text-align:center">$\bar{s}$ (平均值)</td></tr><tr><td style="text-align:center"><code>$\rightarrow$</code></td><td style="text-align:center">$\rightarrow$</td><td style="text-align:center"><code>$\Rightarrow$</code></td><td style="text-align:center">$\Rightarrow$</td></tr><tr><td style="text-align:center"><code>$\overrightarrow{a}$</code></td><td style="text-align:center">$\overrightarrow{a}$</td><td style="text-align:center"><code>$\overleftrightarrow{a}$</code></td><td style="text-align:center">$\overleftrightarrow{a}$</td></tr><tr><td style="text-align:center"><code>$\overleftarrow{a}$</code></td><td style="text-align:center">$\overleftarrow{a}$</td><td style="text-align:center"><code>$\longrightarrow$</code></td><td style="text-align:center">$\longrightarrow$</td></tr><tr><td style="text-align:center"><code>$\overline{a+b}$</code></td><td style="text-align:center">$\overline{a+b}$</td><td style="text-align:center"><code>$\underline{a+b}$</code></td><td style="text-align:center">$\underline{a+b}$</td></tr><tr><td style="text-align:center"><code>$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</code></td><td style="text-align:center">$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</td><td style="text-align:center"><code>$\hat{y}$</code></td><td style="text-align:center">$\hat{y}$</td></tr></tbody></table><h3 id="矩阵与方程组"><a class="header-anchor" href="#矩阵与方程组">¶</a>矩阵与方程组</h3><ul><li>pmatrix:<br><code>$\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$</code> : \begin{pmatrix}1 &amp; 2 \ 3 &amp; 4\ \end{pmatrix}</li><li>bmatrix:<br><code>$\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$</code> : \begin{bmatrix}1 &amp; 2 \ 3 &amp; 4\ \end{bmatrix}</li><li>Bmatrix:<br><code>$\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$</code> : \begin{Bmatrix}1 &amp; 2 \ 3 &amp; 4\ \end{Bmatrix}</li><li>vmatrix:<br><code>$\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$</code> : \begin{vmatrix}1 &amp; 2 \ 3 &amp; 4\ \end{vmatrix}</li><li>Vmatrix:<br><code>$\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$</code> : \begin{Vmatrix}1 &amp; 2 \ 3 &amp; 4\ \end{Vmatrix}</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125;</span><br><span class="line">a<span class="hljs-emphasis">_&#123;11&#125;&amp;a_</span>&#123;12&#125;&amp;\cdots&amp;a_&#123;1n&#125;\\</span><br><span class="line">a<span class="hljs-emphasis">_&#123;21&#125;&amp;a_</span>&#123;21&#125;&amp;\cdots&amp;a_&#123;2n&#125;\\</span><br><span class="line">\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line">a<span class="hljs-emphasis">_&#123;n1&#125;&amp;a_</span>&#123;n2&#125;&amp;\cdots&amp;a_&#123;nn&#125;\\</span><br><span class="line">\end&#123;matrix&#125;$$(类似有\ldots底端对齐)</span><br><span class="line">$$</span><br><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;array&#125;\</span><br><span class="line">a<span class="hljs-emphasis">_1x + a_</span>2y + a<span class="hljs-emphasis">_3z = d_</span>1 \\</span><br><span class="line">b<span class="hljs-emphasis">_1x + b_</span>2y + b<span class="hljs-emphasis">_3z = d_</span>2 \\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">$$(array亦可改为cases)</span><br><span class="line">$$\begin&#123;cases&#125; </span><br><span class="line"><span class="hljs-code">a_&#123;11&#125;x_1&amp;+&amp;a_&#123;12&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;1n&#125;x_n&amp;=&amp;b_1\\</span></span><br><span class="line"><span class="hljs-code">&amp;&amp;&amp;&amp;\vdots\\</span></span><br><span class="line"><span class="hljs-code">a_&#123;n1&#125;x_1&amp;+&amp;a_&#123;n2&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;nn&#125;x_n&amp;=&amp;b_n&amp;</span></span><br><span class="line">\end&#123;cases&#125;$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\left[  \begin&#123;array&#125;  &#123;c c | c&#125; %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">\hline %插入横线，如果去掉\hline就是增广矩阵</span><br><span class="line">4 &amp; 5 &amp; 6</span><br><span class="line">\end&#123;array&#125;  \right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$\begin{matrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\ \ a_{21}&amp;a_{21}&amp;\cdots&amp;a_{2n}\\ \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ \ a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\\ \end{matrix}$$</p><p>$$\begin{cases}<br>​a_{11}x_1&amp;+&amp;a_{12}x_2&amp;+&amp;\cdots&amp;+a_{1n}x_n&amp;=&amp;b_1\\ &amp;&amp;&amp;&amp;\vdots\\ a_{n1}x_1&amp;+&amp;a_{n2}x_2&amp;+&amp;\cdots&amp;+a_{nn}x_n&amp;=&amp;b_n&amp;<br>\end{cases}$$</p><p>$$\left[\begin{array}{c c | c}<br>1 &amp; 2 &amp; 3 \<br>\hline<br>4 &amp; 5 &amp; 6<br>\end{array}\right]$$</p><p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">公式快速参考</a></p><h2 id="表情"><a class="header-anchor" href="#表情">¶</a>表情</h2><table><thead><tr><th style="text-align:center">syntax</th><th style="text-align:center">preview</th><th style="text-align:center">syntax</th><th style="text-align:center">preview</th></tr></thead><tbody><tr><td style="text-align:center"><code>:sun_with_face:</code></td><td style="text-align:center">🌞</td><td style="text-align:center"><code>:smile:</code></td><td style="text-align:center">😄</td></tr><tr><td style="text-align:center"><code>:laughing:</code></td><td style="text-align:center">😆</td><td style="text-align:center"><code>:blush:</code></td><td style="text-align:center">😊</td></tr><tr><td style="text-align:center"><code>:smiley:</code></td><td style="text-align:center">😃</td><td style="text-align:center"><code>:relaxed:</code></td><td style="text-align:center">☺️</td></tr><tr><td style="text-align:center"><code>:smirk:</code></td><td style="text-align:center">😏</td><td style="text-align:center"><code>:heart_eyes:</code></td><td style="text-align:center">😍</td></tr><tr><td style="text-align:center"><code>:kissing_heart:</code></td><td style="text-align:center">😘</td><td style="text-align:center"><code>:kissing_closed_eyes:</code></td><td style="text-align:center">😚</td></tr><tr><td style="text-align:center"><code>:flushed:</code></td><td style="text-align:center">😳</td><td style="text-align:center"><code>:relieved:</code></td><td style="text-align:center">😌</td></tr><tr><td style="text-align:center"><code>:satisfied:</code></td><td style="text-align:center">😆</td><td style="text-align:center"><code>:grin:</code></td><td style="text-align:center">😁</td></tr><tr><td style="text-align:center"><code>:wink:</code></td><td style="text-align:center">😉</td><td style="text-align:center"><code>:stuck_out_tongue_winking_eye:</code></td><td style="text-align:center">😜</td></tr><tr><td style="text-align:center"><code>:stuck_out_tongue_closed_eyes:</code></td><td style="text-align:center">😝</td><td style="text-align:center"><code>:grinning:</code></td><td style="text-align:center">😀</td></tr><tr><td style="text-align:center"><code>:kissing:</code></td><td style="text-align:center">😗</td><td style="text-align:center"><code>:kissing_smiling_eyes:</code></td><td style="text-align:center">😙</td></tr><tr><td style="text-align:center"><code>:stuck_out_tongue:</code></td><td style="text-align:center">😛</td><td style="text-align:center"><code>:sleeping:</code></td><td style="text-align:center">😴</td></tr><tr><td style="text-align:center"><code>:worried:</code></td><td style="text-align:center">😟</td><td style="text-align:center"><code>:frowning:</code></td><td style="text-align:center">😦</td></tr><tr><td style="text-align:center"><code>:anguished:</code></td><td style="text-align:center">😧</td><td style="text-align:center"><code>:open_mouth:</code></td><td style="text-align:center">😮</td></tr><tr><td style="text-align:center"><code>:confused:</code></td><td style="text-align:center">😕</td><td style="text-align:center"><code>:hushed:</code></td><td style="text-align:center">😯</td></tr><tr><td style="text-align:center"><code>:expressionless:</code></td><td style="text-align:center">😑</td><td style="text-align:center"><code>:unamused:</code></td><td style="text-align:center">😒</td></tr><tr><td style="text-align:center"><code>:sweat_smile:</code></td><td style="text-align:center">😅</td><td style="text-align:center"><code>:sweat:</code></td><td style="text-align:center">😓</td></tr></tbody></table><h2 id="字体"><a class="header-anchor" href="#字体">¶</a>字体</h2><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th><th style="text-align:center">输入</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center"><code>$\rm{D}$</code></td><td style="text-align:center">罗马体</td><td style="text-align:center">$\rm{D}$</td><td style="text-align:center"><code>$\cal{D}$</code></td><td style="text-align:center">花体</td><td style="text-align:center">$\cal{D}$</td></tr><tr><td style="text-align:center"><code>$\it{D}$</code></td><td style="text-align:center">意大利体</td><td style="text-align:center">$\it{D}$</td><td style="text-align:center"><code>$\Bbb{D}$</code></td><td style="text-align:center">黑板粗体</td><td style="text-align:center">$\Bbb{D}$</td></tr><tr><td style="text-align:center"><code>$\bf{D}$</code></td><td style="text-align:center">粗体</td><td style="text-align:center">$\bf{D}$</td><td style="text-align:center"><code>$\mit{D}$</code></td><td style="text-align:center">数学斜体</td><td style="text-align:center">$\mit{D}$</td></tr><tr><td style="text-align:center"><code>$\sf{D}$</code></td><td style="text-align:center">等线体</td><td style="text-align:center">$\sf{D}$</td><td style="text-align:center"><code>$\scr{D}$</code></td><td style="text-align:center">手写体</td><td style="text-align:center">$\scr{D}$</td></tr><tr><td style="text-align:center"><code>$\tt{D}$</code></td><td style="text-align:center">打字机体</td><td style="text-align:center">$\tt{D}$</td><td style="text-align:center"><code>$\boldsymbol{D}$</code></td><td style="text-align:center">黑体</td><td style="text-align:center">$\boldsymbol{D}$</td></tr></tbody></table><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-strong">**加粗文字**</span> 对应 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span></span>加粗文字<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span> 及 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span></span>加粗文字<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span></span><br><span class="line"><span class="hljs-emphasis">*倾斜文字*</span> 对应 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span></span>倾斜文字<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span> 及 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span></span>倾斜文字<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span></span><br><span class="line"><span class="hljs-strong">***斜体加粗文字**</span>* </span><br><span class="line">~~加删除线文字~~ 对应 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span></span>加删除线文字<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>bold</strong> <strong>bold</strong></p><p><em>italic</em> <em>italic</em></p><p><s>Strikethrough</s></p><h2 id="颜色"><a class="header-anchor" href="#颜色">¶</a>颜色</h2><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">命令</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>$\color{red}{红色}$</code></td><td style="text-align:center"><code>&lt;font color=#FF0000&gt;红色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#FF0000">红色</font></td></tr><tr><td style="text-align:center"><code>$\color{green}{绿色}$</code></td><td style="text-align:center"><code>&lt;font color=#00FF00&gt;绿色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#00FF00">绿色</font></td></tr><tr><td style="text-align:center"><code>$\color{blue}{蓝色}$</code></td><td style="text-align:center"><code>&lt;font color=#0000FF&gt;蓝色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#0000FF">蓝色</font></td></tr><tr><td style="text-align:center"><code>$\color{cyan}{青色}$</code></td><td style="text-align:center"><code>&lt;font color=#00FFFF&gt;青色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#00FFFF">青色</font></td></tr><tr><td style="text-align:center"><code>$\color{yellow}{黄色}$</code></td><td style="text-align:center"><code>&lt;font color=#FFFF00&gt;黄色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#FFFF00">黄色</font></td></tr><tr><td style="text-align:center"><code>$\color{purple}{紫色}$</code></td><td style="text-align:center"><code>&lt;font color=#FF00FF&gt;紫色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#FF00FF">紫色</font></td></tr><tr><td style="text-align:center"><code>$\color{orange}{橙色}$</code></td><td style="text-align:center"><code>&lt;font color=#FF6100&gt;橙色&lt;/font&gt;</code></td><td style="text-align:center"><font color="#FF6100">橙色</font></td></tr></tbody></table><h2 id="引用"><a class="header-anchor" href="#引用">¶</a>引用</h2><p>多个&gt;用于逐层嵌套</p><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="分割线"><a class="header-anchor" href="#分割线">¶</a>分割线</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-emphasis">___</span></span><br><span class="line">---</span><br><span class="line"><span class="hljs-emphasis">***</span></span><br></pre></td></tr></table></figure><h2 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h2><ul><li>无序列表使用*或+或-标识</li><li>有序列表使用数字加.标识，例如：1.</li></ul><p>Unordered</p><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li>Sub-lists are made by indenting 2 spaces:<ul><li>Marker character change forces new list start:<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><p>Ordered</p><ol><li>Lorem ipsum dolor sit amet</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><h2 id="表格"><a class="header-anchor" href="#表格">¶</a>表格</h2><p>短斜杠(数量至少有一个)左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头|条目一|条目二</span><br><span class="line">:-:|:-:|:-:</span><br><span class="line">1|2|3</span><br><span class="line">4|5|6</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">表头</th><th style="text-align:center">条目一</th><th style="text-align:center">条目二</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table><h2 id="pandoc-版-markdown-与标准版的区别"><a class="header-anchor" href="#pandoc-版-markdown-与标准版的区别">¶</a>$pandoc$版$markdown$与标准版的区别</h2><p>标准Markdown语法并不要求在标题前添加一个空行，但是Pandoc语法却要求标题前添加一个空行（除了文档开头）</p><h1>Html</h1><p><a href="https://www.w3school.com.cn/tags/index.asp" target="_blank" rel="noopener">学习的地方</a></p><h2 id="基本文档"><a class="header-anchor" href="#基本文档">¶</a>基本文档</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文档标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">可见文本...</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> （换行）</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基本元素"><a class="header-anchor" href="#基本元素">¶</a>基本元素</h2><p><b>粗体文本</b></p><p><code class="language-cpp">int exgcd(int x, int y, int &amp;a, int &amp;b) {<br>if (y == 0) {<br>return a = 1, b = 0, x;<br>} else {<br>int g = exgcd(y, x % y, b, a);<br>b -= x / y * a;<br>return g;<br>}<br>}</code></p><p><em>强调文本</em><br><i>斜体文本</i><br><kbd>键盘输入</kbd></p><pre>预格式化文本</pre><p><small>更小的文本</small><br><strong>重要的文本</strong><br><abbr>缩写</abbr><br></p><address>联系信息</address><bdo>文字方向</bdo><blockquote>从另一个源引用的部分</blockquote><cite>工作的名称</cite> <del>删除的文本</del> <ins>插入的文本</ins><sub>下标文本</sub><sup>上标文本</sup>本<h2 id="列表与表格"><a class="header-anchor" href="#列表与表格">¶</a>列表与表格</h2><ul><li>Coffee</li><li>Milk</li></ul><ol><li>Cola</li><li>sara</li></ol><table border="1">    <tr>        <th>Header 1</th><th>Header 2</th>    </tr>    <tr>        <td>row 1, cell 1</td><td>row 1, cell 2</td>    </tr>    <tr>        <td>row 2, cell 1</td><td>row 2, cell 2</td>    </tr></table><br><table><tr>  <th>January <dialog open>This is an open dialog window</dialog></th>  <th>February</th>  <th>March</th></tr><tr>  <td>31</td>  <td>28</td>  <td>31</td></tr></table><h2 id="图片"><a class="header-anchor" href="#图片">¶</a>图片</h2><p>书签：<br><a id="tips">提示部分</a><br><a href="#tips">跳到提示部分</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt; template&lt;typename T&gt; //长度测试////////////////////////////////////////////////////////////////////////////////////////////////////////end</span></span></span><br></pre></td></tr></table></figure><h2 id="框架"><a class="header-anchor" href="#框架">¶</a>框架</h2><iframe src="https://blog.csdn.net/AbelYang1" width="400" height="300"></iframe><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=167827&auto=0&height=66"></iframe><script>    document.write("Hello World!")</script><p><noscript>抱歉，你的浏览器不支持 JavaScript!</noscript></p><details>  <summary>Copyright 1999-2018.</summary>  <p> - by Refsnes Data. All Rights Reserved.</p>  <p>All content and graphics on this web site are the property of the company Refsnes Data.</p></details><p style="font-family:'Courier New'">This is another paragraph.</p><style type="text/css">span.highlight{background-color:yellow}</style><p><span class="highlight">这是文本。</span></p><p>The <dfn title="World Health Organization">WHO</dfn> was founded in 1948.</p><p><a href="http://www.w3school.com.cn/" target="_blank">Visit W3School!</a></p><p><a href="/index.html" target="_top">请点击这里！</a></p><footer>  <p>Posted by: 2inf</p>  <p>Contact information: <a href="2inf.top@gmail.com">  2inf.top@gmail.com</a>.</p></footer>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
